
C:\Users\chen\Desktop\projects\jsk_imu_mini\TrueSTUDIO\jsk_imu_mini\Debug\jsk_imu_mini.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00008804  080001c8  080001c8  000101c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000d3c  080089cc  080089cc  000189cc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000108  08009708  08009708  00019708  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM          00000380  08009810  08009810  00019810  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .init_array   00000008  08009b90  08009b90  00019b90  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .fini_array   00000004  08009b98  08009b98  00019b98  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .data         00000514  20000000  08009b9c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00003940  20000514  0800a0b0  00020514  2**2
                  ALLOC
  9 ._user_heap_stack 00000600  20003e54  0800a0b0  00023e54  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00020514  2**0
                  CONTENTS, READONLY
 11 .debug_line   00008ee4  00000000  00000000  00020544  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00029cb2  00000000  00000000  00029428  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000047af  00000000  00000000  000530da  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001030  00000000  00000000  00057890  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001778  00000000  00000000  000588c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00009763  00000000  00000000  0005a038  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00012084  00000000  00000000  0006379b  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007e  00000000  00000000  0007581f  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00004490  00000000  00000000  000758a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .stab         0000003c  00000000  00000000  00079d30  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stabstr      00000076  00000000  00000000  00079d6c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001c8 <__do_global_dtors_aux>:
 80001c8:	b510      	push	{r4, lr}
 80001ca:	4c05      	ldr	r4, [pc, #20]	; (80001e0 <__do_global_dtors_aux+0x18>)
 80001cc:	7823      	ldrb	r3, [r4, #0]
 80001ce:	b933      	cbnz	r3, 80001de <__do_global_dtors_aux+0x16>
 80001d0:	4b04      	ldr	r3, [pc, #16]	; (80001e4 <__do_global_dtors_aux+0x1c>)
 80001d2:	b113      	cbz	r3, 80001da <__do_global_dtors_aux+0x12>
 80001d4:	4804      	ldr	r0, [pc, #16]	; (80001e8 <__do_global_dtors_aux+0x20>)
 80001d6:	f3af 8000 	nop.w
 80001da:	2301      	movs	r3, #1
 80001dc:	7023      	strb	r3, [r4, #0]
 80001de:	bd10      	pop	{r4, pc}
 80001e0:	20000514 	.word	0x20000514
 80001e4:	00000000 	.word	0x00000000
 80001e8:	080089b4 	.word	0x080089b4

080001ec <frame_dummy>:
 80001ec:	b508      	push	{r3, lr}
 80001ee:	4b03      	ldr	r3, [pc, #12]	; (80001fc <frame_dummy+0x10>)
 80001f0:	b11b      	cbz	r3, 80001fa <frame_dummy+0xe>
 80001f2:	4903      	ldr	r1, [pc, #12]	; (8000200 <frame_dummy+0x14>)
 80001f4:	4803      	ldr	r0, [pc, #12]	; (8000204 <frame_dummy+0x18>)
 80001f6:	f3af 8000 	nop.w
 80001fa:	bd08      	pop	{r3, pc}
 80001fc:	00000000 	.word	0x00000000
 8000200:	20000518 	.word	0x20000518
 8000204:	080089b4 	.word	0x080089b4

08000208 <strcmp>:
 8000208:	f810 2b01 	ldrb.w	r2, [r0], #1
 800020c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000210:	2a01      	cmp	r2, #1
 8000212:	bf28      	it	cs
 8000214:	429a      	cmpcs	r2, r3
 8000216:	d0f7      	beq.n	8000208 <strcmp>
 8000218:	1ad0      	subs	r0, r2, r3
 800021a:	4770      	bx	lr

0800021c <strlen>:
 800021c:	4603      	mov	r3, r0
 800021e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000222:	2a00      	cmp	r2, #0
 8000224:	d1fb      	bne.n	800021e <strlen+0x2>
 8000226:	1a18      	subs	r0, r3, r0
 8000228:	3801      	subs	r0, #1
 800022a:	4770      	bx	lr

0800022c <__aeabi_uldivmod>:
 800022c:	b953      	cbnz	r3, 8000244 <__aeabi_uldivmod+0x18>
 800022e:	b94a      	cbnz	r2, 8000244 <__aeabi_uldivmod+0x18>
 8000230:	2900      	cmp	r1, #0
 8000232:	bf08      	it	eq
 8000234:	2800      	cmpeq	r0, #0
 8000236:	bf1c      	itt	ne
 8000238:	f04f 31ff 	movne.w	r1, #4294967295
 800023c:	f04f 30ff 	movne.w	r0, #4294967295
 8000240:	f001 b8ec 	b.w	800141c <__aeabi_idiv0>
 8000244:	f1ad 0c08 	sub.w	ip, sp, #8
 8000248:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800024c:	f000 f806 	bl	800025c <__udivmoddi4>
 8000250:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000254:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000258:	b004      	add	sp, #16
 800025a:	4770      	bx	lr

0800025c <__udivmoddi4>:
 800025c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000260:	468c      	mov	ip, r1
 8000262:	460e      	mov	r6, r1
 8000264:	4604      	mov	r4, r0
 8000266:	9d08      	ldr	r5, [sp, #32]
 8000268:	2b00      	cmp	r3, #0
 800026a:	d150      	bne.n	800030e <__udivmoddi4+0xb2>
 800026c:	428a      	cmp	r2, r1
 800026e:	4617      	mov	r7, r2
 8000270:	d96c      	bls.n	800034c <__udivmoddi4+0xf0>
 8000272:	fab2 fe82 	clz	lr, r2
 8000276:	f1be 0f00 	cmp.w	lr, #0
 800027a:	d00b      	beq.n	8000294 <__udivmoddi4+0x38>
 800027c:	f1ce 0420 	rsb	r4, lr, #32
 8000280:	fa20 f404 	lsr.w	r4, r0, r4
 8000284:	fa01 f60e 	lsl.w	r6, r1, lr
 8000288:	ea44 0c06 	orr.w	ip, r4, r6
 800028c:	fa02 f70e 	lsl.w	r7, r2, lr
 8000290:	fa00 f40e 	lsl.w	r4, r0, lr
 8000294:	ea4f 4917 	mov.w	r9, r7, lsr #16
 8000298:	0c22      	lsrs	r2, r4, #16
 800029a:	fbbc f0f9 	udiv	r0, ip, r9
 800029e:	fa1f f887 	uxth.w	r8, r7
 80002a2:	fb09 c610 	mls	r6, r9, r0, ip
 80002a6:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 80002aa:	fb00 f308 	mul.w	r3, r0, r8
 80002ae:	42b3      	cmp	r3, r6
 80002b0:	d909      	bls.n	80002c6 <__udivmoddi4+0x6a>
 80002b2:	19f6      	adds	r6, r6, r7
 80002b4:	f100 32ff 	add.w	r2, r0, #4294967295
 80002b8:	f080 8122 	bcs.w	8000500 <__udivmoddi4+0x2a4>
 80002bc:	42b3      	cmp	r3, r6
 80002be:	f240 811f 	bls.w	8000500 <__udivmoddi4+0x2a4>
 80002c2:	3802      	subs	r0, #2
 80002c4:	443e      	add	r6, r7
 80002c6:	1af6      	subs	r6, r6, r3
 80002c8:	b2a2      	uxth	r2, r4
 80002ca:	fbb6 f3f9 	udiv	r3, r6, r9
 80002ce:	fb09 6613 	mls	r6, r9, r3, r6
 80002d2:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 80002d6:	fb03 f808 	mul.w	r8, r3, r8
 80002da:	45a0      	cmp	r8, r4
 80002dc:	d909      	bls.n	80002f2 <__udivmoddi4+0x96>
 80002de:	19e4      	adds	r4, r4, r7
 80002e0:	f103 32ff 	add.w	r2, r3, #4294967295
 80002e4:	f080 810a 	bcs.w	80004fc <__udivmoddi4+0x2a0>
 80002e8:	45a0      	cmp	r8, r4
 80002ea:	f240 8107 	bls.w	80004fc <__udivmoddi4+0x2a0>
 80002ee:	3b02      	subs	r3, #2
 80002f0:	443c      	add	r4, r7
 80002f2:	ebc8 0404 	rsb	r4, r8, r4
 80002f6:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80002fa:	2100      	movs	r1, #0
 80002fc:	2d00      	cmp	r5, #0
 80002fe:	d062      	beq.n	80003c6 <__udivmoddi4+0x16a>
 8000300:	fa24 f40e 	lsr.w	r4, r4, lr
 8000304:	2300      	movs	r3, #0
 8000306:	602c      	str	r4, [r5, #0]
 8000308:	606b      	str	r3, [r5, #4]
 800030a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800030e:	428b      	cmp	r3, r1
 8000310:	d907      	bls.n	8000322 <__udivmoddi4+0xc6>
 8000312:	2d00      	cmp	r5, #0
 8000314:	d055      	beq.n	80003c2 <__udivmoddi4+0x166>
 8000316:	2100      	movs	r1, #0
 8000318:	e885 0041 	stmia.w	r5, {r0, r6}
 800031c:	4608      	mov	r0, r1
 800031e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000322:	fab3 f183 	clz	r1, r3
 8000326:	2900      	cmp	r1, #0
 8000328:	f040 8090 	bne.w	800044c <__udivmoddi4+0x1f0>
 800032c:	42b3      	cmp	r3, r6
 800032e:	d302      	bcc.n	8000336 <__udivmoddi4+0xda>
 8000330:	4282      	cmp	r2, r0
 8000332:	f200 80f8 	bhi.w	8000526 <__udivmoddi4+0x2ca>
 8000336:	1a84      	subs	r4, r0, r2
 8000338:	eb66 0603 	sbc.w	r6, r6, r3
 800033c:	2001      	movs	r0, #1
 800033e:	46b4      	mov	ip, r6
 8000340:	2d00      	cmp	r5, #0
 8000342:	d040      	beq.n	80003c6 <__udivmoddi4+0x16a>
 8000344:	e885 1010 	stmia.w	r5, {r4, ip}
 8000348:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800034c:	b912      	cbnz	r2, 8000354 <__udivmoddi4+0xf8>
 800034e:	2701      	movs	r7, #1
 8000350:	fbb7 f7f2 	udiv	r7, r7, r2
 8000354:	fab7 fe87 	clz	lr, r7
 8000358:	f1be 0f00 	cmp.w	lr, #0
 800035c:	d135      	bne.n	80003ca <__udivmoddi4+0x16e>
 800035e:	1bf3      	subs	r3, r6, r7
 8000360:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000364:	fa1f fc87 	uxth.w	ip, r7
 8000368:	2101      	movs	r1, #1
 800036a:	fbb3 f0f8 	udiv	r0, r3, r8
 800036e:	0c22      	lsrs	r2, r4, #16
 8000370:	fb08 3610 	mls	r6, r8, r0, r3
 8000374:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 8000378:	fb0c f300 	mul.w	r3, ip, r0
 800037c:	42b3      	cmp	r3, r6
 800037e:	d907      	bls.n	8000390 <__udivmoddi4+0x134>
 8000380:	19f6      	adds	r6, r6, r7
 8000382:	f100 32ff 	add.w	r2, r0, #4294967295
 8000386:	d202      	bcs.n	800038e <__udivmoddi4+0x132>
 8000388:	42b3      	cmp	r3, r6
 800038a:	f200 80ce 	bhi.w	800052a <__udivmoddi4+0x2ce>
 800038e:	4610      	mov	r0, r2
 8000390:	1af6      	subs	r6, r6, r3
 8000392:	b2a2      	uxth	r2, r4
 8000394:	fbb6 f3f8 	udiv	r3, r6, r8
 8000398:	fb08 6613 	mls	r6, r8, r3, r6
 800039c:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 80003a0:	fb0c fc03 	mul.w	ip, ip, r3
 80003a4:	45a4      	cmp	ip, r4
 80003a6:	d907      	bls.n	80003b8 <__udivmoddi4+0x15c>
 80003a8:	19e4      	adds	r4, r4, r7
 80003aa:	f103 32ff 	add.w	r2, r3, #4294967295
 80003ae:	d202      	bcs.n	80003b6 <__udivmoddi4+0x15a>
 80003b0:	45a4      	cmp	ip, r4
 80003b2:	f200 80b5 	bhi.w	8000520 <__udivmoddi4+0x2c4>
 80003b6:	4613      	mov	r3, r2
 80003b8:	ebcc 0404 	rsb	r4, ip, r4
 80003bc:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80003c0:	e79c      	b.n	80002fc <__udivmoddi4+0xa0>
 80003c2:	4629      	mov	r1, r5
 80003c4:	4628      	mov	r0, r5
 80003c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003ca:	f1ce 0120 	rsb	r1, lr, #32
 80003ce:	fa06 f30e 	lsl.w	r3, r6, lr
 80003d2:	fa07 f70e 	lsl.w	r7, r7, lr
 80003d6:	fa20 f901 	lsr.w	r9, r0, r1
 80003da:	ea4f 4817 	mov.w	r8, r7, lsr #16
 80003de:	40ce      	lsrs	r6, r1
 80003e0:	ea49 0903 	orr.w	r9, r9, r3
 80003e4:	fbb6 faf8 	udiv	sl, r6, r8
 80003e8:	ea4f 4419 	mov.w	r4, r9, lsr #16
 80003ec:	fb08 661a 	mls	r6, r8, sl, r6
 80003f0:	fa1f fc87 	uxth.w	ip, r7
 80003f4:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
 80003f8:	fb0a f20c 	mul.w	r2, sl, ip
 80003fc:	429a      	cmp	r2, r3
 80003fe:	fa00 f40e 	lsl.w	r4, r0, lr
 8000402:	d90a      	bls.n	800041a <__udivmoddi4+0x1be>
 8000404:	19db      	adds	r3, r3, r7
 8000406:	f10a 31ff 	add.w	r1, sl, #4294967295
 800040a:	f080 8087 	bcs.w	800051c <__udivmoddi4+0x2c0>
 800040e:	429a      	cmp	r2, r3
 8000410:	f240 8084 	bls.w	800051c <__udivmoddi4+0x2c0>
 8000414:	f1aa 0a02 	sub.w	sl, sl, #2
 8000418:	443b      	add	r3, r7
 800041a:	1a9b      	subs	r3, r3, r2
 800041c:	fa1f f989 	uxth.w	r9, r9
 8000420:	fbb3 f1f8 	udiv	r1, r3, r8
 8000424:	fb08 3311 	mls	r3, r8, r1, r3
 8000428:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
 800042c:	fb01 f60c 	mul.w	r6, r1, ip
 8000430:	429e      	cmp	r6, r3
 8000432:	d907      	bls.n	8000444 <__udivmoddi4+0x1e8>
 8000434:	19db      	adds	r3, r3, r7
 8000436:	f101 32ff 	add.w	r2, r1, #4294967295
 800043a:	d26b      	bcs.n	8000514 <__udivmoddi4+0x2b8>
 800043c:	429e      	cmp	r6, r3
 800043e:	d969      	bls.n	8000514 <__udivmoddi4+0x2b8>
 8000440:	3902      	subs	r1, #2
 8000442:	443b      	add	r3, r7
 8000444:	1b9b      	subs	r3, r3, r6
 8000446:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 800044a:	e78e      	b.n	800036a <__udivmoddi4+0x10e>
 800044c:	f1c1 0e20 	rsb	lr, r1, #32
 8000450:	fa22 f40e 	lsr.w	r4, r2, lr
 8000454:	408b      	lsls	r3, r1
 8000456:	4323      	orrs	r3, r4
 8000458:	fa20 f70e 	lsr.w	r7, r0, lr
 800045c:	fa06 f401 	lsl.w	r4, r6, r1
 8000460:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000464:	fa26 f60e 	lsr.w	r6, r6, lr
 8000468:	433c      	orrs	r4, r7
 800046a:	fbb6 f9fc 	udiv	r9, r6, ip
 800046e:	0c27      	lsrs	r7, r4, #16
 8000470:	fb0c 6619 	mls	r6, ip, r9, r6
 8000474:	fa1f f883 	uxth.w	r8, r3
 8000478:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
 800047c:	fb09 f708 	mul.w	r7, r9, r8
 8000480:	42b7      	cmp	r7, r6
 8000482:	fa02 f201 	lsl.w	r2, r2, r1
 8000486:	fa00 fa01 	lsl.w	sl, r0, r1
 800048a:	d908      	bls.n	800049e <__udivmoddi4+0x242>
 800048c:	18f6      	adds	r6, r6, r3
 800048e:	f109 30ff 	add.w	r0, r9, #4294967295
 8000492:	d241      	bcs.n	8000518 <__udivmoddi4+0x2bc>
 8000494:	42b7      	cmp	r7, r6
 8000496:	d93f      	bls.n	8000518 <__udivmoddi4+0x2bc>
 8000498:	f1a9 0902 	sub.w	r9, r9, #2
 800049c:	441e      	add	r6, r3
 800049e:	1bf6      	subs	r6, r6, r7
 80004a0:	b2a0      	uxth	r0, r4
 80004a2:	fbb6 f4fc 	udiv	r4, r6, ip
 80004a6:	fb0c 6614 	mls	r6, ip, r4, r6
 80004aa:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
 80004ae:	fb04 f808 	mul.w	r8, r4, r8
 80004b2:	45b8      	cmp	r8, r7
 80004b4:	d907      	bls.n	80004c6 <__udivmoddi4+0x26a>
 80004b6:	18ff      	adds	r7, r7, r3
 80004b8:	f104 30ff 	add.w	r0, r4, #4294967295
 80004bc:	d228      	bcs.n	8000510 <__udivmoddi4+0x2b4>
 80004be:	45b8      	cmp	r8, r7
 80004c0:	d926      	bls.n	8000510 <__udivmoddi4+0x2b4>
 80004c2:	3c02      	subs	r4, #2
 80004c4:	441f      	add	r7, r3
 80004c6:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
 80004ca:	ebc8 0707 	rsb	r7, r8, r7
 80004ce:	fba0 8902 	umull	r8, r9, r0, r2
 80004d2:	454f      	cmp	r7, r9
 80004d4:	4644      	mov	r4, r8
 80004d6:	464e      	mov	r6, r9
 80004d8:	d314      	bcc.n	8000504 <__udivmoddi4+0x2a8>
 80004da:	d029      	beq.n	8000530 <__udivmoddi4+0x2d4>
 80004dc:	b365      	cbz	r5, 8000538 <__udivmoddi4+0x2dc>
 80004de:	ebba 0304 	subs.w	r3, sl, r4
 80004e2:	eb67 0706 	sbc.w	r7, r7, r6
 80004e6:	fa07 fe0e 	lsl.w	lr, r7, lr
 80004ea:	40cb      	lsrs	r3, r1
 80004ec:	40cf      	lsrs	r7, r1
 80004ee:	ea4e 0303 	orr.w	r3, lr, r3
 80004f2:	e885 0088 	stmia.w	r5, {r3, r7}
 80004f6:	2100      	movs	r1, #0
 80004f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004fc:	4613      	mov	r3, r2
 80004fe:	e6f8      	b.n	80002f2 <__udivmoddi4+0x96>
 8000500:	4610      	mov	r0, r2
 8000502:	e6e0      	b.n	80002c6 <__udivmoddi4+0x6a>
 8000504:	ebb8 0402 	subs.w	r4, r8, r2
 8000508:	eb69 0603 	sbc.w	r6, r9, r3
 800050c:	3801      	subs	r0, #1
 800050e:	e7e5      	b.n	80004dc <__udivmoddi4+0x280>
 8000510:	4604      	mov	r4, r0
 8000512:	e7d8      	b.n	80004c6 <__udivmoddi4+0x26a>
 8000514:	4611      	mov	r1, r2
 8000516:	e795      	b.n	8000444 <__udivmoddi4+0x1e8>
 8000518:	4681      	mov	r9, r0
 800051a:	e7c0      	b.n	800049e <__udivmoddi4+0x242>
 800051c:	468a      	mov	sl, r1
 800051e:	e77c      	b.n	800041a <__udivmoddi4+0x1be>
 8000520:	3b02      	subs	r3, #2
 8000522:	443c      	add	r4, r7
 8000524:	e748      	b.n	80003b8 <__udivmoddi4+0x15c>
 8000526:	4608      	mov	r0, r1
 8000528:	e70a      	b.n	8000340 <__udivmoddi4+0xe4>
 800052a:	3802      	subs	r0, #2
 800052c:	443e      	add	r6, r7
 800052e:	e72f      	b.n	8000390 <__udivmoddi4+0x134>
 8000530:	45c2      	cmp	sl, r8
 8000532:	d3e7      	bcc.n	8000504 <__udivmoddi4+0x2a8>
 8000534:	463e      	mov	r6, r7
 8000536:	e7d1      	b.n	80004dc <__udivmoddi4+0x280>
 8000538:	4629      	mov	r1, r5
 800053a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800053e:	bf00      	nop

08000540 <selfrel_offset31>:
 8000540:	6803      	ldr	r3, [r0, #0]
 8000542:	005a      	lsls	r2, r3, #1
 8000544:	bf4c      	ite	mi
 8000546:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 800054a:	f023 4300 	bicpl.w	r3, r3, #2147483648	; 0x80000000
 800054e:	4418      	add	r0, r3
 8000550:	4770      	bx	lr
 8000552:	bf00      	nop

08000554 <search_EIT_table>:
 8000554:	b361      	cbz	r1, 80005b0 <search_EIT_table+0x5c>
 8000556:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800055a:	f101 3aff 	add.w	sl, r1, #4294967295
 800055e:	4690      	mov	r8, r2
 8000560:	4606      	mov	r6, r0
 8000562:	46d1      	mov	r9, sl
 8000564:	2700      	movs	r7, #0
 8000566:	eb07 0409 	add.w	r4, r7, r9
 800056a:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
 800056e:	1064      	asrs	r4, r4, #1
 8000570:	00e5      	lsls	r5, r4, #3
 8000572:	1971      	adds	r1, r6, r5
 8000574:	4608      	mov	r0, r1
 8000576:	f7ff ffe3 	bl	8000540 <selfrel_offset31>
 800057a:	45a2      	cmp	sl, r4
 800057c:	4683      	mov	fp, r0
 800057e:	f105 0008 	add.w	r0, r5, #8
 8000582:	4430      	add	r0, r6
 8000584:	d009      	beq.n	800059a <search_EIT_table+0x46>
 8000586:	f7ff ffdb 	bl	8000540 <selfrel_offset31>
 800058a:	45c3      	cmp	fp, r8
 800058c:	f100 30ff 	add.w	r0, r0, #4294967295
 8000590:	d805      	bhi.n	800059e <search_EIT_table+0x4a>
 8000592:	4540      	cmp	r0, r8
 8000594:	d209      	bcs.n	80005aa <search_EIT_table+0x56>
 8000596:	1c67      	adds	r7, r4, #1
 8000598:	e7e5      	b.n	8000566 <search_EIT_table+0x12>
 800059a:	45c3      	cmp	fp, r8
 800059c:	d905      	bls.n	80005aa <search_EIT_table+0x56>
 800059e:	42a7      	cmp	r7, r4
 80005a0:	d002      	beq.n	80005a8 <search_EIT_table+0x54>
 80005a2:	f104 39ff 	add.w	r9, r4, #4294967295
 80005a6:	e7de      	b.n	8000566 <search_EIT_table+0x12>
 80005a8:	2100      	movs	r1, #0
 80005aa:	4608      	mov	r0, r1
 80005ac:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80005b0:	4608      	mov	r0, r1
 80005b2:	4770      	bx	lr

080005b4 <__gnu_unwind_get_pr_addr>:
 80005b4:	2801      	cmp	r0, #1
 80005b6:	d007      	beq.n	80005c8 <__gnu_unwind_get_pr_addr+0x14>
 80005b8:	2802      	cmp	r0, #2
 80005ba:	d007      	beq.n	80005cc <__gnu_unwind_get_pr_addr+0x18>
 80005bc:	4b04      	ldr	r3, [pc, #16]	; (80005d0 <__gnu_unwind_get_pr_addr+0x1c>)
 80005be:	2800      	cmp	r0, #0
 80005c0:	bf0c      	ite	eq
 80005c2:	4618      	moveq	r0, r3
 80005c4:	2000      	movne	r0, #0
 80005c6:	4770      	bx	lr
 80005c8:	4802      	ldr	r0, [pc, #8]	; (80005d4 <__gnu_unwind_get_pr_addr+0x20>)
 80005ca:	4770      	bx	lr
 80005cc:	4802      	ldr	r0, [pc, #8]	; (80005d8 <__gnu_unwind_get_pr_addr+0x24>)
 80005ce:	4770      	bx	lr
 80005d0:	08000cc1 	.word	0x08000cc1
 80005d4:	08000cc5 	.word	0x08000cc5
 80005d8:	08000cc9 	.word	0x08000cc9

080005dc <get_eit_entry>:
 80005dc:	b530      	push	{r4, r5, lr}
 80005de:	4b24      	ldr	r3, [pc, #144]	; (8000670 <get_eit_entry+0x94>)
 80005e0:	b083      	sub	sp, #12
 80005e2:	4604      	mov	r4, r0
 80005e4:	1e8d      	subs	r5, r1, #2
 80005e6:	b37b      	cbz	r3, 8000648 <get_eit_entry+0x6c>
 80005e8:	a901      	add	r1, sp, #4
 80005ea:	4628      	mov	r0, r5
 80005ec:	f3af 8000 	nop.w
 80005f0:	b320      	cbz	r0, 800063c <get_eit_entry+0x60>
 80005f2:	9901      	ldr	r1, [sp, #4]
 80005f4:	462a      	mov	r2, r5
 80005f6:	f7ff ffad 	bl	8000554 <search_EIT_table>
 80005fa:	4601      	mov	r1, r0
 80005fc:	b1f0      	cbz	r0, 800063c <get_eit_entry+0x60>
 80005fe:	f7ff ff9f 	bl	8000540 <selfrel_offset31>
 8000602:	684b      	ldr	r3, [r1, #4]
 8000604:	64a0      	str	r0, [r4, #72]	; 0x48
 8000606:	2b01      	cmp	r3, #1
 8000608:	d012      	beq.n	8000630 <get_eit_entry+0x54>
 800060a:	2b00      	cmp	r3, #0
 800060c:	f101 0004 	add.w	r0, r1, #4
 8000610:	db20      	blt.n	8000654 <get_eit_entry+0x78>
 8000612:	f7ff ff95 	bl	8000540 <selfrel_offset31>
 8000616:	2300      	movs	r3, #0
 8000618:	64e0      	str	r0, [r4, #76]	; 0x4c
 800061a:	6523      	str	r3, [r4, #80]	; 0x50
 800061c:	6803      	ldr	r3, [r0, #0]
 800061e:	2b00      	cmp	r3, #0
 8000620:	db1c      	blt.n	800065c <get_eit_entry+0x80>
 8000622:	f7ff ff8d 	bl	8000540 <selfrel_offset31>
 8000626:	2300      	movs	r3, #0
 8000628:	6120      	str	r0, [r4, #16]
 800062a:	4618      	mov	r0, r3
 800062c:	b003      	add	sp, #12
 800062e:	bd30      	pop	{r4, r5, pc}
 8000630:	2300      	movs	r3, #0
 8000632:	6123      	str	r3, [r4, #16]
 8000634:	2305      	movs	r3, #5
 8000636:	4618      	mov	r0, r3
 8000638:	b003      	add	sp, #12
 800063a:	bd30      	pop	{r4, r5, pc}
 800063c:	2300      	movs	r3, #0
 800063e:	6123      	str	r3, [r4, #16]
 8000640:	2309      	movs	r3, #9
 8000642:	4618      	mov	r0, r3
 8000644:	b003      	add	sp, #12
 8000646:	bd30      	pop	{r4, r5, pc}
 8000648:	490a      	ldr	r1, [pc, #40]	; (8000674 <get_eit_entry+0x98>)
 800064a:	480b      	ldr	r0, [pc, #44]	; (8000678 <get_eit_entry+0x9c>)
 800064c:	1a09      	subs	r1, r1, r0
 800064e:	10c9      	asrs	r1, r1, #3
 8000650:	9101      	str	r1, [sp, #4]
 8000652:	e7cf      	b.n	80005f4 <get_eit_entry+0x18>
 8000654:	2301      	movs	r3, #1
 8000656:	64e0      	str	r0, [r4, #76]	; 0x4c
 8000658:	6523      	str	r3, [r4, #80]	; 0x50
 800065a:	e7df      	b.n	800061c <get_eit_entry+0x40>
 800065c:	f3c3 6003 	ubfx	r0, r3, #24, #4
 8000660:	f7ff ffa8 	bl	80005b4 <__gnu_unwind_get_pr_addr>
 8000664:	2800      	cmp	r0, #0
 8000666:	6120      	str	r0, [r4, #16]
 8000668:	bf14      	ite	ne
 800066a:	2300      	movne	r3, #0
 800066c:	2309      	moveq	r3, #9
 800066e:	e7dc      	b.n	800062a <get_eit_entry+0x4e>
 8000670:	00000000 	.word	0x00000000
 8000674:	08009b90 	.word	0x08009b90
 8000678:	08009810 	.word	0x08009810

0800067c <restore_non_core_regs>:
 800067c:	6803      	ldr	r3, [r0, #0]
 800067e:	07da      	lsls	r2, r3, #31
 8000680:	b510      	push	{r4, lr}
 8000682:	4604      	mov	r4, r0
 8000684:	d406      	bmi.n	8000694 <restore_non_core_regs+0x18>
 8000686:	079b      	lsls	r3, r3, #30
 8000688:	f100 0048 	add.w	r0, r0, #72	; 0x48
 800068c:	d509      	bpl.n	80006a2 <restore_non_core_regs+0x26>
 800068e:	f000 fc59 	bl	8000f44 <__gnu_Unwind_Restore_VFP_D>
 8000692:	6823      	ldr	r3, [r4, #0]
 8000694:	0759      	lsls	r1, r3, #29
 8000696:	d509      	bpl.n	80006ac <restore_non_core_regs+0x30>
 8000698:	071a      	lsls	r2, r3, #28
 800069a:	d50e      	bpl.n	80006ba <restore_non_core_regs+0x3e>
 800069c:	06db      	lsls	r3, r3, #27
 800069e:	d513      	bpl.n	80006c8 <restore_non_core_regs+0x4c>
 80006a0:	bd10      	pop	{r4, pc}
 80006a2:	f000 fc47 	bl	8000f34 <__gnu_Unwind_Restore_VFP>
 80006a6:	6823      	ldr	r3, [r4, #0]
 80006a8:	0759      	lsls	r1, r3, #29
 80006aa:	d4f5      	bmi.n	8000698 <restore_non_core_regs+0x1c>
 80006ac:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 80006b0:	f000 fc50 	bl	8000f54 <__gnu_Unwind_Restore_VFP_D_16_to_31>
 80006b4:	6823      	ldr	r3, [r4, #0]
 80006b6:	071a      	lsls	r2, r3, #28
 80006b8:	d4f0      	bmi.n	800069c <restore_non_core_regs+0x20>
 80006ba:	f504 70a8 	add.w	r0, r4, #336	; 0x150
 80006be:	f000 fc51 	bl	8000f64 <__gnu_Unwind_Restore_WMMXD>
 80006c2:	6823      	ldr	r3, [r4, #0]
 80006c4:	06db      	lsls	r3, r3, #27
 80006c6:	d4eb      	bmi.n	80006a0 <restore_non_core_regs+0x24>
 80006c8:	f504 70e8 	add.w	r0, r4, #464	; 0x1d0
 80006cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80006d0:	f000 bc8c 	b.w	8000fec <__gnu_Unwind_Restore_WMMXC>

080006d4 <_Unwind_decode_typeinfo_ptr.isra.0>:
 80006d4:	6803      	ldr	r3, [r0, #0]
 80006d6:	b10b      	cbz	r3, 80006dc <_Unwind_decode_typeinfo_ptr.isra.0+0x8>
 80006d8:	4418      	add	r0, r3
 80006da:	4770      	bx	lr
 80006dc:	4618      	mov	r0, r3
 80006de:	4770      	bx	lr

080006e0 <__gnu_unwind_24bit.isra.1>:
 80006e0:	2009      	movs	r0, #9
 80006e2:	4770      	bx	lr

080006e4 <_Unwind_DebugHook>:
 80006e4:	4770      	bx	lr
 80006e6:	bf00      	nop

080006e8 <unwind_phase2>:
 80006e8:	b570      	push	{r4, r5, r6, lr}
 80006ea:	4604      	mov	r4, r0
 80006ec:	460d      	mov	r5, r1
 80006ee:	e008      	b.n	8000702 <unwind_phase2+0x1a>
 80006f0:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80006f2:	6163      	str	r3, [r4, #20]
 80006f4:	462a      	mov	r2, r5
 80006f6:	6923      	ldr	r3, [r4, #16]
 80006f8:	4621      	mov	r1, r4
 80006fa:	2001      	movs	r0, #1
 80006fc:	4798      	blx	r3
 80006fe:	2808      	cmp	r0, #8
 8000700:	d108      	bne.n	8000714 <unwind_phase2+0x2c>
 8000702:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8000704:	4620      	mov	r0, r4
 8000706:	f7ff ff69 	bl	80005dc <get_eit_entry>
 800070a:	4606      	mov	r6, r0
 800070c:	2800      	cmp	r0, #0
 800070e:	d0ef      	beq.n	80006f0 <unwind_phase2+0x8>
 8000710:	f007 fb26 	bl	8007d60 <abort>
 8000714:	2807      	cmp	r0, #7
 8000716:	d1fb      	bne.n	8000710 <unwind_phase2+0x28>
 8000718:	4630      	mov	r0, r6
 800071a:	6c29      	ldr	r1, [r5, #64]	; 0x40
 800071c:	f7ff ffe2 	bl	80006e4 <_Unwind_DebugHook>
 8000720:	1d28      	adds	r0, r5, #4
 8000722:	f000 fbfb 	bl	8000f1c <__restore_core_regs>
 8000726:	bf00      	nop

08000728 <unwind_phase2_forced>:
 8000728:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800072c:	1d0c      	adds	r4, r1, #4
 800072e:	4606      	mov	r6, r0
 8000730:	4617      	mov	r7, r2
 8000732:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000734:	f5ad 7d72 	sub.w	sp, sp, #968	; 0x3c8
 8000738:	ad03      	add	r5, sp, #12
 800073a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800073c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800073e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000740:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000742:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000744:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8000748:	ac02      	add	r4, sp, #8
 800074a:	f8d6 800c 	ldr.w	r8, [r6, #12]
 800074e:	f8d6 9018 	ldr.w	r9, [r6, #24]
 8000752:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 8000756:	2300      	movs	r3, #0
 8000758:	4630      	mov	r0, r6
 800075a:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800075c:	6023      	str	r3, [r4, #0]
 800075e:	f7ff ff3d 	bl	80005dc <get_eit_entry>
 8000762:	2f00      	cmp	r7, #0
 8000764:	4605      	mov	r5, r0
 8000766:	bf14      	ite	ne
 8000768:	270a      	movne	r7, #10
 800076a:	2709      	moveq	r7, #9
 800076c:	b17d      	cbz	r5, 800078e <unwind_phase2_forced+0x66>
 800076e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000770:	f047 0110 	orr.w	r1, r7, #16
 8000774:	e88d 0210 	stmia.w	sp, {r4, r9}
 8000778:	4632      	mov	r2, r6
 800077a:	6463      	str	r3, [r4, #68]	; 0x44
 800077c:	2001      	movs	r0, #1
 800077e:	4633      	mov	r3, r6
 8000780:	47c0      	blx	r8
 8000782:	bb78      	cbnz	r0, 80007e4 <unwind_phase2_forced+0xbc>
 8000784:	4628      	mov	r0, r5
 8000786:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
 800078a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800078e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000790:	6173      	str	r3, [r6, #20]
 8000792:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 8000796:	4621      	mov	r1, r4
 8000798:	a87a      	add	r0, sp, #488	; 0x1e8
 800079a:	f007 fd45 	bl	8008228 <memcpy>
 800079e:	6933      	ldr	r3, [r6, #16]
 80007a0:	aa7a      	add	r2, sp, #488	; 0x1e8
 80007a2:	4631      	mov	r1, r6
 80007a4:	4638      	mov	r0, r7
 80007a6:	4798      	blx	r3
 80007a8:	9b88      	ldr	r3, [sp, #544]	; 0x220
 80007aa:	4682      	mov	sl, r0
 80007ac:	e88d 0210 	stmia.w	sp, {r4, r9}
 80007b0:	4639      	mov	r1, r7
 80007b2:	6463      	str	r3, [r4, #68]	; 0x44
 80007b4:	4632      	mov	r2, r6
 80007b6:	4633      	mov	r3, r6
 80007b8:	2001      	movs	r0, #1
 80007ba:	47c0      	blx	r8
 80007bc:	b990      	cbnz	r0, 80007e4 <unwind_phase2_forced+0xbc>
 80007be:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 80007c2:	a97a      	add	r1, sp, #488	; 0x1e8
 80007c4:	4620      	mov	r0, r4
 80007c6:	f007 fd2f 	bl	8008228 <memcpy>
 80007ca:	f1ba 0f08 	cmp.w	sl, #8
 80007ce:	d106      	bne.n	80007de <unwind_phase2_forced+0xb6>
 80007d0:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80007d2:	4630      	mov	r0, r6
 80007d4:	f7ff ff02 	bl	80005dc <get_eit_entry>
 80007d8:	2709      	movs	r7, #9
 80007da:	4605      	mov	r5, r0
 80007dc:	e7c6      	b.n	800076c <unwind_phase2_forced+0x44>
 80007de:	f1ba 0f07 	cmp.w	sl, #7
 80007e2:	d004      	beq.n	80007ee <unwind_phase2_forced+0xc6>
 80007e4:	2009      	movs	r0, #9
 80007e6:	f50d 7d72 	add.w	sp, sp, #968	; 0x3c8
 80007ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80007ee:	4628      	mov	r0, r5
 80007f0:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80007f2:	f7ff ff77 	bl	80006e4 <_Unwind_DebugHook>
 80007f6:	a803      	add	r0, sp, #12
 80007f8:	f000 fb90 	bl	8000f1c <__restore_core_regs>

080007fc <_Unwind_GetCFA>:
 80007fc:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80007fe:	4770      	bx	lr

08000800 <__gnu_Unwind_RaiseException>:
 8000800:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000802:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8000804:	640b      	str	r3, [r1, #64]	; 0x40
 8000806:	1d0e      	adds	r6, r1, #4
 8000808:	460f      	mov	r7, r1
 800080a:	4604      	mov	r4, r0
 800080c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800080e:	b0f9      	sub	sp, #484	; 0x1e4
 8000810:	ad01      	add	r5, sp, #4
 8000812:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000814:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8000816:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8000818:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800081a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800081c:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8000820:	f04f 36ff 	mov.w	r6, #4294967295
 8000824:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 8000828:	9600      	str	r6, [sp, #0]
 800082a:	e006      	b.n	800083a <__gnu_Unwind_RaiseException+0x3a>
 800082c:	6923      	ldr	r3, [r4, #16]
 800082e:	466a      	mov	r2, sp
 8000830:	4621      	mov	r1, r4
 8000832:	4798      	blx	r3
 8000834:	2808      	cmp	r0, #8
 8000836:	4605      	mov	r5, r0
 8000838:	d108      	bne.n	800084c <__gnu_Unwind_RaiseException+0x4c>
 800083a:	9910      	ldr	r1, [sp, #64]	; 0x40
 800083c:	4620      	mov	r0, r4
 800083e:	f7ff fecd 	bl	80005dc <get_eit_entry>
 8000842:	2800      	cmp	r0, #0
 8000844:	d0f2      	beq.n	800082c <__gnu_Unwind_RaiseException+0x2c>
 8000846:	2009      	movs	r0, #9
 8000848:	b079      	add	sp, #484	; 0x1e4
 800084a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800084c:	4668      	mov	r0, sp
 800084e:	f7ff ff15 	bl	800067c <restore_non_core_regs>
 8000852:	2d06      	cmp	r5, #6
 8000854:	d1f7      	bne.n	8000846 <__gnu_Unwind_RaiseException+0x46>
 8000856:	4639      	mov	r1, r7
 8000858:	4620      	mov	r0, r4
 800085a:	f7ff ff45 	bl	80006e8 <unwind_phase2>
 800085e:	bf00      	nop

08000860 <__gnu_Unwind_ForcedUnwind>:
 8000860:	b430      	push	{r4, r5}
 8000862:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 8000864:	60c1      	str	r1, [r0, #12]
 8000866:	6182      	str	r2, [r0, #24]
 8000868:	4619      	mov	r1, r3
 800086a:	641d      	str	r5, [r3, #64]	; 0x40
 800086c:	2200      	movs	r2, #0
 800086e:	bc30      	pop	{r4, r5}
 8000870:	e75a      	b.n	8000728 <unwind_phase2_forced>
 8000872:	bf00      	nop

08000874 <__gnu_Unwind_Resume>:
 8000874:	b570      	push	{r4, r5, r6, lr}
 8000876:	68c6      	ldr	r6, [r0, #12]
 8000878:	6943      	ldr	r3, [r0, #20]
 800087a:	640b      	str	r3, [r1, #64]	; 0x40
 800087c:	b126      	cbz	r6, 8000888 <__gnu_Unwind_Resume+0x14>
 800087e:	2201      	movs	r2, #1
 8000880:	f7ff ff52 	bl	8000728 <unwind_phase2_forced>
 8000884:	f007 fa6c 	bl	8007d60 <abort>
 8000888:	6903      	ldr	r3, [r0, #16]
 800088a:	460a      	mov	r2, r1
 800088c:	4604      	mov	r4, r0
 800088e:	460d      	mov	r5, r1
 8000890:	4601      	mov	r1, r0
 8000892:	2002      	movs	r0, #2
 8000894:	4798      	blx	r3
 8000896:	2807      	cmp	r0, #7
 8000898:	d007      	beq.n	80008aa <__gnu_Unwind_Resume+0x36>
 800089a:	2808      	cmp	r0, #8
 800089c:	d103      	bne.n	80008a6 <__gnu_Unwind_Resume+0x32>
 800089e:	4629      	mov	r1, r5
 80008a0:	4620      	mov	r0, r4
 80008a2:	f7ff ff21 	bl	80006e8 <unwind_phase2>
 80008a6:	f007 fa5b 	bl	8007d60 <abort>
 80008aa:	4630      	mov	r0, r6
 80008ac:	6c29      	ldr	r1, [r5, #64]	; 0x40
 80008ae:	f7ff ff19 	bl	80006e4 <_Unwind_DebugHook>
 80008b2:	1d28      	adds	r0, r5, #4
 80008b4:	f000 fb32 	bl	8000f1c <__restore_core_regs>

080008b8 <__gnu_Unwind_Resume_or_Rethrow>:
 80008b8:	68c2      	ldr	r2, [r0, #12]
 80008ba:	b11a      	cbz	r2, 80008c4 <__gnu_Unwind_Resume_or_Rethrow+0xc>
 80008bc:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 80008be:	640a      	str	r2, [r1, #64]	; 0x40
 80008c0:	2200      	movs	r2, #0
 80008c2:	e731      	b.n	8000728 <unwind_phase2_forced>
 80008c4:	e79c      	b.n	8000800 <__gnu_Unwind_RaiseException>
 80008c6:	bf00      	nop

080008c8 <_Unwind_Complete>:
 80008c8:	4770      	bx	lr
 80008ca:	bf00      	nop

080008cc <_Unwind_DeleteException>:
 80008cc:	6883      	ldr	r3, [r0, #8]
 80008ce:	b113      	cbz	r3, 80008d6 <_Unwind_DeleteException+0xa>
 80008d0:	4601      	mov	r1, r0
 80008d2:	2001      	movs	r0, #1
 80008d4:	4718      	bx	r3
 80008d6:	4770      	bx	lr

080008d8 <_Unwind_VRS_Get>:
 80008d8:	b500      	push	{lr}
 80008da:	2904      	cmp	r1, #4
 80008dc:	d807      	bhi.n	80008ee <_Unwind_VRS_Get+0x16>
 80008de:	e8df f001 	tbb	[pc, r1]
 80008e2:	0903      	.short	0x0903
 80008e4:	0906      	.short	0x0906
 80008e6:	09          	.byte	0x09
 80008e7:	00          	.byte	0x00
 80008e8:	b90b      	cbnz	r3, 80008ee <_Unwind_VRS_Get+0x16>
 80008ea:	2a0f      	cmp	r2, #15
 80008ec:	d905      	bls.n	80008fa <_Unwind_VRS_Get+0x22>
 80008ee:	2002      	movs	r0, #2
 80008f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80008f4:	2001      	movs	r0, #1
 80008f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80008fa:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80008fe:	4618      	mov	r0, r3
 8000900:	6853      	ldr	r3, [r2, #4]
 8000902:	9a01      	ldr	r2, [sp, #4]
 8000904:	6013      	str	r3, [r2, #0]
 8000906:	f85d fb04 	ldr.w	pc, [sp], #4
 800090a:	bf00      	nop

0800090c <_Unwind_GetGR>:
 800090c:	b510      	push	{r4, lr}
 800090e:	b084      	sub	sp, #16
 8000910:	2300      	movs	r3, #0
 8000912:	ac03      	add	r4, sp, #12
 8000914:	460a      	mov	r2, r1
 8000916:	9400      	str	r4, [sp, #0]
 8000918:	4619      	mov	r1, r3
 800091a:	f7ff ffdd 	bl	80008d8 <_Unwind_VRS_Get>
 800091e:	9803      	ldr	r0, [sp, #12]
 8000920:	b004      	add	sp, #16
 8000922:	bd10      	pop	{r4, pc}

08000924 <_Unwind_VRS_Set>:
 8000924:	b500      	push	{lr}
 8000926:	2904      	cmp	r1, #4
 8000928:	d807      	bhi.n	800093a <_Unwind_VRS_Set+0x16>
 800092a:	e8df f001 	tbb	[pc, r1]
 800092e:	0903      	.short	0x0903
 8000930:	0906      	.short	0x0906
 8000932:	09          	.byte	0x09
 8000933:	00          	.byte	0x00
 8000934:	b90b      	cbnz	r3, 800093a <_Unwind_VRS_Set+0x16>
 8000936:	2a0f      	cmp	r2, #15
 8000938:	d905      	bls.n	8000946 <_Unwind_VRS_Set+0x22>
 800093a:	2002      	movs	r0, #2
 800093c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000940:	2001      	movs	r0, #1
 8000942:	f85d fb04 	ldr.w	pc, [sp], #4
 8000946:	9901      	ldr	r1, [sp, #4]
 8000948:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800094c:	6809      	ldr	r1, [r1, #0]
 800094e:	6051      	str	r1, [r2, #4]
 8000950:	4618      	mov	r0, r3
 8000952:	f85d fb04 	ldr.w	pc, [sp], #4
 8000956:	bf00      	nop

08000958 <_Unwind_SetGR>:
 8000958:	b510      	push	{r4, lr}
 800095a:	b084      	sub	sp, #16
 800095c:	ac04      	add	r4, sp, #16
 800095e:	2300      	movs	r3, #0
 8000960:	f844 2d04 	str.w	r2, [r4, #-4]!
 8000964:	460a      	mov	r2, r1
 8000966:	9400      	str	r4, [sp, #0]
 8000968:	4619      	mov	r1, r3
 800096a:	f7ff ffdb 	bl	8000924 <_Unwind_VRS_Set>
 800096e:	b004      	add	sp, #16
 8000970:	bd10      	pop	{r4, pc}
 8000972:	bf00      	nop

08000974 <__gnu_Unwind_Backtrace>:
 8000974:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000976:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8000978:	6413      	str	r3, [r2, #64]	; 0x40
 800097a:	1d15      	adds	r5, r2, #4
 800097c:	4607      	mov	r7, r0
 800097e:	460e      	mov	r6, r1
 8000980:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000982:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
 8000986:	ac17      	add	r4, sp, #92	; 0x5c
 8000988:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800098a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800098c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800098e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000990:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000992:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8000996:	f04f 35ff 	mov.w	r5, #4294967295
 800099a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 800099e:	9516      	str	r5, [sp, #88]	; 0x58
 80009a0:	e010      	b.n	80009c4 <__gnu_Unwind_Backtrace+0x50>
 80009a2:	a816      	add	r0, sp, #88	; 0x58
 80009a4:	f7ff ffd8 	bl	8000958 <_Unwind_SetGR>
 80009a8:	4631      	mov	r1, r6
 80009aa:	a816      	add	r0, sp, #88	; 0x58
 80009ac:	47b8      	blx	r7
 80009ae:	aa16      	add	r2, sp, #88	; 0x58
 80009b0:	4669      	mov	r1, sp
 80009b2:	b978      	cbnz	r0, 80009d4 <__gnu_Unwind_Backtrace+0x60>
 80009b4:	9b04      	ldr	r3, [sp, #16]
 80009b6:	2008      	movs	r0, #8
 80009b8:	4798      	blx	r3
 80009ba:	2805      	cmp	r0, #5
 80009bc:	4604      	mov	r4, r0
 80009be:	d00a      	beq.n	80009d6 <__gnu_Unwind_Backtrace+0x62>
 80009c0:	2809      	cmp	r0, #9
 80009c2:	d007      	beq.n	80009d4 <__gnu_Unwind_Backtrace+0x60>
 80009c4:	9926      	ldr	r1, [sp, #152]	; 0x98
 80009c6:	4668      	mov	r0, sp
 80009c8:	f7ff fe08 	bl	80005dc <get_eit_entry>
 80009cc:	466a      	mov	r2, sp
 80009ce:	210c      	movs	r1, #12
 80009d0:	2800      	cmp	r0, #0
 80009d2:	d0e6      	beq.n	80009a2 <__gnu_Unwind_Backtrace+0x2e>
 80009d4:	2409      	movs	r4, #9
 80009d6:	a816      	add	r0, sp, #88	; 0x58
 80009d8:	f7ff fe50 	bl	800067c <restore_non_core_regs>
 80009dc:	4620      	mov	r0, r4
 80009de:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
 80009e2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080009e4 <__gnu_unwind_pr_common>:
 80009e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80009e8:	460d      	mov	r5, r1
 80009ea:	6cc9      	ldr	r1, [r1, #76]	; 0x4c
 80009ec:	b08b      	sub	sp, #44	; 0x2c
 80009ee:	1d0c      	adds	r4, r1, #4
 80009f0:	6809      	ldr	r1, [r1, #0]
 80009f2:	9107      	str	r1, [sp, #28]
 80009f4:	4691      	mov	r9, r2
 80009f6:	9408      	str	r4, [sp, #32]
 80009f8:	f000 0b03 	and.w	fp, r0, #3
 80009fc:	461e      	mov	r6, r3
 80009fe:	2b00      	cmp	r3, #0
 8000a00:	d164      	bne.n	8000acc <__gnu_unwind_pr_common+0xe8>
 8000a02:	0209      	lsls	r1, r1, #8
 8000a04:	2303      	movs	r3, #3
 8000a06:	9107      	str	r1, [sp, #28]
 8000a08:	f88d 6025 	strb.w	r6, [sp, #37]	; 0x25
 8000a0c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8000a10:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8000a12:	f1bb 0f02 	cmp.w	fp, #2
 8000a16:	bf08      	it	eq
 8000a18:	6bac      	ldreq	r4, [r5, #56]	; 0x38
 8000a1a:	f013 0301 	ands.w	r3, r3, #1
 8000a1e:	d143      	bne.n	8000aa8 <__gnu_unwind_pr_common+0xc4>
 8000a20:	f000 0008 	and.w	r0, r0, #8
 8000a24:	b2c2      	uxtb	r2, r0
 8000a26:	9203      	str	r2, [sp, #12]
 8000a28:	9301      	str	r3, [sp, #4]
 8000a2a:	6827      	ldr	r7, [r4, #0]
 8000a2c:	2f00      	cmp	r7, #0
 8000a2e:	d03d      	beq.n	8000aac <__gnu_unwind_pr_common+0xc8>
 8000a30:	2e02      	cmp	r6, #2
 8000a32:	d047      	beq.n	8000ac4 <__gnu_unwind_pr_common+0xe0>
 8000a34:	8827      	ldrh	r7, [r4, #0]
 8000a36:	f8b4 8002 	ldrh.w	r8, [r4, #2]
 8000a3a:	3404      	adds	r4, #4
 8000a3c:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000a3e:	f028 0a01 	bic.w	sl, r8, #1
 8000a42:	210f      	movs	r1, #15
 8000a44:	4648      	mov	r0, r9
 8000a46:	449a      	add	sl, r3
 8000a48:	f7ff ff60 	bl	800090c <_Unwind_GetGR>
 8000a4c:	4582      	cmp	sl, r0
 8000a4e:	d837      	bhi.n	8000ac0 <__gnu_unwind_pr_common+0xdc>
 8000a50:	f027 0301 	bic.w	r3, r7, #1
 8000a54:	449a      	add	sl, r3
 8000a56:	4550      	cmp	r0, sl
 8000a58:	bf2c      	ite	cs
 8000a5a:	2000      	movcs	r0, #0
 8000a5c:	2001      	movcc	r0, #1
 8000a5e:	ea4f 0848 	mov.w	r8, r8, lsl #1
 8000a62:	f008 0802 	and.w	r8, r8, #2
 8000a66:	f007 0701 	and.w	r7, r7, #1
 8000a6a:	ea48 0807 	orr.w	r8, r8, r7
 8000a6e:	f1b8 0f01 	cmp.w	r8, #1
 8000a72:	d041      	beq.n	8000af8 <__gnu_unwind_pr_common+0x114>
 8000a74:	d338      	bcc.n	8000ae8 <__gnu_unwind_pr_common+0x104>
 8000a76:	f1b8 0f02 	cmp.w	r8, #2
 8000a7a:	d11d      	bne.n	8000ab8 <__gnu_unwind_pr_common+0xd4>
 8000a7c:	6823      	ldr	r3, [r4, #0]
 8000a7e:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8000a82:	9202      	str	r2, [sp, #8]
 8000a84:	f1bb 0f00 	cmp.w	fp, #0
 8000a88:	d179      	bne.n	8000b7e <__gnu_unwind_pr_common+0x19a>
 8000a8a:	b130      	cbz	r0, 8000a9a <__gnu_unwind_pr_common+0xb6>
 8000a8c:	9903      	ldr	r1, [sp, #12]
 8000a8e:	2900      	cmp	r1, #0
 8000a90:	f000 8081 	beq.w	8000b96 <__gnu_unwind_pr_common+0x1b2>
 8000a94:	2a00      	cmp	r2, #0
 8000a96:	f000 80a8 	beq.w	8000bea <__gnu_unwind_pr_common+0x206>
 8000a9a:	2b00      	cmp	r3, #0
 8000a9c:	db79      	blt.n	8000b92 <__gnu_unwind_pr_common+0x1ae>
 8000a9e:	9b02      	ldr	r3, [sp, #8]
 8000aa0:	3301      	adds	r3, #1
 8000aa2:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8000aa6:	e7c0      	b.n	8000a2a <__gnu_unwind_pr_common+0x46>
 8000aa8:	2300      	movs	r3, #0
 8000aaa:	9301      	str	r3, [sp, #4]
 8000aac:	2e02      	cmp	r6, #2
 8000aae:	dd40      	ble.n	8000b32 <__gnu_unwind_pr_common+0x14e>
 8000ab0:	f7ff fe16 	bl	80006e0 <__gnu_unwind_24bit.isra.1>
 8000ab4:	2800      	cmp	r0, #0
 8000ab6:	d042      	beq.n	8000b3e <__gnu_unwind_pr_common+0x15a>
 8000ab8:	2009      	movs	r0, #9
 8000aba:	b00b      	add	sp, #44	; 0x2c
 8000abc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000ac0:	2000      	movs	r0, #0
 8000ac2:	e7cc      	b.n	8000a5e <__gnu_unwind_pr_common+0x7a>
 8000ac4:	f8d4 8004 	ldr.w	r8, [r4, #4]
 8000ac8:	3408      	adds	r4, #8
 8000aca:	e7b7      	b.n	8000a3c <__gnu_unwind_pr_common+0x58>
 8000acc:	2b02      	cmp	r3, #2
 8000ace:	dc9f      	bgt.n	8000a10 <__gnu_unwind_pr_common+0x2c>
 8000ad0:	0c0b      	lsrs	r3, r1, #16
 8000ad2:	b2da      	uxtb	r2, r3
 8000ad4:	0409      	lsls	r1, r1, #16
 8000ad6:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 8000ada:	2302      	movs	r3, #2
 8000adc:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 8000ae0:	9107      	str	r1, [sp, #28]
 8000ae2:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 8000ae6:	e793      	b.n	8000a10 <__gnu_unwind_pr_common+0x2c>
 8000ae8:	f1bb 0f00 	cmp.w	fp, #0
 8000aec:	d002      	beq.n	8000af4 <__gnu_unwind_pr_common+0x110>
 8000aee:	2800      	cmp	r0, #0
 8000af0:	f040 80b0 	bne.w	8000c54 <__gnu_unwind_pr_common+0x270>
 8000af4:	3404      	adds	r4, #4
 8000af6:	e798      	b.n	8000a2a <__gnu_unwind_pr_common+0x46>
 8000af8:	f1bb 0f00 	cmp.w	fp, #0
 8000afc:	d126      	bne.n	8000b4c <__gnu_unwind_pr_common+0x168>
 8000afe:	b1b0      	cbz	r0, 8000b2e <__gnu_unwind_pr_common+0x14a>
 8000b00:	e894 000c 	ldmia.w	r4, {r2, r3}
 8000b04:	1c99      	adds	r1, r3, #2
 8000b06:	ea4f 72d2 	mov.w	r2, r2, lsr #31
 8000b0a:	d0d5      	beq.n	8000ab8 <__gnu_unwind_pr_common+0xd4>
 8000b0c:	f105 0158 	add.w	r1, r5, #88	; 0x58
 8000b10:	3301      	adds	r3, #1
 8000b12:	9106      	str	r1, [sp, #24]
 8000b14:	f000 8094 	beq.w	8000c40 <__gnu_unwind_pr_common+0x25c>
 8000b18:	1d20      	adds	r0, r4, #4
 8000b1a:	f7ff fddb 	bl	80006d4 <_Unwind_decode_typeinfo_ptr.isra.0>
 8000b1e:	ab06      	add	r3, sp, #24
 8000b20:	4601      	mov	r1, r0
 8000b22:	4628      	mov	r0, r5
 8000b24:	f005 fd24 	bl	8006570 <__cxa_type_match>
 8000b28:	2800      	cmp	r0, #0
 8000b2a:	f040 80b8 	bne.w	8000c9e <__gnu_unwind_pr_common+0x2ba>
 8000b2e:	3408      	adds	r4, #8
 8000b30:	e77b      	b.n	8000a2a <__gnu_unwind_pr_common+0x46>
 8000b32:	a907      	add	r1, sp, #28
 8000b34:	4648      	mov	r0, r9
 8000b36:	f000 faf3 	bl	8001120 <__gnu_unwind_execute>
 8000b3a:	2800      	cmp	r0, #0
 8000b3c:	d1bc      	bne.n	8000ab8 <__gnu_unwind_pr_common+0xd4>
 8000b3e:	9b01      	ldr	r3, [sp, #4]
 8000b40:	2b00      	cmp	r3, #0
 8000b42:	d15c      	bne.n	8000bfe <__gnu_unwind_pr_common+0x21a>
 8000b44:	2008      	movs	r0, #8
 8000b46:	b00b      	add	sp, #44	; 0x2c
 8000b48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000b4c:	210d      	movs	r1, #13
 8000b4e:	4648      	mov	r0, r9
 8000b50:	6a2f      	ldr	r7, [r5, #32]
 8000b52:	f7ff fedb 	bl	800090c <_Unwind_GetGR>
 8000b56:	4287      	cmp	r7, r0
 8000b58:	d1e9      	bne.n	8000b2e <__gnu_unwind_pr_common+0x14a>
 8000b5a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000b5c:	429c      	cmp	r4, r3
 8000b5e:	d1e6      	bne.n	8000b2e <__gnu_unwind_pr_common+0x14a>
 8000b60:	4620      	mov	r0, r4
 8000b62:	f7ff fced 	bl	8000540 <selfrel_offset31>
 8000b66:	210f      	movs	r1, #15
 8000b68:	4602      	mov	r2, r0
 8000b6a:	4648      	mov	r0, r9
 8000b6c:	f7ff fef4 	bl	8000958 <_Unwind_SetGR>
 8000b70:	4648      	mov	r0, r9
 8000b72:	462a      	mov	r2, r5
 8000b74:	2100      	movs	r1, #0
 8000b76:	f7ff feef 	bl	8000958 <_Unwind_SetGR>
 8000b7a:	2007      	movs	r0, #7
 8000b7c:	e79d      	b.n	8000aba <__gnu_unwind_pr_common+0xd6>
 8000b7e:	210d      	movs	r1, #13
 8000b80:	4648      	mov	r0, r9
 8000b82:	6a2f      	ldr	r7, [r5, #32]
 8000b84:	f7ff fec2 	bl	800090c <_Unwind_GetGR>
 8000b88:	4287      	cmp	r7, r0
 8000b8a:	d048      	beq.n	8000c1e <__gnu_unwind_pr_common+0x23a>
 8000b8c:	6823      	ldr	r3, [r4, #0]
 8000b8e:	2b00      	cmp	r3, #0
 8000b90:	da85      	bge.n	8000a9e <__gnu_unwind_pr_common+0xba>
 8000b92:	3404      	adds	r4, #4
 8000b94:	e783      	b.n	8000a9e <__gnu_unwind_pr_common+0xba>
 8000b96:	9b02      	ldr	r3, [sp, #8]
 8000b98:	b33b      	cbz	r3, 8000bea <__gnu_unwind_pr_common+0x206>
 8000b9a:	f105 0358 	add.w	r3, r5, #88	; 0x58
 8000b9e:	1d27      	adds	r7, r4, #4
 8000ba0:	f8cd b010 	str.w	fp, [sp, #16]
 8000ba4:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8000ba8:	f8dd a008 	ldr.w	sl, [sp, #8]
 8000bac:	9605      	str	r6, [sp, #20]
 8000bae:	46a3      	mov	fp, r4
 8000bb0:	461c      	mov	r4, r3
 8000bb2:	e002      	b.n	8000bba <__gnu_unwind_pr_common+0x1d6>
 8000bb4:	45b2      	cmp	sl, r6
 8000bb6:	46b0      	mov	r8, r6
 8000bb8:	d016      	beq.n	8000be8 <__gnu_unwind_pr_common+0x204>
 8000bba:	4638      	mov	r0, r7
 8000bbc:	9406      	str	r4, [sp, #24]
 8000bbe:	f7ff fd89 	bl	80006d4 <_Unwind_decode_typeinfo_ptr.isra.0>
 8000bc2:	ab06      	add	r3, sp, #24
 8000bc4:	4601      	mov	r1, r0
 8000bc6:	2200      	movs	r2, #0
 8000bc8:	4628      	mov	r0, r5
 8000bca:	f005 fcd1 	bl	8006570 <__cxa_type_match>
 8000bce:	f108 0601 	add.w	r6, r8, #1
 8000bd2:	3704      	adds	r7, #4
 8000bd4:	2800      	cmp	r0, #0
 8000bd6:	d0ed      	beq.n	8000bb4 <__gnu_unwind_pr_common+0x1d0>
 8000bd8:	9b02      	ldr	r3, [sp, #8]
 8000bda:	9e05      	ldr	r6, [sp, #20]
 8000bdc:	4543      	cmp	r3, r8
 8000bde:	465c      	mov	r4, fp
 8000be0:	f8dd b010 	ldr.w	fp, [sp, #16]
 8000be4:	d1d2      	bne.n	8000b8c <__gnu_unwind_pr_common+0x1a8>
 8000be6:	e000      	b.n	8000bea <__gnu_unwind_pr_common+0x206>
 8000be8:	465c      	mov	r4, fp
 8000bea:	4648      	mov	r0, r9
 8000bec:	210d      	movs	r1, #13
 8000bee:	f7ff fe8d 	bl	800090c <_Unwind_GetGR>
 8000bf2:	9b06      	ldr	r3, [sp, #24]
 8000bf4:	6228      	str	r0, [r5, #32]
 8000bf6:	62ac      	str	r4, [r5, #40]	; 0x28
 8000bf8:	626b      	str	r3, [r5, #36]	; 0x24
 8000bfa:	2006      	movs	r0, #6
 8000bfc:	e75d      	b.n	8000aba <__gnu_unwind_pr_common+0xd6>
 8000bfe:	210f      	movs	r1, #15
 8000c00:	4648      	mov	r0, r9
 8000c02:	f7ff fe83 	bl	800090c <_Unwind_GetGR>
 8000c06:	210e      	movs	r1, #14
 8000c08:	4602      	mov	r2, r0
 8000c0a:	4648      	mov	r0, r9
 8000c0c:	f7ff fea4 	bl	8000958 <_Unwind_SetGR>
 8000c10:	4648      	mov	r0, r9
 8000c12:	4a2a      	ldr	r2, [pc, #168]	; (8000cbc <__gnu_unwind_pr_common+0x2d8>)
 8000c14:	210f      	movs	r1, #15
 8000c16:	f7ff fe9f 	bl	8000958 <_Unwind_SetGR>
 8000c1a:	2007      	movs	r0, #7
 8000c1c:	e74d      	b.n	8000aba <__gnu_unwind_pr_common+0xd6>
 8000c1e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000c20:	429c      	cmp	r4, r3
 8000c22:	d1b3      	bne.n	8000b8c <__gnu_unwind_pr_common+0x1a8>
 8000c24:	2204      	movs	r2, #4
 8000c26:	2700      	movs	r7, #0
 8000c28:	18a3      	adds	r3, r4, r2
 8000c2a:	9902      	ldr	r1, [sp, #8]
 8000c2c:	62a9      	str	r1, [r5, #40]	; 0x28
 8000c2e:	62ef      	str	r7, [r5, #44]	; 0x2c
 8000c30:	632a      	str	r2, [r5, #48]	; 0x30
 8000c32:	636b      	str	r3, [r5, #52]	; 0x34
 8000c34:	6823      	ldr	r3, [r4, #0]
 8000c36:	42bb      	cmp	r3, r7
 8000c38:	db1f      	blt.n	8000c7a <__gnu_unwind_pr_common+0x296>
 8000c3a:	2301      	movs	r3, #1
 8000c3c:	9301      	str	r3, [sp, #4]
 8000c3e:	e72e      	b.n	8000a9e <__gnu_unwind_pr_common+0xba>
 8000c40:	4648      	mov	r0, r9
 8000c42:	210d      	movs	r1, #13
 8000c44:	f7ff fe62 	bl	800090c <_Unwind_GetGR>
 8000c48:	6228      	str	r0, [r5, #32]
 8000c4a:	9b06      	ldr	r3, [sp, #24]
 8000c4c:	626b      	str	r3, [r5, #36]	; 0x24
 8000c4e:	62ac      	str	r4, [r5, #40]	; 0x28
 8000c50:	2006      	movs	r0, #6
 8000c52:	e732      	b.n	8000aba <__gnu_unwind_pr_common+0xd6>
 8000c54:	4620      	mov	r0, r4
 8000c56:	f7ff fc73 	bl	8000540 <selfrel_offset31>
 8000c5a:	3404      	adds	r4, #4
 8000c5c:	4606      	mov	r6, r0
 8000c5e:	63ac      	str	r4, [r5, #56]	; 0x38
 8000c60:	4628      	mov	r0, r5
 8000c62:	f005 fce3 	bl	800662c <__cxa_begin_cleanup>
 8000c66:	2800      	cmp	r0, #0
 8000c68:	f43f af26 	beq.w	8000ab8 <__gnu_unwind_pr_common+0xd4>
 8000c6c:	4648      	mov	r0, r9
 8000c6e:	4632      	mov	r2, r6
 8000c70:	210f      	movs	r1, #15
 8000c72:	f7ff fe71 	bl	8000958 <_Unwind_SetGR>
 8000c76:	2007      	movs	r0, #7
 8000c78:	e71f      	b.n	8000aba <__gnu_unwind_pr_common+0xd6>
 8000c7a:	4608      	mov	r0, r1
 8000c7c:	3001      	adds	r0, #1
 8000c7e:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8000c82:	f7ff fc5d 	bl	8000540 <selfrel_offset31>
 8000c86:	210f      	movs	r1, #15
 8000c88:	4602      	mov	r2, r0
 8000c8a:	4648      	mov	r0, r9
 8000c8c:	f7ff fe64 	bl	8000958 <_Unwind_SetGR>
 8000c90:	4648      	mov	r0, r9
 8000c92:	462a      	mov	r2, r5
 8000c94:	4639      	mov	r1, r7
 8000c96:	f7ff fe5f 	bl	8000958 <_Unwind_SetGR>
 8000c9a:	2007      	movs	r0, #7
 8000c9c:	e70d      	b.n	8000aba <__gnu_unwind_pr_common+0xd6>
 8000c9e:	4607      	mov	r7, r0
 8000ca0:	210d      	movs	r1, #13
 8000ca2:	4648      	mov	r0, r9
 8000ca4:	f7ff fe32 	bl	800090c <_Unwind_GetGR>
 8000ca8:	2f02      	cmp	r7, #2
 8000caa:	6228      	str	r0, [r5, #32]
 8000cac:	d1cd      	bne.n	8000c4a <__gnu_unwind_pr_common+0x266>
 8000cae:	462b      	mov	r3, r5
 8000cb0:	9a06      	ldr	r2, [sp, #24]
 8000cb2:	f843 2f2c 	str.w	r2, [r3, #44]!
 8000cb6:	626b      	str	r3, [r5, #36]	; 0x24
 8000cb8:	e7c9      	b.n	8000c4e <__gnu_unwind_pr_common+0x26a>
 8000cba:	bf00      	nop
 8000cbc:	08006ecd 	.word	0x08006ecd

08000cc0 <__aeabi_unwind_cpp_pr0>:
 8000cc0:	2300      	movs	r3, #0
 8000cc2:	e68f      	b.n	80009e4 <__gnu_unwind_pr_common>

08000cc4 <__aeabi_unwind_cpp_pr1>:
 8000cc4:	2301      	movs	r3, #1
 8000cc6:	e68d      	b.n	80009e4 <__gnu_unwind_pr_common>

08000cc8 <__aeabi_unwind_cpp_pr2>:
 8000cc8:	2302      	movs	r3, #2
 8000cca:	e68b      	b.n	80009e4 <__gnu_unwind_pr_common>

08000ccc <_Unwind_VRS_Pop>:
 8000ccc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000cce:	4604      	mov	r4, r0
 8000cd0:	b0c5      	sub	sp, #276	; 0x114
 8000cd2:	2904      	cmp	r1, #4
 8000cd4:	d80d      	bhi.n	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000cd6:	e8df f001 	tbb	[pc, r1]
 8000cda:	0357      	.short	0x0357
 8000cdc:	310c      	.short	0x310c
 8000cde:	0f          	.byte	0x0f
 8000cdf:	00          	.byte	0x00
 8000ce0:	2b01      	cmp	r3, #1
 8000ce2:	ea4f 4612 	mov.w	r6, r2, lsr #16
 8000ce6:	b295      	uxth	r5, r2
 8000ce8:	d166      	bne.n	8000db8 <_Unwind_VRS_Pop+0xec>
 8000cea:	1972      	adds	r2, r6, r5
 8000cec:	2a10      	cmp	r2, #16
 8000cee:	f240 809f 	bls.w	8000e30 <_Unwind_VRS_Pop+0x164>
 8000cf2:	2002      	movs	r0, #2
 8000cf4:	b045      	add	sp, #276	; 0x114
 8000cf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cf8:	2b00      	cmp	r3, #0
 8000cfa:	d1fa      	bne.n	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000cfc:	2a10      	cmp	r2, #16
 8000cfe:	d8f8      	bhi.n	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000d00:	6823      	ldr	r3, [r4, #0]
 8000d02:	06d8      	lsls	r0, r3, #27
 8000d04:	f100 80c9 	bmi.w	8000e9a <_Unwind_VRS_Pop+0x1ce>
 8000d08:	ae22      	add	r6, sp, #136	; 0x88
 8000d0a:	4630      	mov	r0, r6
 8000d0c:	9201      	str	r2, [sp, #4]
 8000d0e:	f000 f977 	bl	8001000 <__gnu_Unwind_Save_WMMXC>
 8000d12:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8000d14:	9a01      	ldr	r2, [sp, #4]
 8000d16:	2300      	movs	r3, #0
 8000d18:	2501      	movs	r5, #1
 8000d1a:	fa05 f103 	lsl.w	r1, r5, r3
 8000d1e:	4211      	tst	r1, r2
 8000d20:	d003      	beq.n	8000d2a <_Unwind_VRS_Pop+0x5e>
 8000d22:	6801      	ldr	r1, [r0, #0]
 8000d24:	f846 1023 	str.w	r1, [r6, r3, lsl #2]
 8000d28:	3004      	adds	r0, #4
 8000d2a:	3301      	adds	r3, #1
 8000d2c:	2b04      	cmp	r3, #4
 8000d2e:	d1f4      	bne.n	8000d1a <_Unwind_VRS_Pop+0x4e>
 8000d30:	63a0      	str	r0, [r4, #56]	; 0x38
 8000d32:	4630      	mov	r0, r6
 8000d34:	f000 f95a 	bl	8000fec <__gnu_Unwind_Restore_WMMXC>
 8000d38:	2000      	movs	r0, #0
 8000d3a:	e7db      	b.n	8000cf4 <_Unwind_VRS_Pop+0x28>
 8000d3c:	2b03      	cmp	r3, #3
 8000d3e:	d1d8      	bne.n	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000d40:	0c15      	lsrs	r5, r2, #16
 8000d42:	b297      	uxth	r7, r2
 8000d44:	19eb      	adds	r3, r5, r7
 8000d46:	2b10      	cmp	r3, #16
 8000d48:	d8d3      	bhi.n	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000d4a:	6823      	ldr	r3, [r4, #0]
 8000d4c:	071e      	lsls	r6, r3, #28
 8000d4e:	f100 80b8 	bmi.w	8000ec2 <_Unwind_VRS_Pop+0x1f6>
 8000d52:	ae22      	add	r6, sp, #136	; 0x88
 8000d54:	4630      	mov	r0, r6
 8000d56:	007f      	lsls	r7, r7, #1
 8000d58:	f000 f926 	bl	8000fa8 <__gnu_Unwind_Save_WMMXD>
 8000d5c:	eb06 02c5 	add.w	r2, r6, r5, lsl #3
 8000d60:	1e7b      	subs	r3, r7, #1
 8000d62:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8000d64:	b157      	cbz	r7, 8000d7c <_Unwind_VRS_Pop+0xb0>
 8000d66:	3a04      	subs	r2, #4
 8000d68:	4629      	mov	r1, r5
 8000d6a:	f851 0b04 	ldr.w	r0, [r1], #4
 8000d6e:	f842 0f04 	str.w	r0, [r2, #4]!
 8000d72:	3b01      	subs	r3, #1
 8000d74:	1c58      	adds	r0, r3, #1
 8000d76:	d1f8      	bne.n	8000d6a <_Unwind_VRS_Pop+0x9e>
 8000d78:	eb05 0587 	add.w	r5, r5, r7, lsl #2
 8000d7c:	4630      	mov	r0, r6
 8000d7e:	63a5      	str	r5, [r4, #56]	; 0x38
 8000d80:	f000 f8f0 	bl	8000f64 <__gnu_Unwind_Restore_WMMXD>
 8000d84:	2000      	movs	r0, #0
 8000d86:	e7b5      	b.n	8000cf4 <_Unwind_VRS_Pop+0x28>
 8000d88:	2b00      	cmp	r3, #0
 8000d8a:	d1b2      	bne.n	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000d8c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8000d8e:	b297      	uxth	r7, r2
 8000d90:	1d20      	adds	r0, r4, #4
 8000d92:	2601      	movs	r6, #1
 8000d94:	fa06 f103 	lsl.w	r1, r6, r3
 8000d98:	4239      	tst	r1, r7
 8000d9a:	f103 0301 	add.w	r3, r3, #1
 8000d9e:	d002      	beq.n	8000da6 <_Unwind_VRS_Pop+0xda>
 8000da0:	6829      	ldr	r1, [r5, #0]
 8000da2:	6001      	str	r1, [r0, #0]
 8000da4:	3504      	adds	r5, #4
 8000da6:	2b10      	cmp	r3, #16
 8000da8:	f100 0004 	add.w	r0, r0, #4
 8000dac:	d1f2      	bne.n	8000d94 <_Unwind_VRS_Pop+0xc8>
 8000dae:	f412 5000 	ands.w	r0, r2, #8192	; 0x2000
 8000db2:	d13b      	bne.n	8000e2c <_Unwind_VRS_Pop+0x160>
 8000db4:	63a5      	str	r5, [r4, #56]	; 0x38
 8000db6:	e79d      	b.n	8000cf4 <_Unwind_VRS_Pop+0x28>
 8000db8:	2b05      	cmp	r3, #5
 8000dba:	d19a      	bne.n	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000dbc:	1977      	adds	r7, r6, r5
 8000dbe:	2f20      	cmp	r7, #32
 8000dc0:	d897      	bhi.n	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000dc2:	2e0f      	cmp	r6, #15
 8000dc4:	d965      	bls.n	8000e92 <_Unwind_VRS_Pop+0x1c6>
 8000dc6:	462f      	mov	r7, r5
 8000dc8:	2d00      	cmp	r5, #0
 8000dca:	d148      	bne.n	8000e5e <_Unwind_VRS_Pop+0x192>
 8000dcc:	462a      	mov	r2, r5
 8000dce:	2700      	movs	r7, #0
 8000dd0:	2a00      	cmp	r2, #0
 8000dd2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8000dd4:	dd71      	ble.n	8000eba <_Unwind_VRS_Pop+0x1ee>
 8000dd6:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 8000dda:	4601      	mov	r1, r0
 8000ddc:	a844      	add	r0, sp, #272	; 0x110
 8000dde:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
 8000de2:	388c      	subs	r0, #140	; 0x8c
 8000de4:	f851 5b04 	ldr.w	r5, [r1], #4
 8000de8:	f840 5f04 	str.w	r5, [r0, #4]!
 8000dec:	4291      	cmp	r1, r2
 8000dee:	d1f9      	bne.n	8000de4 <_Unwind_VRS_Pop+0x118>
 8000df0:	4608      	mov	r0, r1
 8000df2:	b197      	cbz	r7, 8000e1a <_Unwind_VRS_Pop+0x14e>
 8000df4:	2e10      	cmp	r6, #16
 8000df6:	4632      	mov	r2, r6
 8000df8:	a944      	add	r1, sp, #272	; 0x110
 8000dfa:	bf38      	it	cc
 8000dfc:	2210      	movcc	r2, #16
 8000dfe:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8000e02:	f5a2 72c4 	sub.w	r2, r2, #392	; 0x188
 8000e06:	0079      	lsls	r1, r7, #1
 8000e08:	3a04      	subs	r2, #4
 8000e0a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8000e0e:	f850 5b04 	ldr.w	r5, [r0], #4
 8000e12:	f842 5f04 	str.w	r5, [r2, #4]!
 8000e16:	4281      	cmp	r1, r0
 8000e18:	d1f9      	bne.n	8000e0e <_Unwind_VRS_Pop+0x142>
 8000e1a:	2b01      	cmp	r3, #1
 8000e1c:	d047      	beq.n	8000eae <_Unwind_VRS_Pop+0x1e2>
 8000e1e:	2e0f      	cmp	r6, #15
 8000e20:	63a1      	str	r1, [r4, #56]	; 0x38
 8000e22:	d932      	bls.n	8000e8a <_Unwind_VRS_Pop+0x1be>
 8000e24:	b117      	cbz	r7, 8000e2c <_Unwind_VRS_Pop+0x160>
 8000e26:	a802      	add	r0, sp, #8
 8000e28:	f000 f894 	bl	8000f54 <__gnu_Unwind_Restore_VFP_D_16_to_31>
 8000e2c:	2000      	movs	r0, #0
 8000e2e:	e761      	b.n	8000cf4 <_Unwind_VRS_Pop+0x28>
 8000e30:	2e0f      	cmp	r6, #15
 8000e32:	f63f af5e 	bhi.w	8000cf2 <_Unwind_VRS_Pop+0x26>
 8000e36:	2700      	movs	r7, #0
 8000e38:	6822      	ldr	r2, [r4, #0]
 8000e3a:	07d1      	lsls	r1, r2, #31
 8000e3c:	d50d      	bpl.n	8000e5a <_Unwind_VRS_Pop+0x18e>
 8000e3e:	f022 0101 	bic.w	r1, r2, #1
 8000e42:	2b05      	cmp	r3, #5
 8000e44:	6021      	str	r1, [r4, #0]
 8000e46:	9301      	str	r3, [sp, #4]
 8000e48:	4620      	mov	r0, r4
 8000e4a:	d052      	beq.n	8000ef2 <_Unwind_VRS_Pop+0x226>
 8000e4c:	f022 0203 	bic.w	r2, r2, #3
 8000e50:	f840 2b48 	str.w	r2, [r0], #72
 8000e54:	f000 f872 	bl	8000f3c <__gnu_Unwind_Save_VFP>
 8000e58:	9b01      	ldr	r3, [sp, #4]
 8000e5a:	2f00      	cmp	r7, #0
 8000e5c:	d051      	beq.n	8000f02 <_Unwind_VRS_Pop+0x236>
 8000e5e:	6822      	ldr	r2, [r4, #0]
 8000e60:	0751      	lsls	r1, r2, #29
 8000e62:	d436      	bmi.n	8000ed2 <_Unwind_VRS_Pop+0x206>
 8000e64:	2b01      	cmp	r3, #1
 8000e66:	d03e      	beq.n	8000ee6 <_Unwind_VRS_Pop+0x21a>
 8000e68:	2e0f      	cmp	r6, #15
 8000e6a:	d806      	bhi.n	8000e7a <_Unwind_VRS_Pop+0x1ae>
 8000e6c:	a822      	add	r0, sp, #136	; 0x88
 8000e6e:	9301      	str	r3, [sp, #4]
 8000e70:	f000 f86c 	bl	8000f4c <__gnu_Unwind_Save_VFP_D>
 8000e74:	9b01      	ldr	r3, [sp, #4]
 8000e76:	2f00      	cmp	r7, #0
 8000e78:	d0a8      	beq.n	8000dcc <_Unwind_VRS_Pop+0x100>
 8000e7a:	a802      	add	r0, sp, #8
 8000e7c:	9301      	str	r3, [sp, #4]
 8000e7e:	f000 f86d 	bl	8000f5c <__gnu_Unwind_Save_VFP_D_16_to_31>
 8000e82:	9b01      	ldr	r3, [sp, #4]
 8000e84:	f1c6 0210 	rsb	r2, r6, #16
 8000e88:	e7a2      	b.n	8000dd0 <_Unwind_VRS_Pop+0x104>
 8000e8a:	a822      	add	r0, sp, #136	; 0x88
 8000e8c:	f000 f85a 	bl	8000f44 <__gnu_Unwind_Restore_VFP_D>
 8000e90:	e7c8      	b.n	8000e24 <_Unwind_VRS_Pop+0x158>
 8000e92:	2f10      	cmp	r7, #16
 8000e94:	d9cf      	bls.n	8000e36 <_Unwind_VRS_Pop+0x16a>
 8000e96:	3f10      	subs	r7, #16
 8000e98:	e7ce      	b.n	8000e38 <_Unwind_VRS_Pop+0x16c>
 8000e9a:	f023 0310 	bic.w	r3, r3, #16
 8000e9e:	6023      	str	r3, [r4, #0]
 8000ea0:	f504 70e8 	add.w	r0, r4, #464	; 0x1d0
 8000ea4:	9201      	str	r2, [sp, #4]
 8000ea6:	f000 f8ab 	bl	8001000 <__gnu_Unwind_Save_WMMXC>
 8000eaa:	9a01      	ldr	r2, [sp, #4]
 8000eac:	e72c      	b.n	8000d08 <_Unwind_VRS_Pop+0x3c>
 8000eae:	3104      	adds	r1, #4
 8000eb0:	63a1      	str	r1, [r4, #56]	; 0x38
 8000eb2:	a822      	add	r0, sp, #136	; 0x88
 8000eb4:	f000 f83e 	bl	8000f34 <__gnu_Unwind_Restore_VFP>
 8000eb8:	e7b8      	b.n	8000e2c <_Unwind_VRS_Pop+0x160>
 8000eba:	2f00      	cmp	r7, #0
 8000ebc:	d19a      	bne.n	8000df4 <_Unwind_VRS_Pop+0x128>
 8000ebe:	4601      	mov	r1, r0
 8000ec0:	e7ab      	b.n	8000e1a <_Unwind_VRS_Pop+0x14e>
 8000ec2:	f023 0308 	bic.w	r3, r3, #8
 8000ec6:	6023      	str	r3, [r4, #0]
 8000ec8:	f504 70a8 	add.w	r0, r4, #336	; 0x150
 8000ecc:	f000 f86c 	bl	8000fa8 <__gnu_Unwind_Save_WMMXD>
 8000ed0:	e73f      	b.n	8000d52 <_Unwind_VRS_Pop+0x86>
 8000ed2:	4620      	mov	r0, r4
 8000ed4:	f022 0204 	bic.w	r2, r2, #4
 8000ed8:	f840 2bd0 	str.w	r2, [r0], #208
 8000edc:	9301      	str	r3, [sp, #4]
 8000ede:	f000 f83d 	bl	8000f5c <__gnu_Unwind_Save_VFP_D_16_to_31>
 8000ee2:	9b01      	ldr	r3, [sp, #4]
 8000ee4:	e7be      	b.n	8000e64 <_Unwind_VRS_Pop+0x198>
 8000ee6:	a822      	add	r0, sp, #136	; 0x88
 8000ee8:	9301      	str	r3, [sp, #4]
 8000eea:	f000 f827 	bl	8000f3c <__gnu_Unwind_Save_VFP>
 8000eee:	9b01      	ldr	r3, [sp, #4]
 8000ef0:	e7c8      	b.n	8000e84 <_Unwind_VRS_Pop+0x1b8>
 8000ef2:	f041 0102 	orr.w	r1, r1, #2
 8000ef6:	f840 1b48 	str.w	r1, [r0], #72
 8000efa:	f000 f827 	bl	8000f4c <__gnu_Unwind_Save_VFP_D>
 8000efe:	9b01      	ldr	r3, [sp, #4]
 8000f00:	e7ab      	b.n	8000e5a <_Unwind_VRS_Pop+0x18e>
 8000f02:	2b01      	cmp	r3, #1
 8000f04:	d003      	beq.n	8000f0e <_Unwind_VRS_Pop+0x242>
 8000f06:	2e0f      	cmp	r6, #15
 8000f08:	f63f af60 	bhi.w	8000dcc <_Unwind_VRS_Pop+0x100>
 8000f0c:	e7ae      	b.n	8000e6c <_Unwind_VRS_Pop+0x1a0>
 8000f0e:	a822      	add	r0, sp, #136	; 0x88
 8000f10:	9301      	str	r3, [sp, #4]
 8000f12:	f000 f813 	bl	8000f3c <__gnu_Unwind_Save_VFP>
 8000f16:	9b01      	ldr	r3, [sp, #4]
 8000f18:	e758      	b.n	8000dcc <_Unwind_VRS_Pop+0x100>
 8000f1a:	bf00      	nop

08000f1c <__restore_core_regs>:
 8000f1c:	f100 0134 	add.w	r1, r0, #52	; 0x34
 8000f20:	e891 0038 	ldmia.w	r1, {r3, r4, r5}
 8000f24:	469c      	mov	ip, r3
 8000f26:	46a6      	mov	lr, r4
 8000f28:	f84c 5d04 	str.w	r5, [ip, #-4]!
 8000f2c:	e890 0fff 	ldmia.w	r0, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp}
 8000f30:	46e5      	mov	sp, ip
 8000f32:	bd00      	pop	{pc}

08000f34 <__gnu_Unwind_Restore_VFP>:
 8000f34:	ec90 0b21 	fldmiax	r0, {d0-d15}	;@ Deprecated
 8000f38:	4770      	bx	lr
 8000f3a:	bf00      	nop

08000f3c <__gnu_Unwind_Save_VFP>:
 8000f3c:	ec80 0b21 	fstmiax	r0, {d0-d15}	;@ Deprecated
 8000f40:	4770      	bx	lr
 8000f42:	bf00      	nop

08000f44 <__gnu_Unwind_Restore_VFP_D>:
 8000f44:	ec90 0b20 	vldmia	r0, {d0-d15}
 8000f48:	4770      	bx	lr
 8000f4a:	bf00      	nop

08000f4c <__gnu_Unwind_Save_VFP_D>:
 8000f4c:	ec80 0b20 	vstmia	r0, {d0-d15}
 8000f50:	4770      	bx	lr
 8000f52:	bf00      	nop

08000f54 <__gnu_Unwind_Restore_VFP_D_16_to_31>:
 8000f54:	ecd0 0b20 	vldmia	r0, {d16-d31}
 8000f58:	4770      	bx	lr
 8000f5a:	bf00      	nop

08000f5c <__gnu_Unwind_Save_VFP_D_16_to_31>:
 8000f5c:	ecc0 0b20 	vstmia	r0, {d16-d31}
 8000f60:	4770      	bx	lr
 8000f62:	bf00      	nop

08000f64 <__gnu_Unwind_Restore_WMMXD>:
 8000f64:	ecf0 0102 	ldfe	f0, [r0], #8
 8000f68:	ecf0 1102 	ldfe	f1, [r0], #8
 8000f6c:	ecf0 2102 	ldfe	f2, [r0], #8
 8000f70:	ecf0 3102 	ldfe	f3, [r0], #8
 8000f74:	ecf0 4102 	ldfe	f4, [r0], #8
 8000f78:	ecf0 5102 	ldfe	f5, [r0], #8
 8000f7c:	ecf0 6102 	ldfe	f6, [r0], #8
 8000f80:	ecf0 7102 	ldfe	f7, [r0], #8
 8000f84:	ecf0 8102 	ldfp	f0, [r0], #8
 8000f88:	ecf0 9102 	ldfp	f1, [r0], #8
 8000f8c:	ecf0 a102 	ldfp	f2, [r0], #8
 8000f90:	ecf0 b102 	ldfp	f3, [r0], #8
 8000f94:	ecf0 c102 	ldfp	f4, [r0], #8
 8000f98:	ecf0 d102 	ldfp	f5, [r0], #8
 8000f9c:	ecf0 e102 	ldfp	f6, [r0], #8
 8000fa0:	ecf0 f102 	ldfp	f7, [r0], #8
 8000fa4:	4770      	bx	lr
 8000fa6:	bf00      	nop

08000fa8 <__gnu_Unwind_Save_WMMXD>:
 8000fa8:	ece0 0102 	stfe	f0, [r0], #8
 8000fac:	ece0 1102 	stfe	f1, [r0], #8
 8000fb0:	ece0 2102 	stfe	f2, [r0], #8
 8000fb4:	ece0 3102 	stfe	f3, [r0], #8
 8000fb8:	ece0 4102 	stfe	f4, [r0], #8
 8000fbc:	ece0 5102 	stfe	f5, [r0], #8
 8000fc0:	ece0 6102 	stfe	f6, [r0], #8
 8000fc4:	ece0 7102 	stfe	f7, [r0], #8
 8000fc8:	ece0 8102 	stfp	f0, [r0], #8
 8000fcc:	ece0 9102 	stfp	f1, [r0], #8
 8000fd0:	ece0 a102 	stfp	f2, [r0], #8
 8000fd4:	ece0 b102 	stfp	f3, [r0], #8
 8000fd8:	ece0 c102 	stfp	f4, [r0], #8
 8000fdc:	ece0 d102 	stfp	f5, [r0], #8
 8000fe0:	ece0 e102 	stfp	f6, [r0], #8
 8000fe4:	ece0 f102 	stfp	f7, [r0], #8
 8000fe8:	4770      	bx	lr
 8000fea:	bf00      	nop

08000fec <__gnu_Unwind_Restore_WMMXC>:
 8000fec:	fcb0 8101 	ldc2	1, cr8, [r0], #4
 8000ff0:	fcb0 9101 	ldc2	1, cr9, [r0], #4
 8000ff4:	fcb0 a101 	ldc2	1, cr10, [r0], #4
 8000ff8:	fcb0 b101 	ldc2	1, cr11, [r0], #4
 8000ffc:	4770      	bx	lr
 8000ffe:	bf00      	nop

08001000 <__gnu_Unwind_Save_WMMXC>:
 8001000:	fca0 8101 	stc2	1, cr8, [r0], #4
 8001004:	fca0 9101 	stc2	1, cr9, [r0], #4
 8001008:	fca0 a101 	stc2	1, cr10, [r0], #4
 800100c:	fca0 b101 	stc2	1, cr11, [r0], #4
 8001010:	4770      	bx	lr
 8001012:	bf00      	nop

08001014 <_Unwind_RaiseException>:
 8001014:	46ec      	mov	ip, sp
 8001016:	b500      	push	{lr}
 8001018:	e92d 5000 	stmdb	sp!, {ip, lr}
 800101c:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8001020:	f04f 0300 	mov.w	r3, #0
 8001024:	e92d 000c 	stmdb	sp!, {r2, r3}
 8001028:	a901      	add	r1, sp, #4
 800102a:	f7ff fbe9 	bl	8000800 <__gnu_Unwind_RaiseException>
 800102e:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8001032:	b012      	add	sp, #72	; 0x48
 8001034:	4770      	bx	lr
 8001036:	bf00      	nop

08001038 <_Unwind_Resume>:
 8001038:	46ec      	mov	ip, sp
 800103a:	b500      	push	{lr}
 800103c:	e92d 5000 	stmdb	sp!, {ip, lr}
 8001040:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8001044:	f04f 0300 	mov.w	r3, #0
 8001048:	e92d 000c 	stmdb	sp!, {r2, r3}
 800104c:	a901      	add	r1, sp, #4
 800104e:	f7ff fc11 	bl	8000874 <__gnu_Unwind_Resume>
 8001052:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 8001056:	b012      	add	sp, #72	; 0x48
 8001058:	4770      	bx	lr
 800105a:	bf00      	nop

0800105c <_Unwind_Resume_or_Rethrow>:
 800105c:	46ec      	mov	ip, sp
 800105e:	b500      	push	{lr}
 8001060:	e92d 5000 	stmdb	sp!, {ip, lr}
 8001064:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8001068:	f04f 0300 	mov.w	r3, #0
 800106c:	e92d 000c 	stmdb	sp!, {r2, r3}
 8001070:	a901      	add	r1, sp, #4
 8001072:	f7ff fc21 	bl	80008b8 <__gnu_Unwind_Resume_or_Rethrow>
 8001076:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 800107a:	b012      	add	sp, #72	; 0x48
 800107c:	4770      	bx	lr
 800107e:	bf00      	nop

08001080 <_Unwind_ForcedUnwind>:
 8001080:	46ec      	mov	ip, sp
 8001082:	b500      	push	{lr}
 8001084:	e92d 5000 	stmdb	sp!, {ip, lr}
 8001088:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 800108c:	f04f 0300 	mov.w	r3, #0
 8001090:	e92d 000c 	stmdb	sp!, {r2, r3}
 8001094:	ab01      	add	r3, sp, #4
 8001096:	f7ff fbe3 	bl	8000860 <__gnu_Unwind_ForcedUnwind>
 800109a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 800109e:	b012      	add	sp, #72	; 0x48
 80010a0:	4770      	bx	lr
 80010a2:	bf00      	nop

080010a4 <_Unwind_Backtrace>:
 80010a4:	46ec      	mov	ip, sp
 80010a6:	b500      	push	{lr}
 80010a8:	e92d 5000 	stmdb	sp!, {ip, lr}
 80010ac:	e92d 1fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 80010b0:	f04f 0300 	mov.w	r3, #0
 80010b4:	e92d 000c 	stmdb	sp!, {r2, r3}
 80010b8:	aa01      	add	r2, sp, #4
 80010ba:	f7ff fc5b 	bl	8000974 <__gnu_Unwind_Backtrace>
 80010be:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
 80010c2:	b012      	add	sp, #72	; 0x48
 80010c4:	4770      	bx	lr
 80010c6:	bf00      	nop

080010c8 <next_unwind_byte>:
 80010c8:	7a03      	ldrb	r3, [r0, #8]
 80010ca:	b91b      	cbnz	r3, 80010d4 <next_unwind_byte+0xc>
 80010cc:	7a43      	ldrb	r3, [r0, #9]
 80010ce:	b943      	cbnz	r3, 80010e2 <next_unwind_byte+0x1a>
 80010d0:	20b0      	movs	r0, #176	; 0xb0
 80010d2:	4770      	bx	lr
 80010d4:	1e5a      	subs	r2, r3, #1
 80010d6:	6803      	ldr	r3, [r0, #0]
 80010d8:	7202      	strb	r2, [r0, #8]
 80010da:	021a      	lsls	r2, r3, #8
 80010dc:	6002      	str	r2, [r0, #0]
 80010de:	0e18      	lsrs	r0, r3, #24
 80010e0:	4770      	bx	lr
 80010e2:	6842      	ldr	r2, [r0, #4]
 80010e4:	3b01      	subs	r3, #1
 80010e6:	b410      	push	{r4}
 80010e8:	7243      	strb	r3, [r0, #9]
 80010ea:	6813      	ldr	r3, [r2, #0]
 80010ec:	2103      	movs	r1, #3
 80010ee:	1d14      	adds	r4, r2, #4
 80010f0:	7201      	strb	r1, [r0, #8]
 80010f2:	021a      	lsls	r2, r3, #8
 80010f4:	6044      	str	r4, [r0, #4]
 80010f6:	6002      	str	r2, [r0, #0]
 80010f8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80010fc:	0e18      	lsrs	r0, r3, #24
 80010fe:	4770      	bx	lr

08001100 <_Unwind_GetGR.constprop.0>:
 8001100:	b500      	push	{lr}
 8001102:	b085      	sub	sp, #20
 8001104:	aa03      	add	r2, sp, #12
 8001106:	2300      	movs	r3, #0
 8001108:	9200      	str	r2, [sp, #0]
 800110a:	4619      	mov	r1, r3
 800110c:	220c      	movs	r2, #12
 800110e:	f7ff fbe3 	bl	80008d8 <_Unwind_VRS_Get>
 8001112:	9803      	ldr	r0, [sp, #12]
 8001114:	b005      	add	sp, #20
 8001116:	f85d fb04 	ldr.w	pc, [sp], #4
 800111a:	bf00      	nop

0800111c <unwind_UCB_from_context>:
 800111c:	e7f0      	b.n	8001100 <_Unwind_GetGR.constprop.0>
 800111e:	bf00      	nop

08001120 <__gnu_unwind_execute>:
 8001120:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001124:	4606      	mov	r6, r0
 8001126:	b085      	sub	sp, #20
 8001128:	460d      	mov	r5, r1
 800112a:	f04f 0800 	mov.w	r8, #0
 800112e:	4628      	mov	r0, r5
 8001130:	f7ff ffca 	bl	80010c8 <next_unwind_byte>
 8001134:	28b0      	cmp	r0, #176	; 0xb0
 8001136:	4604      	mov	r4, r0
 8001138:	f000 80b4 	beq.w	80012a4 <__gnu_unwind_execute+0x184>
 800113c:	f020 037f 	bic.w	r3, r0, #127	; 0x7f
 8001140:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 8001144:	d020      	beq.n	8001188 <__gnu_unwind_execute+0x68>
 8001146:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
 800114a:	2b80      	cmp	r3, #128	; 0x80
 800114c:	d07a      	beq.n	8001244 <__gnu_unwind_execute+0x124>
 800114e:	2b90      	cmp	r3, #144	; 0x90
 8001150:	d035      	beq.n	80011be <__gnu_unwind_execute+0x9e>
 8001152:	2ba0      	cmp	r3, #160	; 0xa0
 8001154:	d048      	beq.n	80011e8 <__gnu_unwind_execute+0xc8>
 8001156:	2bb0      	cmp	r3, #176	; 0xb0
 8001158:	d05c      	beq.n	8001214 <__gnu_unwind_execute+0xf4>
 800115a:	2bc0      	cmp	r3, #192	; 0xc0
 800115c:	f000 8089 	beq.w	8001272 <__gnu_unwind_execute+0x152>
 8001160:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
 8001164:	2bd0      	cmp	r3, #208	; 0xd0
 8001166:	d10b      	bne.n	8001180 <__gnu_unwind_execute+0x60>
 8001168:	f000 0207 	and.w	r2, r0, #7
 800116c:	3201      	adds	r2, #1
 800116e:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8001172:	2305      	movs	r3, #5
 8001174:	2101      	movs	r1, #1
 8001176:	4630      	mov	r0, r6
 8001178:	f7ff fda8 	bl	8000ccc <_Unwind_VRS_Pop>
 800117c:	2800      	cmp	r0, #0
 800117e:	d0d6      	beq.n	800112e <__gnu_unwind_execute+0xe>
 8001180:	2009      	movs	r0, #9
 8001182:	b005      	add	sp, #20
 8001184:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001188:	f10d 090c 	add.w	r9, sp, #12
 800118c:	4619      	mov	r1, r3
 800118e:	0087      	lsls	r7, r0, #2
 8001190:	f8cd 9000 	str.w	r9, [sp]
 8001194:	220d      	movs	r2, #13
 8001196:	4630      	mov	r0, r6
 8001198:	f7ff fb9e 	bl	80008d8 <_Unwind_VRS_Get>
 800119c:	b2ff      	uxtb	r7, r7
 800119e:	9b03      	ldr	r3, [sp, #12]
 80011a0:	f8cd 9000 	str.w	r9, [sp]
 80011a4:	3704      	adds	r7, #4
 80011a6:	0660      	lsls	r0, r4, #25
 80011a8:	bf4c      	ite	mi
 80011aa:	1bdf      	submi	r7, r3, r7
 80011ac:	18ff      	addpl	r7, r7, r3
 80011ae:	2300      	movs	r3, #0
 80011b0:	4619      	mov	r1, r3
 80011b2:	220d      	movs	r2, #13
 80011b4:	4630      	mov	r0, r6
 80011b6:	9703      	str	r7, [sp, #12]
 80011b8:	f7ff fbb4 	bl	8000924 <_Unwind_VRS_Set>
 80011bc:	e7b7      	b.n	800112e <__gnu_unwind_execute+0xe>
 80011be:	f000 030d 	and.w	r3, r0, #13
 80011c2:	2b0d      	cmp	r3, #13
 80011c4:	d0dc      	beq.n	8001180 <__gnu_unwind_execute+0x60>
 80011c6:	af03      	add	r7, sp, #12
 80011c8:	2300      	movs	r3, #0
 80011ca:	f000 020f 	and.w	r2, r0, #15
 80011ce:	4619      	mov	r1, r3
 80011d0:	9700      	str	r7, [sp, #0]
 80011d2:	4630      	mov	r0, r6
 80011d4:	f7ff fb80 	bl	80008d8 <_Unwind_VRS_Get>
 80011d8:	2300      	movs	r3, #0
 80011da:	9700      	str	r7, [sp, #0]
 80011dc:	4619      	mov	r1, r3
 80011de:	220d      	movs	r2, #13
 80011e0:	4630      	mov	r0, r6
 80011e2:	f7ff fb9f 	bl	8000924 <_Unwind_VRS_Set>
 80011e6:	e7a2      	b.n	800112e <__gnu_unwind_execute+0xe>
 80011e8:	43c2      	mvns	r2, r0
 80011ea:	f44f 637f 	mov.w	r3, #4080	; 0xff0
 80011ee:	f002 0207 	and.w	r2, r2, #7
 80011f2:	fa43 f202 	asr.w	r2, r3, r2
 80011f6:	0701      	lsls	r1, r0, #28
 80011f8:	ea02 0203 	and.w	r2, r2, r3
 80011fc:	f04f 0300 	mov.w	r3, #0
 8001200:	bf48      	it	mi
 8001202:	f442 4280 	orrmi.w	r2, r2, #16384	; 0x4000
 8001206:	4619      	mov	r1, r3
 8001208:	4630      	mov	r0, r6
 800120a:	f7ff fd5f 	bl	8000ccc <_Unwind_VRS_Pop>
 800120e:	2800      	cmp	r0, #0
 8001210:	d1b6      	bne.n	8001180 <__gnu_unwind_execute+0x60>
 8001212:	e78c      	b.n	800112e <__gnu_unwind_execute+0xe>
 8001214:	28b1      	cmp	r0, #177	; 0xb1
 8001216:	d04a      	beq.n	80012ae <__gnu_unwind_execute+0x18e>
 8001218:	28b2      	cmp	r0, #178	; 0xb2
 800121a:	d053      	beq.n	80012c4 <__gnu_unwind_execute+0x1a4>
 800121c:	28b3      	cmp	r0, #179	; 0xb3
 800121e:	f000 8081 	beq.w	8001324 <__gnu_unwind_execute+0x204>
 8001222:	f000 03fc 	and.w	r3, r0, #252	; 0xfc
 8001226:	2bb4      	cmp	r3, #180	; 0xb4
 8001228:	d0aa      	beq.n	8001180 <__gnu_unwind_execute+0x60>
 800122a:	f000 0207 	and.w	r2, r0, #7
 800122e:	3201      	adds	r2, #1
 8001230:	2301      	movs	r3, #1
 8001232:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8001236:	4619      	mov	r1, r3
 8001238:	4630      	mov	r0, r6
 800123a:	f7ff fd47 	bl	8000ccc <_Unwind_VRS_Pop>
 800123e:	2800      	cmp	r0, #0
 8001240:	d19e      	bne.n	8001180 <__gnu_unwind_execute+0x60>
 8001242:	e774      	b.n	800112e <__gnu_unwind_execute+0xe>
 8001244:	4628      	mov	r0, r5
 8001246:	f7ff ff3f 	bl	80010c8 <next_unwind_byte>
 800124a:	0224      	lsls	r4, r4, #8
 800124c:	4320      	orrs	r0, r4
 800124e:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8001252:	d095      	beq.n	8001180 <__gnu_unwind_execute+0x60>
 8001254:	0104      	lsls	r4, r0, #4
 8001256:	2300      	movs	r3, #0
 8001258:	b2a2      	uxth	r2, r4
 800125a:	4619      	mov	r1, r3
 800125c:	4630      	mov	r0, r6
 800125e:	f7ff fd35 	bl	8000ccc <_Unwind_VRS_Pop>
 8001262:	2800      	cmp	r0, #0
 8001264:	d18c      	bne.n	8001180 <__gnu_unwind_execute+0x60>
 8001266:	f414 4f00 	tst.w	r4, #32768	; 0x8000
 800126a:	bf18      	it	ne
 800126c:	f04f 0801 	movne.w	r8, #1
 8001270:	e75d      	b.n	800112e <__gnu_unwind_execute+0xe>
 8001272:	28c6      	cmp	r0, #198	; 0xc6
 8001274:	d062      	beq.n	800133c <__gnu_unwind_execute+0x21c>
 8001276:	28c7      	cmp	r0, #199	; 0xc7
 8001278:	d06c      	beq.n	8001354 <__gnu_unwind_execute+0x234>
 800127a:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
 800127e:	2bc0      	cmp	r3, #192	; 0xc0
 8001280:	d07b      	beq.n	800137a <__gnu_unwind_execute+0x25a>
 8001282:	28c8      	cmp	r0, #200	; 0xc8
 8001284:	f000 8091 	beq.w	80013aa <__gnu_unwind_execute+0x28a>
 8001288:	28c9      	cmp	r0, #201	; 0xc9
 800128a:	f47f af79 	bne.w	8001180 <__gnu_unwind_execute+0x60>
 800128e:	4628      	mov	r0, r5
 8001290:	f7ff ff1a 	bl	80010c8 <next_unwind_byte>
 8001294:	0302      	lsls	r2, r0, #12
 8001296:	f000 000f 	and.w	r0, r0, #15
 800129a:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
 800129e:	3001      	adds	r0, #1
 80012a0:	4302      	orrs	r2, r0
 80012a2:	e766      	b.n	8001172 <__gnu_unwind_execute+0x52>
 80012a4:	f1b8 0f00 	cmp.w	r8, #0
 80012a8:	d06e      	beq.n	8001388 <__gnu_unwind_execute+0x268>
 80012aa:	2000      	movs	r0, #0
 80012ac:	e769      	b.n	8001182 <__gnu_unwind_execute+0x62>
 80012ae:	4628      	mov	r0, r5
 80012b0:	f7ff ff0a 	bl	80010c8 <next_unwind_byte>
 80012b4:	4602      	mov	r2, r0
 80012b6:	2800      	cmp	r0, #0
 80012b8:	f43f af62 	beq.w	8001180 <__gnu_unwind_execute+0x60>
 80012bc:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
 80012c0:	d0b9      	beq.n	8001236 <__gnu_unwind_execute+0x116>
 80012c2:	e75d      	b.n	8001180 <__gnu_unwind_execute+0x60>
 80012c4:	2300      	movs	r3, #0
 80012c6:	f10d 090c 	add.w	r9, sp, #12
 80012ca:	220d      	movs	r2, #13
 80012cc:	4619      	mov	r1, r3
 80012ce:	f8cd 9000 	str.w	r9, [sp]
 80012d2:	4630      	mov	r0, r6
 80012d4:	f7ff fb00 	bl	80008d8 <_Unwind_VRS_Get>
 80012d8:	4628      	mov	r0, r5
 80012da:	f7ff fef5 	bl	80010c8 <next_unwind_byte>
 80012de:	0602      	lsls	r2, r0, #24
 80012e0:	f04f 0402 	mov.w	r4, #2
 80012e4:	d50c      	bpl.n	8001300 <__gnu_unwind_execute+0x1e0>
 80012e6:	9b03      	ldr	r3, [sp, #12]
 80012e8:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 80012ec:	40a0      	lsls	r0, r4
 80012ee:	4403      	add	r3, r0
 80012f0:	4628      	mov	r0, r5
 80012f2:	9303      	str	r3, [sp, #12]
 80012f4:	f7ff fee8 	bl	80010c8 <next_unwind_byte>
 80012f8:	0603      	lsls	r3, r0, #24
 80012fa:	f104 0407 	add.w	r4, r4, #7
 80012fe:	d4f2      	bmi.n	80012e6 <__gnu_unwind_execute+0x1c6>
 8001300:	9b03      	ldr	r3, [sp, #12]
 8001302:	f8cd 9000 	str.w	r9, [sp]
 8001306:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 800130a:	fa00 f204 	lsl.w	r2, r0, r4
 800130e:	f503 7401 	add.w	r4, r3, #516	; 0x204
 8001312:	2300      	movs	r3, #0
 8001314:	4414      	add	r4, r2
 8001316:	4619      	mov	r1, r3
 8001318:	220d      	movs	r2, #13
 800131a:	4630      	mov	r0, r6
 800131c:	9403      	str	r4, [sp, #12]
 800131e:	f7ff fb01 	bl	8000924 <_Unwind_VRS_Set>
 8001322:	e704      	b.n	800112e <__gnu_unwind_execute+0xe>
 8001324:	4628      	mov	r0, r5
 8001326:	f7ff fecf 	bl	80010c8 <next_unwind_byte>
 800132a:	0301      	lsls	r1, r0, #12
 800132c:	f000 000f 	and.w	r0, r0, #15
 8001330:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
 8001334:	1c42      	adds	r2, r0, #1
 8001336:	2301      	movs	r3, #1
 8001338:	430a      	orrs	r2, r1
 800133a:	e77c      	b.n	8001236 <__gnu_unwind_execute+0x116>
 800133c:	4628      	mov	r0, r5
 800133e:	f7ff fec3 	bl	80010c8 <next_unwind_byte>
 8001342:	0301      	lsls	r1, r0, #12
 8001344:	f000 000f 	and.w	r0, r0, #15
 8001348:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
 800134c:	1c42      	adds	r2, r0, #1
 800134e:	2303      	movs	r3, #3
 8001350:	430a      	orrs	r2, r1
 8001352:	e770      	b.n	8001236 <__gnu_unwind_execute+0x116>
 8001354:	4628      	mov	r0, r5
 8001356:	f7ff feb7 	bl	80010c8 <next_unwind_byte>
 800135a:	4602      	mov	r2, r0
 800135c:	2800      	cmp	r0, #0
 800135e:	f43f af0f 	beq.w	8001180 <__gnu_unwind_execute+0x60>
 8001362:	f010 03f0 	ands.w	r3, r0, #240	; 0xf0
 8001366:	f47f af0b 	bne.w	8001180 <__gnu_unwind_execute+0x60>
 800136a:	2104      	movs	r1, #4
 800136c:	4630      	mov	r0, r6
 800136e:	f7ff fcad 	bl	8000ccc <_Unwind_VRS_Pop>
 8001372:	2800      	cmp	r0, #0
 8001374:	f47f af04 	bne.w	8001180 <__gnu_unwind_execute+0x60>
 8001378:	e6d9      	b.n	800112e <__gnu_unwind_execute+0xe>
 800137a:	f000 020f 	and.w	r2, r0, #15
 800137e:	3201      	adds	r2, #1
 8001380:	2303      	movs	r3, #3
 8001382:	f442 2220 	orr.w	r2, r2, #655360	; 0xa0000
 8001386:	e756      	b.n	8001236 <__gnu_unwind_execute+0x116>
 8001388:	ac03      	add	r4, sp, #12
 800138a:	4643      	mov	r3, r8
 800138c:	220e      	movs	r2, #14
 800138e:	4641      	mov	r1, r8
 8001390:	9400      	str	r4, [sp, #0]
 8001392:	4630      	mov	r0, r6
 8001394:	f7ff faa0 	bl	80008d8 <_Unwind_VRS_Get>
 8001398:	9400      	str	r4, [sp, #0]
 800139a:	4630      	mov	r0, r6
 800139c:	4643      	mov	r3, r8
 800139e:	220f      	movs	r2, #15
 80013a0:	4641      	mov	r1, r8
 80013a2:	f7ff fabf 	bl	8000924 <_Unwind_VRS_Set>
 80013a6:	4640      	mov	r0, r8
 80013a8:	e6eb      	b.n	8001182 <__gnu_unwind_execute+0x62>
 80013aa:	4628      	mov	r0, r5
 80013ac:	f7ff fe8c 	bl	80010c8 <next_unwind_byte>
 80013b0:	f000 02f0 	and.w	r2, r0, #240	; 0xf0
 80013b4:	f000 030f 	and.w	r3, r0, #15
 80013b8:	3210      	adds	r2, #16
 80013ba:	3301      	adds	r3, #1
 80013bc:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
 80013c0:	e6d7      	b.n	8001172 <__gnu_unwind_execute+0x52>
 80013c2:	bf00      	nop

080013c4 <__gnu_unwind_frame>:
 80013c4:	b510      	push	{r4, lr}
 80013c6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80013c8:	b084      	sub	sp, #16
 80013ca:	685a      	ldr	r2, [r3, #4]
 80013cc:	2003      	movs	r0, #3
 80013ce:	f88d 000c 	strb.w	r0, [sp, #12]
 80013d2:	79dc      	ldrb	r4, [r3, #7]
 80013d4:	f88d 400d 	strb.w	r4, [sp, #13]
 80013d8:	0212      	lsls	r2, r2, #8
 80013da:	3308      	adds	r3, #8
 80013dc:	4608      	mov	r0, r1
 80013de:	a901      	add	r1, sp, #4
 80013e0:	9201      	str	r2, [sp, #4]
 80013e2:	9302      	str	r3, [sp, #8]
 80013e4:	f7ff fe9c 	bl	8001120 <__gnu_unwind_execute>
 80013e8:	b004      	add	sp, #16
 80013ea:	bd10      	pop	{r4, pc}

080013ec <_Unwind_GetRegionStart>:
 80013ec:	b508      	push	{r3, lr}
 80013ee:	f7ff fe95 	bl	800111c <unwind_UCB_from_context>
 80013f2:	6c80      	ldr	r0, [r0, #72]	; 0x48
 80013f4:	bd08      	pop	{r3, pc}
 80013f6:	bf00      	nop

080013f8 <_Unwind_GetLanguageSpecificData>:
 80013f8:	b508      	push	{r3, lr}
 80013fa:	f7ff fe8f 	bl	800111c <unwind_UCB_from_context>
 80013fe:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8001400:	79d8      	ldrb	r0, [r3, #7]
 8001402:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8001406:	3008      	adds	r0, #8
 8001408:	bd08      	pop	{r3, pc}
 800140a:	bf00      	nop

0800140c <_Unwind_GetTextRelBase>:
 800140c:	b508      	push	{r3, lr}
 800140e:	f006 fca7 	bl	8007d60 <abort>
 8001412:	bf00      	nop

08001414 <_Unwind_GetDataRelBase>:
 8001414:	b508      	push	{r3, lr}
 8001416:	f7ff fff9 	bl	800140c <_Unwind_GetTextRelBase>
 800141a:	bf00      	nop

0800141c <__aeabi_idiv0>:
 800141c:	4770      	bx	lr
 800141e:	bf00      	nop

08001420 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack       /* set stack pointer */
 8001420:	f8df d034 	ldr.w	sp, [pc, #52]	; 8001458 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
 8001424:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8001426:	e003      	b.n	8001430 <LoopCopyDataInit>

08001428 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8001428:	4b0c      	ldr	r3, [pc, #48]	; (800145c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800142a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800142c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800142e:	3104      	adds	r1, #4

08001430 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8001430:	480b      	ldr	r0, [pc, #44]	; (8001460 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8001432:	4b0c      	ldr	r3, [pc, #48]	; (8001464 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8001434:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8001436:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8001438:	d3f6      	bcc.n	8001428 <CopyDataInit>
  ldr  r2, =_sbss
 800143a:	4a0b      	ldr	r2, [pc, #44]	; (8001468 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800143c:	e002      	b.n	8001444 <LoopFillZerobss>

0800143e <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
 800143e:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8001440:	f842 3b04 	str.w	r3, [r2], #4

08001444 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8001444:	4b09      	ldr	r3, [pc, #36]	; (800146c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8001446:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8001448:	d3f9      	bcc.n	800143e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800144a:	f002 fd91 	bl	8003f70 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800144e:	f006 fc95 	bl	8007d7c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001452:	f001 f953 	bl	80026fc <main>
  bx  lr    
 8001456:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack       /* set stack pointer */
 8001458:	20008000 	.word	0x20008000
/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800145c:	08009b9c 	.word	0x08009b9c
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8001460:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8001464:	20000514 	.word	0x20000514
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8001468:	20000514 	.word	0x20000514
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800146c:	20003e54 	.word	0x20003e54

08001470 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001470:	e7fe      	b.n	8001470 <ADC_IRQHandler>
	...

08001474 <MX_ADC1_Init>:

ADC_HandleTypeDef hadc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 8001474:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  ADC_ChannelConfTypeDef sConfig;

    /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
    */
  hadc1.Instance = ADC1;
 8001476:	4815      	ldr	r0, [pc, #84]	; (80014cc <MX_ADC1_Init+0x58>)
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8001478:	4a15      	ldr	r2, [pc, #84]	; (80014d0 <MX_ADC1_Init+0x5c>)
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 800147a:	4916      	ldr	r1, [pc, #88]	; (80014d4 <MX_ADC1_Init+0x60>)
 800147c:	6281      	str	r1, [r0, #40]	; 0x28
  ADC_ChannelConfTypeDef sConfig;

    /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
    */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 800147e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001482:	e880 000c 	stmia.w	r0, {r2, r3}
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8001486:	2300      	movs	r3, #0
  hadc1.Init.ScanConvMode = ENABLE;
 8001488:	2201      	movs	r2, #1

    /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
    */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 800148a:	6083      	str	r3, [r0, #8]
  hadc1.Init.ScanConvMode = ENABLE;
 800148c:	6102      	str	r2, [r0, #16]
  hadc1.Init.ContinuousConvMode = DISABLE;
 800148e:	6183      	str	r3, [r0, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8001490:	6203      	str	r3, [r0, #32]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8001492:	62c3      	str	r3, [r0, #44]	; 0x2c
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8001494:	60c3      	str	r3, [r0, #12]
  hadc1.Init.NbrOfConversion = 1;
 8001496:	61c2      	str	r2, [r0, #28]
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8001498:	6303      	str	r3, [r0, #48]	; 0x30
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800149a:	6142      	str	r2, [r0, #20]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 800149c:	f002 fdda 	bl	8004054 <HAL_ADC_Init>
 80014a0:	b118      	cbz	r0, 80014aa <MX_ADC1_Init+0x36>
  {
    _Error_Handler(__FILE__, __LINE__);
 80014a2:	2148      	movs	r1, #72	; 0x48
 80014a4:	480c      	ldr	r0, [pc, #48]	; (80014d8 <MX_ADC1_Init+0x64>)
 80014a6:	f001 f80d 	bl	80024c4 <_Error_Handler>

    /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
    */
  sConfig.Channel = ADC_CHANNEL_2;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 80014aa:	2102      	movs	r1, #2
 80014ac:	2201      	movs	r2, #1
 80014ae:	2300      	movs	r3, #0
 80014b0:	e88d 000e 	stmia.w	sp, {r1, r2, r3}
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80014b4:	4805      	ldr	r0, [pc, #20]	; (80014cc <MX_ADC1_Init+0x58>)
 80014b6:	4669      	mov	r1, sp
 80014b8:	f002 fe70 	bl	800419c <HAL_ADC_ConfigChannel>
 80014bc:	b118      	cbz	r0, 80014c6 <MX_ADC1_Init+0x52>
  {
    _Error_Handler(__FILE__, __LINE__);
 80014be:	2152      	movs	r1, #82	; 0x52
 80014c0:	4805      	ldr	r0, [pc, #20]	; (80014d8 <MX_ADC1_Init+0x64>)
 80014c2:	f000 ffff 	bl	80024c4 <_Error_Handler>
  }

}
 80014c6:	b005      	add	sp, #20
 80014c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80014cc:	20000a20 	.word	0x20000a20
 80014d0:	40012000 	.word	0x40012000
 80014d4:	0f000001 	.word	0x0f000001
 80014d8:	080089e8 	.word	0x080089e8

080014dc <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 80014dc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(adcHandle->Instance==ADC1)
 80014de:	6802      	ldr	r2, [r0, #0]
 80014e0:	4b0d      	ldr	r3, [pc, #52]	; (8001518 <HAL_ADC_MspInit+0x3c>)
 80014e2:	429a      	cmp	r2, r3
 80014e4:	d115      	bne.n	8001512 <HAL_ADC_MspInit+0x36>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
 80014e6:	2100      	movs	r1, #0
 80014e8:	f503 338c 	add.w	r3, r3, #71680	; 0x11800
 80014ec:	9100      	str	r1, [sp, #0]
 80014ee:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    PA4     ------> ADC1_IN4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80014f0:	480a      	ldr	r0, [pc, #40]	; (800151c <HAL_ADC_MspInit+0x40>)
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
 80014f2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80014f6:	645a      	str	r2, [r3, #68]	; 0x44
 80014f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    PA3     ------> ADC1_IN3
    PA4     ------> ADC1_IN4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014fa:	9103      	str	r1, [sp, #12]
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
 80014fc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001500:	9300      	str	r3, [sp, #0]
 8001502:	9b00      	ldr	r3, [sp, #0]
    PA1     ------> ADC1_IN1
    PA2     ------> ADC1_IN2
    PA3     ------> ADC1_IN3
    PA4     ------> ADC1_IN4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;
 8001504:	231e      	movs	r3, #30
 8001506:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001508:	a901      	add	r1, sp, #4
    PA2     ------> ADC1_IN2
    PA3     ------> ADC1_IN3
    PA4     ------> ADC1_IN4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800150a:	2303      	movs	r3, #3
 800150c:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800150e:	f003 faad 	bl	8004a6c <HAL_GPIO_Init>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8001512:	b007      	add	sp, #28
 8001514:	f85d fb04 	ldr.w	pc, [sp], #4
 8001518:	40012000 	.word	0x40012000
 800151c:	40020000 	.word	0x40020000

08001520 <MX_DMA_Init>:

/** 
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
 8001520:	b507      	push	{r0, r1, r2, lr}
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8001522:	2300      	movs	r3, #0
 8001524:	9301      	str	r3, [sp, #4]
 8001526:	4b0e      	ldr	r3, [pc, #56]	; (8001560 <MX_DMA_Init+0x40>)
 8001528:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800152a:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800152e:	631a      	str	r2, [r3, #48]	; 0x30
 8001530:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001532:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8001536:	9301      	str	r3, [sp, #4]

  /* DMA interrupt init */
  /* DMA2_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 2, 1);
 8001538:	2201      	movs	r2, #1
 800153a:	2102      	movs	r1, #2
 800153c:	203a      	movs	r0, #58	; 0x3a
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 800153e:	9b01      	ldr	r3, [sp, #4]

  /* DMA interrupt init */
  /* DMA2_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 2, 1);
 8001540:	f002 fed4 	bl	80042ec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
 8001544:	203a      	movs	r0, #58	; 0x3a
 8001546:	f002 ff05 	bl	8004354 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream7_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 2, 1);
 800154a:	2201      	movs	r2, #1
 800154c:	2102      	movs	r1, #2
 800154e:	2046      	movs	r0, #70	; 0x46
 8001550:	f002 fecc 	bl	80042ec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);
 8001554:	2046      	movs	r0, #70	; 0x46
 8001556:	f002 fefd 	bl	8004354 <HAL_NVIC_EnableIRQ>

}
 800155a:	b003      	add	sp, #12
 800155c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001560:	40023800 	.word	0x40023800

08001564 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8001564:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001566:	b08b      	sub	sp, #44	; 0x2c

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001568:	4b27      	ldr	r3, [pc, #156]	; (8001608 <MX_GPIO_Init+0xa4>)
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(PC13_LED_GPIO_Port, PC13_LED_Pin, GPIO_PIN_RESET);
 800156a:	4f28      	ldr	r7, [pc, #160]	; (800160c <MX_GPIO_Init+0xa8>)

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_RESET);
 800156c:	4e28      	ldr	r6, [pc, #160]	; (8001610 <MX_GPIO_Init+0xac>)
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800156e:	2400      	movs	r4, #0
 8001570:	9401      	str	r4, [sp, #4]
 8001572:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001574:	f042 0204 	orr.w	r2, r2, #4
 8001578:	631a      	str	r2, [r3, #48]	; 0x30
 800157a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800157c:	f002 0204 	and.w	r2, r2, #4
 8001580:	9201      	str	r2, [sp, #4]
 8001582:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8001584:	9402      	str	r4, [sp, #8]
 8001586:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001588:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800158c:	631a      	str	r2, [r3, #48]	; 0x30
 800158e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001590:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8001594:	9202      	str	r2, [sp, #8]
 8001596:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001598:	9403      	str	r4, [sp, #12]
 800159a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800159c:	f042 0201 	orr.w	r2, r2, #1
 80015a0:	631a      	str	r2, [r3, #48]	; 0x30
 80015a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80015a4:	f002 0201 	and.w	r2, r2, #1
 80015a8:	9203      	str	r2, [sp, #12]
 80015aa:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80015ac:	9404      	str	r4, [sp, #16]
 80015ae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80015b0:	f042 0202 	orr.w	r2, r2, #2
 80015b4:	631a      	str	r2, [r3, #48]	; 0x30
 80015b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80015b8:	f003 0302 	and.w	r3, r3, #2
 80015bc:	9304      	str	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(PC13_LED_GPIO_Port, PC13_LED_Pin, GPIO_PIN_RESET);
 80015be:	4622      	mov	r2, r4
 80015c0:	4638      	mov	r0, r7
 80015c2:	f44f 5100 	mov.w	r1, #8192	; 0x2000

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80015c6:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(PC13_LED_GPIO_Port, PC13_LED_Pin, GPIO_PIN_RESET);
 80015c8:	f003 fb10 	bl	8004bec <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_RESET);
 80015cc:	4622      	mov	r2, r4
 80015ce:	4630      	mov	r0, r6
 80015d0:	2140      	movs	r1, #64	; 0x40
 80015d2:	f003 fb0b 	bl	8004bec <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = PC13_LED_Pin;
 80015d6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80015da:	2501      	movs	r5, #1

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = PC13_LED_Pin;
 80015dc:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(PC13_LED_GPIO_Port, &GPIO_InitStruct);
 80015de:	a905      	add	r1, sp, #20
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = PC13_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 80015e0:	2311      	movs	r3, #17
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(PC13_LED_GPIO_Port, &GPIO_InitStruct);
 80015e2:	4638      	mov	r0, r7
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = PC13_LED_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
 80015e4:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80015e6:	9507      	str	r5, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80015e8:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(PC13_LED_GPIO_Port, &GPIO_InitStruct);
 80015ea:	f003 fa3f 	bl	8004a6c <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = SPI1_CS_Pin;
 80015ee:	2340      	movs	r3, #64	; 0x40
 80015f0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  HAL_GPIO_Init(SPI1_CS_GPIO_Port, &GPIO_InitStruct);
 80015f2:	a905      	add	r1, sp, #20

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = SPI1_CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80015f4:	2302      	movs	r3, #2
  HAL_GPIO_Init(SPI1_CS_GPIO_Port, &GPIO_InitStruct);
 80015f6:	4630      	mov	r0, r6
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(PC13_LED_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = SPI1_CS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80015f8:	9506      	str	r5, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80015fa:	9507      	str	r5, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80015fc:	9308      	str	r3, [sp, #32]
  HAL_GPIO_Init(SPI1_CS_GPIO_Port, &GPIO_InitStruct);
 80015fe:	f003 fa35 	bl	8004a6c <HAL_GPIO_Init>

}
 8001602:	b00b      	add	sp, #44	; 0x2c
 8001604:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001606:	bf00      	nop
 8001608:	40023800 	.word	0x40023800
 800160c:	40020800 	.word	0x40020800
 8001610:	40020400 	.word	0x40020400

08001614 <_ZNK8std_msgs4Time9serializeEPh>:
    }

    virtual int serialize(unsigned char *outbuffer) const
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data.sec >> (8 * 0)) & 0xFF;
 8001614:	6843      	ldr	r3, [r0, #4]
 8001616:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->data.sec >> (8 * 1)) & 0xFF;
 8001618:	6843      	ldr	r3, [r0, #4]
 800161a:	0a1b      	lsrs	r3, r3, #8
 800161c:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset + 2) = (this->data.sec >> (8 * 2)) & 0xFF;
 800161e:	88c3      	ldrh	r3, [r0, #6]
 8001620:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset + 3) = (this->data.sec >> (8 * 3)) & 0xFF;
 8001622:	79c3      	ldrb	r3, [r0, #7]
 8001624:	70cb      	strb	r3, [r1, #3]
      offset += sizeof(this->data.sec);
      *(outbuffer + offset + 0) = (this->data.nsec >> (8 * 0)) & 0xFF;
 8001626:	6883      	ldr	r3, [r0, #8]
 8001628:	710b      	strb	r3, [r1, #4]
      *(outbuffer + offset + 1) = (this->data.nsec >> (8 * 1)) & 0xFF;
 800162a:	6883      	ldr	r3, [r0, #8]
 800162c:	0a1b      	lsrs	r3, r3, #8
 800162e:	714b      	strb	r3, [r1, #5]
      *(outbuffer + offset + 2) = (this->data.nsec >> (8 * 2)) & 0xFF;
 8001630:	8943      	ldrh	r3, [r0, #10]
 8001632:	718b      	strb	r3, [r1, #6]
      *(outbuffer + offset + 3) = (this->data.nsec >> (8 * 3)) & 0xFF;
 8001634:	7ac3      	ldrb	r3, [r0, #11]
 8001636:	71cb      	strb	r3, [r1, #7]
      offset += sizeof(this->data.nsec);
      return offset;
    }
 8001638:	2008      	movs	r0, #8
 800163a:	4770      	bx	lr

0800163c <_ZN8std_msgs4Time11deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
    {
      int offset = 0;
      this->data.sec =  ((uint32_t) (*(inbuffer + offset)));
 800163c:	780b      	ldrb	r3, [r1, #0]
 800163e:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
 8001640:	784a      	ldrb	r2, [r1, #1]
 8001642:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001646:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
 8001648:	788a      	ldrb	r2, [r1, #2]
 800164a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800164e:	6043      	str	r3, [r0, #4]
      this->data.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001650:	78ca      	ldrb	r2, [r1, #3]
 8001652:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001656:	6043      	str	r3, [r0, #4]
      offset += sizeof(this->data.sec);
      this->data.nsec =  ((uint32_t) (*(inbuffer + offset)));
 8001658:	790b      	ldrb	r3, [r1, #4]
 800165a:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
 800165c:	794a      	ldrb	r2, [r1, #5]
 800165e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001662:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
 8001664:	798a      	ldrb	r2, [r1, #6]
 8001666:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800166a:	6083      	str	r3, [r0, #8]
      this->data.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 800166c:	79ca      	ldrb	r2, [r1, #7]
 800166e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001672:	6083      	str	r3, [r0, #8]
      offset += sizeof(this->data.nsec);
     return offset;
    }
 8001674:	2008      	movs	r0, #8
 8001676:	4770      	bx	lr

08001678 <_ZN8std_msgs4Time7getTypeEv>:

    const char * getType(){ return "std_msgs/Time"; };
 8001678:	4800      	ldr	r0, [pc, #0]	; (800167c <_ZN8std_msgs4Time7getTypeEv+0x4>)
 800167a:	4770      	bx	lr
 800167c:	08008e2c 	.word	0x08008e2c

08001680 <_ZN8std_msgs4Time6getMD5Ev>:
    const char * getMD5(){ return "cd7166c74c552c311fbcc2fe5a7bc289"; };
 8001680:	4800      	ldr	r0, [pc, #0]	; (8001684 <_ZN8std_msgs4Time6getMD5Ev+0x4>)
 8001682:	4770      	bx	lr
 8001684:	08008e3a 	.word	0x08008e3a

08001688 <_ZN14rosserial_msgs9TopicInfo7getTypeEv>:
      this->buffer_size = u_buffer_size.real;
      offset += sizeof(this->buffer_size);
     return offset;
    }

    const char * getType(){ return "rosserial_msgs/TopicInfo"; };
 8001688:	4800      	ldr	r0, [pc, #0]	; (800168c <_ZN14rosserial_msgs9TopicInfo7getTypeEv+0x4>)
 800168a:	4770      	bx	lr
 800168c:	08008e5b 	.word	0x08008e5b

08001690 <_ZN14rosserial_msgs9TopicInfo6getMD5Ev>:
    const char * getMD5(){ return "0ad51f88fc44892f8c10684077646005"; };
 8001690:	4800      	ldr	r0, [pc, #0]	; (8001694 <_ZN14rosserial_msgs9TopicInfo6getMD5Ev+0x4>)
 8001692:	4770      	bx	lr
 8001694:	08008e74 	.word	0x08008e74

08001698 <_ZN14rosserial_msgs3Log7getTypeEv>:
      this->msg = (char *)(inbuffer + offset-1);
      offset += length_msg;
     return offset;
    }

    const char * getType(){ return "rosserial_msgs/Log"; };
 8001698:	4800      	ldr	r0, [pc, #0]	; (800169c <_ZN14rosserial_msgs3Log7getTypeEv+0x4>)
 800169a:	4770      	bx	lr
 800169c:	08008e95 	.word	0x08008e95

080016a0 <_ZN14rosserial_msgs3Log6getMD5Ev>:
    const char * getMD5(){ return "11abd731c25933261cd6183bd12d6295"; };
 80016a0:	4800      	ldr	r0, [pc, #0]	; (80016a4 <_ZN14rosserial_msgs3Log6getMD5Ev+0x4>)
 80016a2:	4770      	bx	lr
 80016a4:	08008ea8 	.word	0x08008ea8

080016a8 <_ZN14rosserial_msgs20RequestParamResponse7getTypeEv>:
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
      }
     return offset;
    }

    const char * getType(){ return REQUESTPARAM; };
 80016a8:	4800      	ldr	r0, [pc, #0]	; (80016ac <_ZN14rosserial_msgs20RequestParamResponse7getTypeEv+0x4>)
 80016aa:	4770      	bx	lr
 80016ac:	080089cc 	.word	0x080089cc

080016b0 <_ZN14rosserial_msgs20RequestParamResponse6getMD5Ev>:
    const char * getMD5(){ return "9f0e98bda65981986ddf53afa7a40e49"; };
 80016b0:	4800      	ldr	r0, [pc, #0]	; (80016b4 <_ZN14rosserial_msgs20RequestParamResponse6getMD5Ev+0x4>)
 80016b2:	4770      	bx	lr
 80016b4:	08008ec9 	.word	0x08008ec9

080016b8 <_ZNK8std_msgs4Int89serializeEPh>:
      union {
        int8_t real;
        uint8_t base;
      } u_data;
      u_data.real = this->data;
      *(outbuffer + offset + 0) = (u_data.base >> (8 * 0)) & 0xFF;
 80016b8:	7903      	ldrb	r3, [r0, #4]
 80016ba:	700b      	strb	r3, [r1, #0]
      offset += sizeof(this->data);
      return offset;
    }
 80016bc:	2001      	movs	r0, #1
 80016be:	4770      	bx	lr

080016c0 <_ZN8std_msgs4Int811deserializeEPh>:
        int8_t real;
        uint8_t base;
      } u_data;
      u_data.base = 0;
      u_data.base |= ((uint8_t) (*(inbuffer + offset + 0))) << (8 * 0);
      this->data = u_data.real;
 80016c0:	780b      	ldrb	r3, [r1, #0]
 80016c2:	7103      	strb	r3, [r0, #4]
      offset += sizeof(this->data);
     return offset;
    }
 80016c4:	2001      	movs	r0, #1
 80016c6:	4770      	bx	lr

080016c8 <_ZN8std_msgs4Int87getTypeEv>:

    const char * getType(){ return "std_msgs/Int8"; };
 80016c8:	4800      	ldr	r0, [pc, #0]	; (80016cc <_ZN8std_msgs4Int87getTypeEv+0x4>)
 80016ca:	4770      	bx	lr
 80016cc:	08008eea 	.word	0x08008eea

080016d0 <_ZN8std_msgs4Int86getMD5Ev>:
    const char * getMD5(){ return "27ffa0c9c4b8fb8492252bcad9e5c57b"; };
 80016d0:	4800      	ldr	r0, [pc, #0]	; (80016d4 <_ZN8std_msgs4Int86getMD5Ev+0x4>)
 80016d2:	4770      	bx	lr
 80016d4:	08008ef8 	.word	0x08008ef8

080016d8 <_ZNK13geometry_msgs7Vector39serializeEPh>:
      union {
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
 80016d8:	6882      	ldr	r2, [r0, #8]
 80016da:	68c3      	ldr	r3, [r0, #12]
 80016dc:	700a      	strb	r2, [r1, #0]
      y(0),
      z(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 80016de:	b510      	push	{r4, lr}
        double real;
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
 80016e0:	0a14      	lsrs	r4, r2, #8
 80016e2:	704c      	strb	r4, [r1, #1]
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
 80016e4:	0c14      	lsrs	r4, r2, #16
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
 80016e6:	0e12      	lsrs	r2, r2, #24
 80016e8:	70ca      	strb	r2, [r1, #3]
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
 80016ea:	0a1a      	lsrs	r2, r3, #8
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
 80016ec:	710b      	strb	r3, [r1, #4]
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
 80016ee:	714a      	strb	r2, [r1, #5]
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
 80016f0:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
 80016f2:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_x;
      u_x.real = this->x;
      *(outbuffer + offset + 0) = (u_x.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_x.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_x.base >> (8 * 2)) & 0xFF;
 80016f4:	708c      	strb	r4, [r1, #2]
      *(outbuffer + offset + 3) = (u_x.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_x.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_x.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_x.base >> (8 * 6)) & 0xFF;
 80016f6:	718a      	strb	r2, [r1, #6]
      *(outbuffer + offset + 7) = (u_x.base >> (8 * 7)) & 0xFF;
 80016f8:	71cb      	strb	r3, [r1, #7]
      union {
        double real;
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
 80016fa:	6902      	ldr	r2, [r0, #16]
 80016fc:	6943      	ldr	r3, [r0, #20]
 80016fe:	720a      	strb	r2, [r1, #8]
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
 8001700:	0a14      	lsrs	r4, r2, #8
 8001702:	724c      	strb	r4, [r1, #9]
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
 8001704:	0c14      	lsrs	r4, r2, #16
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
 8001706:	0e12      	lsrs	r2, r2, #24
 8001708:	72ca      	strb	r2, [r1, #11]
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
 800170a:	0a1a      	lsrs	r2, r3, #8
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
 800170c:	730b      	strb	r3, [r1, #12]
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
 800170e:	734a      	strb	r2, [r1, #13]
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
 8001710:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
 8001712:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_y;
      u_y.real = this->y;
      *(outbuffer + offset + 0) = (u_y.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_y.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_y.base >> (8 * 2)) & 0xFF;
 8001714:	728c      	strb	r4, [r1, #10]
      *(outbuffer + offset + 3) = (u_y.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_y.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_y.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_y.base >> (8 * 6)) & 0xFF;
 8001716:	738a      	strb	r2, [r1, #14]
      *(outbuffer + offset + 7) = (u_y.base >> (8 * 7)) & 0xFF;
 8001718:	73cb      	strb	r3, [r1, #15]
      union {
        double real;
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
 800171a:	6982      	ldr	r2, [r0, #24]
 800171c:	69c3      	ldr	r3, [r0, #28]
 800171e:	740a      	strb	r2, [r1, #16]
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
 8001720:	0a10      	lsrs	r0, r2, #8
 8001722:	7448      	strb	r0, [r1, #17]
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
 8001724:	0c10      	lsrs	r0, r2, #16
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
 8001726:	0e12      	lsrs	r2, r2, #24
 8001728:	74ca      	strb	r2, [r1, #19]
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
 800172a:	0a1a      	lsrs	r2, r3, #8
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
 800172c:	750b      	strb	r3, [r1, #20]
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
 800172e:	754a      	strb	r2, [r1, #21]
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
 8001730:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
 8001732:	0e1b      	lsrs	r3, r3, #24
        uint64_t base;
      } u_z;
      u_z.real = this->z;
      *(outbuffer + offset + 0) = (u_z.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_z.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_z.base >> (8 * 2)) & 0xFF;
 8001734:	7488      	strb	r0, [r1, #18]
      *(outbuffer + offset + 3) = (u_z.base >> (8 * 3)) & 0xFF;
      *(outbuffer + offset + 4) = (u_z.base >> (8 * 4)) & 0xFF;
      *(outbuffer + offset + 5) = (u_z.base >> (8 * 5)) & 0xFF;
      *(outbuffer + offset + 6) = (u_z.base >> (8 * 6)) & 0xFF;
 8001736:	758a      	strb	r2, [r1, #22]
      *(outbuffer + offset + 7) = (u_z.base >> (8 * 7)) & 0xFF;
 8001738:	75cb      	strb	r3, [r1, #23]
      offset += sizeof(this->z);
      return offset;
    }
 800173a:	2018      	movs	r0, #24
 800173c:	bd10      	pop	{r4, pc}

0800173e <_ZN13geometry_msgs7Vector311deserializeEPh>:
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_x.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
 800173e:	680a      	ldr	r2, [r1, #0]
 8001740:	684b      	ldr	r3, [r1, #4]
      this->x = u_x.real;
 8001742:	e9c0 2302 	strd	r2, r3, [r0, #8]
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_y.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
 8001746:	688a      	ldr	r2, [r1, #8]
 8001748:	68cb      	ldr	r3, [r1, #12]
      this->y = u_y.real;
 800174a:	e9c0 2304 	strd	r2, r3, [r0, #16]
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 3))) << (8 * 3);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 4))) << (8 * 4);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 5))) << (8 * 5);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 6))) << (8 * 6);
      u_z.base |= ((uint64_t) (*(inbuffer + offset + 7))) << (8 * 7);
 800174e:	690a      	ldr	r2, [r1, #16]
 8001750:	694b      	ldr	r3, [r1, #20]
      this->z = u_z.real;
 8001752:	e9c0 2306 	strd	r2, r3, [r0, #24]
      offset += sizeof(this->z);
     return offset;
    }
 8001756:	2018      	movs	r0, #24
 8001758:	4770      	bx	lr
	...

0800175c <_ZN13geometry_msgs7Vector37getTypeEv>:

    const char * getType(){ return "geometry_msgs/Vector3"; };
 800175c:	4800      	ldr	r0, [pc, #0]	; (8001760 <_ZN13geometry_msgs7Vector37getTypeEv+0x4>)
 800175e:	4770      	bx	lr
 8001760:	08008f19 	.word	0x08008f19

08001764 <_ZN13geometry_msgs7Vector36getMD5Ev>:
    const char * getMD5(){ return "4a842b65f413084dc2b10fb484ea7f17"; };
 8001764:	4800      	ldr	r0, [pc, #0]	; (8001768 <_ZN13geometry_msgs7Vector36getMD5Ev+0x4>)
 8001766:	4770      	bx	lr
 8001768:	08008f2f 	.word	0x08008f2f

0800176c <_ZNK13geometry_msgs5Twist9serializeEPh>:
      linear(),
      angular()
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 800176c:	b570      	push	{r4, r5, r6, lr}
 800176e:	4605      	mov	r5, r0
    {
      int offset = 0;
      offset += this->linear.serialize(outbuffer + offset);
 8001770:	3008      	adds	r0, #8
      linear(),
      angular()
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001772:	460e      	mov	r6, r1
    {
      int offset = 0;
      offset += this->linear.serialize(outbuffer + offset);
 8001774:	f7ff ffb0 	bl	80016d8 <_ZNK13geometry_msgs7Vector39serializeEPh>
 8001778:	4604      	mov	r4, r0
      offset += this->angular.serialize(outbuffer + offset);
 800177a:	1831      	adds	r1, r6, r0
 800177c:	f105 0028 	add.w	r0, r5, #40	; 0x28
 8001780:	f7ff ffaa 	bl	80016d8 <_ZNK13geometry_msgs7Vector39serializeEPh>
      return offset;
    }
 8001784:	4420      	add	r0, r4
 8001786:	bd70      	pop	{r4, r5, r6, pc}

08001788 <_ZN13geometry_msgs5Twist11deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
 8001788:	b570      	push	{r4, r5, r6, lr}
 800178a:	4605      	mov	r5, r0
    {
      int offset = 0;
      offset += this->linear.deserialize(inbuffer + offset);
 800178c:	3008      	adds	r0, #8
      offset += this->linear.serialize(outbuffer + offset);
      offset += this->angular.serialize(outbuffer + offset);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer)
 800178e:	460e      	mov	r6, r1
    {
      int offset = 0;
      offset += this->linear.deserialize(inbuffer + offset);
 8001790:	f7ff ffd5 	bl	800173e <_ZN13geometry_msgs7Vector311deserializeEPh>
 8001794:	4604      	mov	r4, r0
      offset += this->angular.deserialize(inbuffer + offset);
 8001796:	1831      	adds	r1, r6, r0
 8001798:	f105 0028 	add.w	r0, r5, #40	; 0x28
 800179c:	f7ff ffcf 	bl	800173e <_ZN13geometry_msgs7Vector311deserializeEPh>
     return offset;
    }
 80017a0:	4420      	add	r0, r4
 80017a2:	bd70      	pop	{r4, r5, r6, pc}

080017a4 <_ZN13geometry_msgs5Twist7getTypeEv>:

    const char * getType(){ return "geometry_msgs/Twist"; };
 80017a4:	4800      	ldr	r0, [pc, #0]	; (80017a8 <_ZN13geometry_msgs5Twist7getTypeEv+0x4>)
 80017a6:	4770      	bx	lr
 80017a8:	08008f50 	.word	0x08008f50

080017ac <_ZN13geometry_msgs5Twist6getMD5Ev>:
    const char * getMD5(){ return "9f195f881246fdfa2798d1d3eebca84a"; };
 80017ac:	4800      	ldr	r0, [pc, #0]	; (80017b0 <_ZN13geometry_msgs5Twist6getMD5Ev+0x4>)
 80017ae:	4770      	bx	lr
 80017b0:	08008f64 	.word	0x08008f64

080017b4 <_ZNK17aerial_robot_msgs3Imu9serializeEPh>:
    }

    virtual int serialize(unsigned char *outbuffer) const
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->stamp.sec >> (8 * 0)) & 0xFF;
 80017b4:	6843      	ldr	r3, [r0, #4]
      mag_data(),
      angles()
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 80017b6:	b5f0      	push	{r4, r5, r6, r7, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->stamp.sec >> (8 * 0)) & 0xFF;
 80017b8:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->stamp.sec >> (8 * 1)) & 0xFF;
 80017ba:	6843      	ldr	r3, [r0, #4]
 80017bc:	0a1b      	lsrs	r3, r3, #8
 80017be:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset + 2) = (this->stamp.sec >> (8 * 2)) & 0xFF;
 80017c0:	88c3      	ldrh	r3, [r0, #6]
 80017c2:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset + 3) = (this->stamp.sec >> (8 * 3)) & 0xFF;
 80017c4:	79c3      	ldrb	r3, [r0, #7]
 80017c6:	70cb      	strb	r3, [r1, #3]
      offset += sizeof(this->stamp.sec);
      *(outbuffer + offset + 0) = (this->stamp.nsec >> (8 * 0)) & 0xFF;
 80017c8:	6883      	ldr	r3, [r0, #8]
 80017ca:	710b      	strb	r3, [r1, #4]
      *(outbuffer + offset + 1) = (this->stamp.nsec >> (8 * 1)) & 0xFF;
 80017cc:	6883      	ldr	r3, [r0, #8]
 80017ce:	0a1b      	lsrs	r3, r3, #8
 80017d0:	714b      	strb	r3, [r1, #5]
      *(outbuffer + offset + 2) = (this->stamp.nsec >> (8 * 2)) & 0xFF;
 80017d2:	8943      	ldrh	r3, [r0, #10]
 80017d4:	718b      	strb	r3, [r1, #6]
      *(outbuffer + offset + 3) = (this->stamp.nsec >> (8 * 3)) & 0xFF;
 80017d6:	7ac3      	ldrb	r3, [r0, #11]
 80017d8:	71cb      	strb	r3, [r1, #7]
 80017da:	f100 060c 	add.w	r6, r0, #12
 80017de:	460a      	mov	r2, r1
 80017e0:	f101 040c 	add.w	r4, r1, #12
 80017e4:	460d      	mov	r5, r1
      for( uint8_t i = 0; i < 3; i++){
      union {
        float real;
        uint32_t base;
      } u_acc_datai;
      u_acc_datai.real = this->acc_data[i];
 80017e6:	f856 3b04 	ldr.w	r3, [r6], #4
      *(outbuffer + offset + 0) = (u_acc_datai.base >> (8 * 0)) & 0xFF;
 80017ea:	722b      	strb	r3, [r5, #8]
      *(outbuffer + offset + 1) = (u_acc_datai.base >> (8 * 1)) & 0xFF;
 80017ec:	0a1f      	lsrs	r7, r3, #8
 80017ee:	726f      	strb	r7, [r5, #9]
      *(outbuffer + offset + 2) = (u_acc_datai.base >> (8 * 2)) & 0xFF;
 80017f0:	0c1f      	lsrs	r7, r3, #16
      *(outbuffer + offset + 3) = (u_acc_datai.base >> (8 * 3)) & 0xFF;
 80017f2:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_acc_datai;
      u_acc_datai.real = this->acc_data[i];
      *(outbuffer + offset + 0) = (u_acc_datai.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_acc_datai.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_acc_datai.base >> (8 * 2)) & 0xFF;
 80017f4:	72af      	strb	r7, [r5, #10]
      *(outbuffer + offset + 3) = (u_acc_datai.base >> (8 * 3)) & 0xFF;
 80017f6:	72eb      	strb	r3, [r5, #11]
 80017f8:	3504      	adds	r5, #4
      *(outbuffer + offset + 0) = (this->stamp.nsec >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->stamp.nsec >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (this->stamp.nsec >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (this->stamp.nsec >> (8 * 3)) & 0xFF;
      offset += sizeof(this->stamp.nsec);
      for( uint8_t i = 0; i < 3; i++){
 80017fa:	42a5      	cmp	r5, r4
 80017fc:	d1f3      	bne.n	80017e6 <_ZNK17aerial_robot_msgs3Imu9serializeEPh+0x32>
 80017fe:	f100 0618 	add.w	r6, r0, #24
 8001802:	460d      	mov	r5, r1
      for( uint8_t i = 0; i < 3; i++){
      union {
        float real;
        uint32_t base;
      } u_gyro_datai;
      u_gyro_datai.real = this->gyro_data[i];
 8001804:	f856 3b04 	ldr.w	r3, [r6], #4
      *(outbuffer + offset + 0) = (u_gyro_datai.base >> (8 * 0)) & 0xFF;
 8001808:	752b      	strb	r3, [r5, #20]
      *(outbuffer + offset + 1) = (u_gyro_datai.base >> (8 * 1)) & 0xFF;
 800180a:	0a1f      	lsrs	r7, r3, #8
 800180c:	756f      	strb	r7, [r5, #21]
      *(outbuffer + offset + 2) = (u_gyro_datai.base >> (8 * 2)) & 0xFF;
 800180e:	0c1f      	lsrs	r7, r3, #16
      *(outbuffer + offset + 3) = (u_gyro_datai.base >> (8 * 3)) & 0xFF;
 8001810:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_gyro_datai;
      u_gyro_datai.real = this->gyro_data[i];
      *(outbuffer + offset + 0) = (u_gyro_datai.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_gyro_datai.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_gyro_datai.base >> (8 * 2)) & 0xFF;
 8001812:	75af      	strb	r7, [r5, #22]
      *(outbuffer + offset + 3) = (u_gyro_datai.base >> (8 * 3)) & 0xFF;
 8001814:	75eb      	strb	r3, [r5, #23]
 8001816:	3504      	adds	r5, #4
      *(outbuffer + offset + 1) = (u_acc_datai.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_acc_datai.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_acc_datai.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->acc_data[i]);
      }
      for( uint8_t i = 0; i < 3; i++){
 8001818:	42ac      	cmp	r4, r5
 800181a:	d1f3      	bne.n	8001804 <_ZNK17aerial_robot_msgs3Imu9serializeEPh+0x50>
 800181c:	f100 0524 	add.w	r5, r0, #36	; 0x24
      for( uint8_t i = 0; i < 3; i++){
      union {
        float real;
        uint32_t base;
      } u_mag_datai;
      u_mag_datai.real = this->mag_data[i];
 8001820:	f855 3b04 	ldr.w	r3, [r5], #4
      *(outbuffer + offset + 0) = (u_mag_datai.base >> (8 * 0)) & 0xFF;
 8001824:	f881 3020 	strb.w	r3, [r1, #32]
      *(outbuffer + offset + 1) = (u_mag_datai.base >> (8 * 1)) & 0xFF;
 8001828:	0a1e      	lsrs	r6, r3, #8
 800182a:	f881 6021 	strb.w	r6, [r1, #33]	; 0x21
      *(outbuffer + offset + 2) = (u_mag_datai.base >> (8 * 2)) & 0xFF;
 800182e:	0c1e      	lsrs	r6, r3, #16
      *(outbuffer + offset + 3) = (u_mag_datai.base >> (8 * 3)) & 0xFF;
 8001830:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_mag_datai;
      u_mag_datai.real = this->mag_data[i];
      *(outbuffer + offset + 0) = (u_mag_datai.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_mag_datai.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_mag_datai.base >> (8 * 2)) & 0xFF;
 8001832:	f881 6022 	strb.w	r6, [r1, #34]	; 0x22
      *(outbuffer + offset + 3) = (u_mag_datai.base >> (8 * 3)) & 0xFF;
 8001836:	f881 3023 	strb.w	r3, [r1, #35]	; 0x23
 800183a:	3104      	adds	r1, #4
      *(outbuffer + offset + 1) = (u_gyro_datai.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_gyro_datai.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_gyro_datai.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->gyro_data[i]);
      }
      for( uint8_t i = 0; i < 3; i++){
 800183c:	428c      	cmp	r4, r1
 800183e:	d1ef      	bne.n	8001820 <_ZNK17aerial_robot_msgs3Imu9serializeEPh+0x6c>
 8001840:	3030      	adds	r0, #48	; 0x30
      for( uint8_t i = 0; i < 3; i++){
      union {
        float real;
        uint32_t base;
      } u_anglesi;
      u_anglesi.real = this->angles[i];
 8001842:	f850 3b04 	ldr.w	r3, [r0], #4
      *(outbuffer + offset + 0) = (u_anglesi.base >> (8 * 0)) & 0xFF;
 8001846:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
      *(outbuffer + offset + 1) = (u_anglesi.base >> (8 * 1)) & 0xFF;
 800184a:	0a19      	lsrs	r1, r3, #8
 800184c:	f882 102d 	strb.w	r1, [r2, #45]	; 0x2d
      *(outbuffer + offset + 2) = (u_anglesi.base >> (8 * 2)) & 0xFF;
 8001850:	0c19      	lsrs	r1, r3, #16
      *(outbuffer + offset + 3) = (u_anglesi.base >> (8 * 3)) & 0xFF;
 8001852:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_anglesi;
      u_anglesi.real = this->angles[i];
      *(outbuffer + offset + 0) = (u_anglesi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_anglesi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_anglesi.base >> (8 * 2)) & 0xFF;
 8001854:	f882 102e 	strb.w	r1, [r2, #46]	; 0x2e
      *(outbuffer + offset + 3) = (u_anglesi.base >> (8 * 3)) & 0xFF;
 8001858:	f882 302f 	strb.w	r3, [r2, #47]	; 0x2f
 800185c:	3204      	adds	r2, #4
      *(outbuffer + offset + 1) = (u_mag_datai.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_mag_datai.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_mag_datai.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->mag_data[i]);
      }
      for( uint8_t i = 0; i < 3; i++){
 800185e:	4294      	cmp	r4, r2
 8001860:	d1ef      	bne.n	8001842 <_ZNK17aerial_robot_msgs3Imu9serializeEPh+0x8e>
      *(outbuffer + offset + 2) = (u_anglesi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_anglesi.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->angles[i]);
      }
      return offset;
    }
 8001862:	2038      	movs	r0, #56	; 0x38
 8001864:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001866 <_ZN17aerial_robot_msgs3Imu11deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
 8001866:	b5f0      	push	{r4, r5, r6, r7, lr}
    {
      int offset = 0;
      this->stamp.sec =  ((uint32_t) (*(inbuffer + offset)));
 8001868:	780b      	ldrb	r3, [r1, #0]
 800186a:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
 800186c:	784a      	ldrb	r2, [r1, #1]
 800186e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001872:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
 8001874:	788a      	ldrb	r2, [r1, #2]
 8001876:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800187a:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 800187c:	78ca      	ldrb	r2, [r1, #3]
 800187e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001882:	6043      	str	r3, [r0, #4]
      offset += sizeof(this->stamp.sec);
      this->stamp.nsec =  ((uint32_t) (*(inbuffer + offset)));
 8001884:	790b      	ldrb	r3, [r1, #4]
 8001886:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
 8001888:	794a      	ldrb	r2, [r1, #5]
 800188a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800188e:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
 8001890:	798a      	ldrb	r2, [r1, #6]
 8001892:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001896:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001898:	79ca      	ldrb	r2, [r1, #7]
 800189a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800189e:	6083      	str	r3, [r0, #8]
 80018a0:	f100 060c 	add.w	r6, r0, #12
 80018a4:	460b      	mov	r3, r1
 80018a6:	f100 0718 	add.w	r7, r0, #24
 80018aa:	460a      	mov	r2, r1
      } u_acc_datai;
      u_acc_datai.base = 0;
      u_acc_datai.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_acc_datai.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_acc_datai.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_acc_datai.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 80018ac:	7a94      	ldrb	r4, [r2, #10]
 80018ae:	7a55      	ldrb	r5, [r2, #9]
 80018b0:	0424      	lsls	r4, r4, #16
 80018b2:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
 80018b6:	7a15      	ldrb	r5, [r2, #8]
 80018b8:	432c      	orrs	r4, r5
 80018ba:	7ad5      	ldrb	r5, [r2, #11]
      this->acc_data[i] = u_acc_datai.real;
 80018bc:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 80018c0:	f846 4b04 	str.w	r4, [r6], #4
      this->stamp.nsec =  ((uint32_t) (*(inbuffer + offset)));
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      offset += sizeof(this->stamp.nsec);
      for( uint8_t i = 0; i < 3; i++){
 80018c4:	42be      	cmp	r6, r7
 80018c6:	f102 0204 	add.w	r2, r2, #4
 80018ca:	d1ef      	bne.n	80018ac <_ZN17aerial_robot_msgs3Imu11deserializeEPh+0x46>
 80018cc:	f100 0624 	add.w	r6, r0, #36	; 0x24
 80018d0:	460a      	mov	r2, r1
      } u_gyro_datai;
      u_gyro_datai.base = 0;
      u_gyro_datai.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_gyro_datai.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_gyro_datai.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_gyro_datai.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 80018d2:	7d94      	ldrb	r4, [r2, #22]
 80018d4:	7d55      	ldrb	r5, [r2, #21]
 80018d6:	0424      	lsls	r4, r4, #16
 80018d8:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
 80018dc:	7d15      	ldrb	r5, [r2, #20]
 80018de:	432c      	orrs	r4, r5
 80018e0:	7dd5      	ldrb	r5, [r2, #23]
      this->gyro_data[i] = u_gyro_datai.real;
 80018e2:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
 80018e6:	f847 4b04 	str.w	r4, [r7], #4
      u_acc_datai.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_acc_datai.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->acc_data[i] = u_acc_datai.real;
      offset += sizeof(this->acc_data[i]);
      }
      for( uint8_t i = 0; i < 3; i++){
 80018ea:	42b7      	cmp	r7, r6
 80018ec:	f102 0204 	add.w	r2, r2, #4
 80018f0:	d1ef      	bne.n	80018d2 <_ZN17aerial_robot_msgs3Imu11deserializeEPh+0x6c>
 80018f2:	f100 0430 	add.w	r4, r0, #48	; 0x30
      } u_mag_datai;
      u_mag_datai.base = 0;
      u_mag_datai.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_mag_datai.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_mag_datai.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_mag_datai.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 80018f6:	f891 2022 	ldrb.w	r2, [r1, #34]	; 0x22
 80018fa:	f891 5021 	ldrb.w	r5, [r1, #33]	; 0x21
 80018fe:	0412      	lsls	r2, r2, #16
 8001900:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
 8001904:	f891 5020 	ldrb.w	r5, [r1, #32]
 8001908:	432a      	orrs	r2, r5
 800190a:	f891 5023 	ldrb.w	r5, [r1, #35]	; 0x23
      this->mag_data[i] = u_mag_datai.real;
 800190e:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
 8001912:	f846 2b04 	str.w	r2, [r6], #4
      u_gyro_datai.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_gyro_datai.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->gyro_data[i] = u_gyro_datai.real;
      offset += sizeof(this->gyro_data[i]);
      }
      for( uint8_t i = 0; i < 3; i++){
 8001916:	42a6      	cmp	r6, r4
 8001918:	f101 0104 	add.w	r1, r1, #4
 800191c:	d1eb      	bne.n	80018f6 <_ZN17aerial_robot_msgs3Imu11deserializeEPh+0x90>
 800191e:	303c      	adds	r0, #60	; 0x3c
      } u_anglesi;
      u_anglesi.base = 0;
      u_anglesi.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_anglesi.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_anglesi.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_anglesi.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001920:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
 8001924:	f893 102d 	ldrb.w	r1, [r3, #45]	; 0x2d
 8001928:	0412      	lsls	r2, r2, #16
 800192a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800192e:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8001932:	430a      	orrs	r2, r1
 8001934:	f893 102f 	ldrb.w	r1, [r3, #47]	; 0x2f
      this->angles[i] = u_anglesi.real;
 8001938:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800193c:	f844 2b04 	str.w	r2, [r4], #4
      u_mag_datai.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_mag_datai.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->mag_data[i] = u_mag_datai.real;
      offset += sizeof(this->mag_data[i]);
      }
      for( uint8_t i = 0; i < 3; i++){
 8001940:	42a0      	cmp	r0, r4
 8001942:	f103 0304 	add.w	r3, r3, #4
 8001946:	d1eb      	bne.n	8001920 <_ZN17aerial_robot_msgs3Imu11deserializeEPh+0xba>
      u_anglesi.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->angles[i] = u_anglesi.real;
      offset += sizeof(this->angles[i]);
      }
     return offset;
    }
 8001948:	2038      	movs	r0, #56	; 0x38
 800194a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800194c <_ZN17aerial_robot_msgs3Imu7getTypeEv>:

    const char * getType(){ return "aerial_robot_msgs/Imu"; };
 800194c:	4800      	ldr	r0, [pc, #0]	; (8001950 <_ZN17aerial_robot_msgs3Imu7getTypeEv+0x4>)
 800194e:	4770      	bx	lr
 8001950:	08008f85 	.word	0x08008f85

08001954 <_ZN17aerial_robot_msgs3Imu6getMD5Ev>:
    const char * getMD5(){ return "68b769ca85e5d9c44dbce51dc60e4be7"; };
 8001954:	4800      	ldr	r0, [pc, #0]	; (8001958 <_ZN17aerial_robot_msgs3Imu6getMD5Ev+0x4>)
 8001956:	4770      	bx	lr
 8001958:	08008f9b 	.word	0x08008f9b

0800195c <_ZNK17aerial_robot_base11DesireCoord9serializeEPh>:
      union {
        float real;
        uint32_t base;
      } u_roll;
      u_roll.real = this->roll;
      *(outbuffer + offset + 0) = (u_roll.base >> (8 * 0)) & 0xFF;
 800195c:	6843      	ldr	r3, [r0, #4]
 800195e:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (u_roll.base >> (8 * 1)) & 0xFF;
 8001960:	0a1a      	lsrs	r2, r3, #8
 8001962:	704a      	strb	r2, [r1, #1]
      *(outbuffer + offset + 2) = (u_roll.base >> (8 * 2)) & 0xFF;
 8001964:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_roll.base >> (8 * 3)) & 0xFF;
 8001966:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_roll;
      u_roll.real = this->roll;
      *(outbuffer + offset + 0) = (u_roll.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_roll.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_roll.base >> (8 * 2)) & 0xFF;
 8001968:	708a      	strb	r2, [r1, #2]
      *(outbuffer + offset + 3) = (u_roll.base >> (8 * 3)) & 0xFF;
 800196a:	70cb      	strb	r3, [r1, #3]
      union {
        float real;
        uint32_t base;
      } u_pitch;
      u_pitch.real = this->pitch;
      *(outbuffer + offset + 0) = (u_pitch.base >> (8 * 0)) & 0xFF;
 800196c:	6883      	ldr	r3, [r0, #8]
 800196e:	710b      	strb	r3, [r1, #4]
      *(outbuffer + offset + 1) = (u_pitch.base >> (8 * 1)) & 0xFF;
 8001970:	0a1a      	lsrs	r2, r3, #8
 8001972:	714a      	strb	r2, [r1, #5]
      *(outbuffer + offset + 2) = (u_pitch.base >> (8 * 2)) & 0xFF;
 8001974:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_pitch.base >> (8 * 3)) & 0xFF;
 8001976:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_pitch;
      u_pitch.real = this->pitch;
      *(outbuffer + offset + 0) = (u_pitch.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_pitch.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_pitch.base >> (8 * 2)) & 0xFF;
 8001978:	718a      	strb	r2, [r1, #6]
      *(outbuffer + offset + 3) = (u_pitch.base >> (8 * 3)) & 0xFF;
 800197a:	71cb      	strb	r3, [r1, #7]
      union {
        float real;
        uint32_t base;
      } u_yaw;
      u_yaw.real = this->yaw;
      *(outbuffer + offset + 0) = (u_yaw.base >> (8 * 0)) & 0xFF;
 800197c:	68c3      	ldr	r3, [r0, #12]
 800197e:	720b      	strb	r3, [r1, #8]
      *(outbuffer + offset + 1) = (u_yaw.base >> (8 * 1)) & 0xFF;
 8001980:	0a1a      	lsrs	r2, r3, #8
 8001982:	724a      	strb	r2, [r1, #9]
      *(outbuffer + offset + 2) = (u_yaw.base >> (8 * 2)) & 0xFF;
 8001984:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_yaw.base >> (8 * 3)) & 0xFF;
 8001986:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_yaw;
      u_yaw.real = this->yaw;
      *(outbuffer + offset + 0) = (u_yaw.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_yaw.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_yaw.base >> (8 * 2)) & 0xFF;
 8001988:	728a      	strb	r2, [r1, #10]
      *(outbuffer + offset + 3) = (u_yaw.base >> (8 * 3)) & 0xFF;
 800198a:	72cb      	strb	r3, [r1, #11]
      offset += sizeof(this->yaw);
      *(outbuffer + offset + 0) = (this->coord_type >> (8 * 0)) & 0xFF;
 800198c:	7c03      	ldrb	r3, [r0, #16]
 800198e:	730b      	strb	r3, [r1, #12]
      offset += sizeof(this->coord_type);
      return offset;
    }
 8001990:	200d      	movs	r0, #13
 8001992:	4770      	bx	lr

08001994 <_ZN17aerial_robot_base11DesireCoord11deserializeEPh>:
      u_roll.base = 0;
      u_roll.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_roll.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_roll.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_roll.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->roll = u_roll.real;
 8001994:	680b      	ldr	r3, [r1, #0]
 8001996:	6043      	str	r3, [r0, #4]
      u_pitch.base = 0;
      u_pitch.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_pitch.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_pitch.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_pitch.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->pitch = u_pitch.real;
 8001998:	684b      	ldr	r3, [r1, #4]
 800199a:	6083      	str	r3, [r0, #8]
      u_yaw.base = 0;
      u_yaw.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_yaw.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_yaw.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_yaw.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->yaw = u_yaw.real;
 800199c:	688b      	ldr	r3, [r1, #8]
 800199e:	60c3      	str	r3, [r0, #12]
      offset += sizeof(this->yaw);
      this->coord_type =  ((uint8_t) (*(inbuffer + offset)));
 80019a0:	7b0b      	ldrb	r3, [r1, #12]
 80019a2:	7403      	strb	r3, [r0, #16]
      offset += sizeof(this->coord_type);
     return offset;
    }
 80019a4:	200d      	movs	r0, #13
 80019a6:	4770      	bx	lr

080019a8 <_ZN17aerial_robot_base11DesireCoord7getTypeEv>:

    const char * getType(){ return "aerial_robot_base/DesireCoord"; };
 80019a8:	4800      	ldr	r0, [pc, #0]	; (80019ac <_ZN17aerial_robot_base11DesireCoord7getTypeEv+0x4>)
 80019aa:	4770      	bx	lr
 80019ac:	08008fbc 	.word	0x08008fbc

080019b0 <_ZN17aerial_robot_base11DesireCoord6getMD5Ev>:
    const char * getMD5(){ return "6ccf1a68453182818d4a1d0d5013bd0d"; };
 80019b0:	4800      	ldr	r0, [pc, #0]	; (80019b4 <_ZN17aerial_robot_base11DesireCoord6getMD5Ev+0x4>)
 80019b2:	4770      	bx	lr
 80019b4:	08008fda 	.word	0x08008fda

080019b8 <_ZNK17aerial_robot_msgs9Barometer9serializeEPh>:
    }

    virtual int serialize(unsigned char *outbuffer) const
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->stamp.sec >> (8 * 0)) & 0xFF;
 80019b8:	6843      	ldr	r3, [r0, #4]
 80019ba:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->stamp.sec >> (8 * 1)) & 0xFF;
 80019bc:	6843      	ldr	r3, [r0, #4]
 80019be:	0a1b      	lsrs	r3, r3, #8
 80019c0:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset + 2) = (this->stamp.sec >> (8 * 2)) & 0xFF;
 80019c2:	88c3      	ldrh	r3, [r0, #6]
 80019c4:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset + 3) = (this->stamp.sec >> (8 * 3)) & 0xFF;
 80019c6:	79c3      	ldrb	r3, [r0, #7]
 80019c8:	70cb      	strb	r3, [r1, #3]
      offset += sizeof(this->stamp.sec);
      *(outbuffer + offset + 0) = (this->stamp.nsec >> (8 * 0)) & 0xFF;
 80019ca:	6883      	ldr	r3, [r0, #8]
 80019cc:	710b      	strb	r3, [r1, #4]
      *(outbuffer + offset + 1) = (this->stamp.nsec >> (8 * 1)) & 0xFF;
 80019ce:	6883      	ldr	r3, [r0, #8]
 80019d0:	0a1b      	lsrs	r3, r3, #8
 80019d2:	714b      	strb	r3, [r1, #5]
      *(outbuffer + offset + 2) = (this->stamp.nsec >> (8 * 2)) & 0xFF;
 80019d4:	8943      	ldrh	r3, [r0, #10]
 80019d6:	718b      	strb	r3, [r1, #6]
      *(outbuffer + offset + 3) = (this->stamp.nsec >> (8 * 3)) & 0xFF;
 80019d8:	7ac3      	ldrb	r3, [r0, #11]
 80019da:	71cb      	strb	r3, [r1, #7]
      union {
        float real;
        uint32_t base;
      } u_altitude;
      u_altitude.real = this->altitude;
      *(outbuffer + offset + 0) = (u_altitude.base >> (8 * 0)) & 0xFF;
 80019dc:	68c3      	ldr	r3, [r0, #12]
 80019de:	720b      	strb	r3, [r1, #8]
      *(outbuffer + offset + 1) = (u_altitude.base >> (8 * 1)) & 0xFF;
 80019e0:	0a1a      	lsrs	r2, r3, #8
 80019e2:	724a      	strb	r2, [r1, #9]
      *(outbuffer + offset + 2) = (u_altitude.base >> (8 * 2)) & 0xFF;
 80019e4:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_altitude.base >> (8 * 3)) & 0xFF;
 80019e6:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_altitude;
      u_altitude.real = this->altitude;
      *(outbuffer + offset + 0) = (u_altitude.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_altitude.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_altitude.base >> (8 * 2)) & 0xFF;
 80019e8:	728a      	strb	r2, [r1, #10]
      *(outbuffer + offset + 3) = (u_altitude.base >> (8 * 3)) & 0xFF;
 80019ea:	72cb      	strb	r3, [r1, #11]
      union {
        float real;
        uint32_t base;
      } u_pressure;
      u_pressure.real = this->pressure;
      *(outbuffer + offset + 0) = (u_pressure.base >> (8 * 0)) & 0xFF;
 80019ec:	6903      	ldr	r3, [r0, #16]
 80019ee:	730b      	strb	r3, [r1, #12]
      *(outbuffer + offset + 1) = (u_pressure.base >> (8 * 1)) & 0xFF;
 80019f0:	0a1a      	lsrs	r2, r3, #8
 80019f2:	734a      	strb	r2, [r1, #13]
      *(outbuffer + offset + 2) = (u_pressure.base >> (8 * 2)) & 0xFF;
 80019f4:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_pressure.base >> (8 * 3)) & 0xFF;
 80019f6:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_pressure;
      u_pressure.real = this->pressure;
      *(outbuffer + offset + 0) = (u_pressure.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_pressure.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_pressure.base >> (8 * 2)) & 0xFF;
 80019f8:	738a      	strb	r2, [r1, #14]
      *(outbuffer + offset + 3) = (u_pressure.base >> (8 * 3)) & 0xFF;
 80019fa:	73cb      	strb	r3, [r1, #15]
      union {
        float real;
        uint32_t base;
      } u_temperature;
      u_temperature.real = this->temperature;
      *(outbuffer + offset + 0) = (u_temperature.base >> (8 * 0)) & 0xFF;
 80019fc:	6943      	ldr	r3, [r0, #20]
 80019fe:	740b      	strb	r3, [r1, #16]
      *(outbuffer + offset + 1) = (u_temperature.base >> (8 * 1)) & 0xFF;
 8001a00:	0a1a      	lsrs	r2, r3, #8
 8001a02:	744a      	strb	r2, [r1, #17]
      *(outbuffer + offset + 2) = (u_temperature.base >> (8 * 2)) & 0xFF;
 8001a04:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_temperature.base >> (8 * 3)) & 0xFF;
 8001a06:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_temperature;
      u_temperature.real = this->temperature;
      *(outbuffer + offset + 0) = (u_temperature.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_temperature.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_temperature.base >> (8 * 2)) & 0xFF;
 8001a08:	748a      	strb	r2, [r1, #18]
      *(outbuffer + offset + 3) = (u_temperature.base >> (8 * 3)) & 0xFF;
 8001a0a:	74cb      	strb	r3, [r1, #19]
      offset += sizeof(this->temperature);
      return offset;
    }
 8001a0c:	2014      	movs	r0, #20
 8001a0e:	4770      	bx	lr

08001a10 <_ZN17aerial_robot_msgs9Barometer11deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
    {
      int offset = 0;
      this->stamp.sec =  ((uint32_t) (*(inbuffer + offset)));
 8001a10:	780b      	ldrb	r3, [r1, #0]
 8001a12:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
 8001a14:	784a      	ldrb	r2, [r1, #1]
 8001a16:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001a1a:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
 8001a1c:	788a      	ldrb	r2, [r1, #2]
 8001a1e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001a22:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001a24:	78ca      	ldrb	r2, [r1, #3]
 8001a26:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001a2a:	6043      	str	r3, [r0, #4]
      offset += sizeof(this->stamp.sec);
      this->stamp.nsec =  ((uint32_t) (*(inbuffer + offset)));
 8001a2c:	790b      	ldrb	r3, [r1, #4]
 8001a2e:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
 8001a30:	794a      	ldrb	r2, [r1, #5]
 8001a32:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001a36:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
 8001a38:	798a      	ldrb	r2, [r1, #6]
 8001a3a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001a3e:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001a40:	79ca      	ldrb	r2, [r1, #7]
 8001a42:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001a46:	6083      	str	r3, [r0, #8]
      u_altitude.base = 0;
      u_altitude.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_altitude.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_altitude.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_altitude.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->altitude = u_altitude.real;
 8001a48:	688b      	ldr	r3, [r1, #8]
 8001a4a:	60c3      	str	r3, [r0, #12]
      u_pressure.base = 0;
      u_pressure.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_pressure.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_pressure.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_pressure.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->pressure = u_pressure.real;
 8001a4c:	68cb      	ldr	r3, [r1, #12]
 8001a4e:	6103      	str	r3, [r0, #16]
      u_temperature.base = 0;
      u_temperature.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_temperature.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_temperature.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_temperature.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->temperature = u_temperature.real;
 8001a50:	690b      	ldr	r3, [r1, #16]
 8001a52:	6143      	str	r3, [r0, #20]
      offset += sizeof(this->temperature);
     return offset;
    }
 8001a54:	2014      	movs	r0, #20
 8001a56:	4770      	bx	lr

08001a58 <_ZN17aerial_robot_msgs9Barometer7getTypeEv>:

    const char * getType(){ return "aerial_robot_msgs/Barometer"; };
 8001a58:	4800      	ldr	r0, [pc, #0]	; (8001a5c <_ZN17aerial_robot_msgs9Barometer7getTypeEv+0x4>)
 8001a5a:	4770      	bx	lr
 8001a5c:	08008ffb 	.word	0x08008ffb

08001a60 <_ZN17aerial_robot_msgs9Barometer6getMD5Ev>:
    const char * getMD5(){ return "b732c389660333d48fe976feb5768402"; };
 8001a60:	4800      	ldr	r0, [pc, #0]	; (8001a64 <_ZN17aerial_robot_msgs9Barometer6getMD5Ev+0x4>)
 8001a62:	4770      	bx	lr
 8001a64:	08009017 	.word	0x08009017

08001a68 <_ZNK17aerial_robot_msgs3Gps9serializeEPh>:
    }

    virtual int serialize(unsigned char *outbuffer) const
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->stamp.sec >> (8 * 0)) & 0xFF;
 8001a68:	6843      	ldr	r3, [r0, #4]
 8001a6a:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->stamp.sec >> (8 * 1)) & 0xFF;
 8001a6c:	6843      	ldr	r3, [r0, #4]
 8001a6e:	0a1b      	lsrs	r3, r3, #8
 8001a70:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset + 2) = (this->stamp.sec >> (8 * 2)) & 0xFF;
 8001a72:	88c3      	ldrh	r3, [r0, #6]
 8001a74:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset + 3) = (this->stamp.sec >> (8 * 3)) & 0xFF;
 8001a76:	79c3      	ldrb	r3, [r0, #7]
 8001a78:	70cb      	strb	r3, [r1, #3]
      offset += sizeof(this->stamp.sec);
      *(outbuffer + offset + 0) = (this->stamp.nsec >> (8 * 0)) & 0xFF;
 8001a7a:	6883      	ldr	r3, [r0, #8]
 8001a7c:	710b      	strb	r3, [r1, #4]
      *(outbuffer + offset + 1) = (this->stamp.nsec >> (8 * 1)) & 0xFF;
 8001a7e:	6883      	ldr	r3, [r0, #8]
 8001a80:	0a1b      	lsrs	r3, r3, #8
 8001a82:	714b      	strb	r3, [r1, #5]
      *(outbuffer + offset + 2) = (this->stamp.nsec >> (8 * 2)) & 0xFF;
 8001a84:	8943      	ldrh	r3, [r0, #10]
 8001a86:	718b      	strb	r3, [r1, #6]
      *(outbuffer + offset + 3) = (this->stamp.nsec >> (8 * 3)) & 0xFF;
 8001a88:	7ac3      	ldrb	r3, [r0, #11]
 8001a8a:	71cb      	strb	r3, [r1, #7]
      union {
        float real;
        uint32_t base;
      } u_locationi;
      u_locationi.real = this->location[i];
      *(outbuffer + offset + 0) = (u_locationi.base >> (8 * 0)) & 0xFF;
 8001a8c:	68c3      	ldr	r3, [r0, #12]
 8001a8e:	720b      	strb	r3, [r1, #8]
      *(outbuffer + offset + 1) = (u_locationi.base >> (8 * 1)) & 0xFF;
 8001a90:	0a1a      	lsrs	r2, r3, #8
 8001a92:	724a      	strb	r2, [r1, #9]
      *(outbuffer + offset + 2) = (u_locationi.base >> (8 * 2)) & 0xFF;
 8001a94:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_locationi.base >> (8 * 3)) & 0xFF;
 8001a96:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_locationi;
      u_locationi.real = this->location[i];
      *(outbuffer + offset + 0) = (u_locationi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_locationi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_locationi.base >> (8 * 2)) & 0xFF;
 8001a98:	728a      	strb	r2, [r1, #10]
      *(outbuffer + offset + 3) = (u_locationi.base >> (8 * 3)) & 0xFF;
 8001a9a:	72cb      	strb	r3, [r1, #11]
      union {
        float real;
        uint32_t base;
      } u_locationi;
      u_locationi.real = this->location[i];
      *(outbuffer + offset + 0) = (u_locationi.base >> (8 * 0)) & 0xFF;
 8001a9c:	6903      	ldr	r3, [r0, #16]
 8001a9e:	730b      	strb	r3, [r1, #12]
      *(outbuffer + offset + 1) = (u_locationi.base >> (8 * 1)) & 0xFF;
 8001aa0:	0a1a      	lsrs	r2, r3, #8
 8001aa2:	734a      	strb	r2, [r1, #13]
      *(outbuffer + offset + 2) = (u_locationi.base >> (8 * 2)) & 0xFF;
 8001aa4:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_locationi.base >> (8 * 3)) & 0xFF;
 8001aa6:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_locationi;
      u_locationi.real = this->location[i];
      *(outbuffer + offset + 0) = (u_locationi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_locationi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_locationi.base >> (8 * 2)) & 0xFF;
 8001aa8:	738a      	strb	r2, [r1, #14]
      *(outbuffer + offset + 3) = (u_locationi.base >> (8 * 3)) & 0xFF;
 8001aaa:	73cb      	strb	r3, [r1, #15]
      union {
        float real;
        uint32_t base;
      } u_velocityi;
      u_velocityi.real = this->velocity[i];
      *(outbuffer + offset + 0) = (u_velocityi.base >> (8 * 0)) & 0xFF;
 8001aac:	6943      	ldr	r3, [r0, #20]
 8001aae:	740b      	strb	r3, [r1, #16]
      *(outbuffer + offset + 1) = (u_velocityi.base >> (8 * 1)) & 0xFF;
 8001ab0:	0a1a      	lsrs	r2, r3, #8
 8001ab2:	744a      	strb	r2, [r1, #17]
      *(outbuffer + offset + 2) = (u_velocityi.base >> (8 * 2)) & 0xFF;
 8001ab4:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_velocityi.base >> (8 * 3)) & 0xFF;
 8001ab6:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_velocityi;
      u_velocityi.real = this->velocity[i];
      *(outbuffer + offset + 0) = (u_velocityi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_velocityi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_velocityi.base >> (8 * 2)) & 0xFF;
 8001ab8:	748a      	strb	r2, [r1, #18]
      *(outbuffer + offset + 3) = (u_velocityi.base >> (8 * 3)) & 0xFF;
 8001aba:	74cb      	strb	r3, [r1, #19]
      union {
        float real;
        uint32_t base;
      } u_velocityi;
      u_velocityi.real = this->velocity[i];
      *(outbuffer + offset + 0) = (u_velocityi.base >> (8 * 0)) & 0xFF;
 8001abc:	6983      	ldr	r3, [r0, #24]
 8001abe:	750b      	strb	r3, [r1, #20]
      *(outbuffer + offset + 1) = (u_velocityi.base >> (8 * 1)) & 0xFF;
 8001ac0:	0a1a      	lsrs	r2, r3, #8
 8001ac2:	754a      	strb	r2, [r1, #21]
      *(outbuffer + offset + 2) = (u_velocityi.base >> (8 * 2)) & 0xFF;
 8001ac4:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_velocityi.base >> (8 * 3)) & 0xFF;
 8001ac6:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_velocityi;
      u_velocityi.real = this->velocity[i];
      *(outbuffer + offset + 0) = (u_velocityi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_velocityi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_velocityi.base >> (8 * 2)) & 0xFF;
 8001ac8:	758a      	strb	r2, [r1, #22]
      *(outbuffer + offset + 3) = (u_velocityi.base >> (8 * 3)) & 0xFF;
 8001aca:	75cb      	strb	r3, [r1, #23]
      offset += sizeof(this->velocity[i]);
      }
      *(outbuffer + offset + 0) = (this->sat_num >> (8 * 0)) & 0xFF;
 8001acc:	7f03      	ldrb	r3, [r0, #28]
 8001ace:	760b      	strb	r3, [r1, #24]
      offset += sizeof(this->sat_num);
      return offset;
    }
 8001ad0:	2019      	movs	r0, #25
 8001ad2:	4770      	bx	lr

08001ad4 <_ZN17aerial_robot_msgs3Gps11deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
    {
      int offset = 0;
      this->stamp.sec =  ((uint32_t) (*(inbuffer + offset)));
 8001ad4:	780b      	ldrb	r3, [r1, #0]
 8001ad6:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
 8001ad8:	784a      	ldrb	r2, [r1, #1]
 8001ada:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001ade:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
 8001ae0:	788a      	ldrb	r2, [r1, #2]
 8001ae2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001ae6:	6043      	str	r3, [r0, #4]
      this->stamp.sec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001ae8:	78ca      	ldrb	r2, [r1, #3]
 8001aea:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001aee:	6043      	str	r3, [r0, #4]
      offset += sizeof(this->stamp.sec);
      this->stamp.nsec =  ((uint32_t) (*(inbuffer + offset)));
 8001af0:	790b      	ldrb	r3, [r1, #4]
 8001af2:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
 8001af4:	794a      	ldrb	r2, [r1, #5]
 8001af6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001afa:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
 8001afc:	798a      	ldrb	r2, [r1, #6]
 8001afe:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8001b02:	6083      	str	r3, [r0, #8]
      this->stamp.nsec |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001b04:	79ca      	ldrb	r2, [r1, #7]
 8001b06:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001b0a:	6083      	str	r3, [r0, #8]
      u_locationi.base = 0;
      u_locationi.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_locationi.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_locationi.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_locationi.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->location[i] = u_locationi.real;
 8001b0c:	688b      	ldr	r3, [r1, #8]
 8001b0e:	60c3      	str	r3, [r0, #12]
 8001b10:	68cb      	ldr	r3, [r1, #12]
 8001b12:	6103      	str	r3, [r0, #16]
      } u_velocityi;
      u_velocityi.base = 0;
      u_velocityi.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_velocityi.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_velocityi.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_velocityi.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001b14:	7c8b      	ldrb	r3, [r1, #18]
 8001b16:	7c4a      	ldrb	r2, [r1, #17]
 8001b18:	041b      	lsls	r3, r3, #16
 8001b1a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001b1e:	7c0a      	ldrb	r2, [r1, #16]
 8001b20:	4313      	orrs	r3, r2
 8001b22:	7cca      	ldrb	r2, [r1, #19]
      this->velocity[i] = u_velocityi.real;
 8001b24:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001b28:	6143      	str	r3, [r0, #20]
      } u_velocityi;
      u_velocityi.base = 0;
      u_velocityi.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_velocityi.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_velocityi.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_velocityi.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8001b2a:	7d8b      	ldrb	r3, [r1, #22]
 8001b2c:	7d4a      	ldrb	r2, [r1, #21]
 8001b2e:	041b      	lsls	r3, r3, #16
 8001b30:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001b34:	7d0a      	ldrb	r2, [r1, #20]
 8001b36:	4313      	orrs	r3, r2
 8001b38:	7dca      	ldrb	r2, [r1, #23]
      this->velocity[i] = u_velocityi.real;
 8001b3a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001b3e:	6183      	str	r3, [r0, #24]
      offset += sizeof(this->velocity[i]);
      }
      this->sat_num =  ((uint8_t) (*(inbuffer + offset)));
 8001b40:	7e0b      	ldrb	r3, [r1, #24]
 8001b42:	7703      	strb	r3, [r0, #28]
      offset += sizeof(this->sat_num);
     return offset;
    }
 8001b44:	2019      	movs	r0, #25
 8001b46:	4770      	bx	lr

08001b48 <_ZN17aerial_robot_msgs3Gps7getTypeEv>:

    const char * getType(){ return "aerial_robot_msgs/Gps"; };
 8001b48:	4800      	ldr	r0, [pc, #0]	; (8001b4c <_ZN17aerial_robot_msgs3Gps7getTypeEv+0x4>)
 8001b4a:	4770      	bx	lr
 8001b4c:	08009038 	.word	0x08009038

08001b50 <_ZN17aerial_robot_msgs3Gps6getMD5Ev>:
    const char * getMD5(){ return "b9b55701ff5240f76ada29af2827853c"; };
 8001b50:	4800      	ldr	r0, [pc, #0]	; (8001b54 <_ZN17aerial_robot_msgs3Gps6getMD5Ev+0x4>)
 8001b52:	4770      	bx	lr
 8001b54:	0800904e 	.word	0x0800904e

08001b58 <_ZN13StateEstimateD1Ev>:
{
public:
  StateEstimate()
  {
  }
  ~StateEstimate(){}
 8001b58:	4770      	bx	lr

08001b5a <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE9connectedEv>:


    /* Are we connected to the PC? */
    virtual bool connected() {
      return configured_;
    };
 8001b5a:	f890 02d0 	ldrb.w	r0, [r0, #720]	; 0x2d0
 8001b5e:	4770      	bx	lr

08001b60 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef>:

  static void TransmitCplt(DMA_HandleTypeDef *hdma)
  {
    Hardware* huart = ( Hardware* )(hdma)->Parent;
    /* DMA Normal mode*/
    if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8001b60:	6803      	ldr	r3, [r0, #0]
  ~TxBuffer(){}


  static void TransmitCplt(DMA_HandleTypeDef *hdma)
  {
    Hardware* huart = ( Hardware* )(hdma)->Parent;
 8001b62:	6b81      	ldr	r1, [r0, #56]	; 0x38
    /* DMA Normal mode*/
    if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8001b64:	681b      	ldr	r3, [r3, #0]
 8001b66:	f413 7280 	ands.w	r2, r3, #256	; 0x100
  }

  ~TxBuffer(){}


  static void TransmitCplt(DMA_HandleTypeDef *hdma)
 8001b6a:	b530      	push	{r4, r5, lr}
 8001b6c:	680b      	ldr	r3, [r1, #0]
  {
    Hardware* huart = ( Hardware* )(hdma)->Parent;
    /* DMA Normal mode*/
    if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8001b6e:	d109      	bne.n	8001b84 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x24>
      {
        huart->TxXferCount = 0;
 8001b70:	84ca      	strh	r2, [r1, #38]	; 0x26

        /* Disable the DMA transfer for transmit request by setting the DMAT bit
           in the UART CR3 register */
        huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAT);
 8001b72:	695a      	ldr	r2, [r3, #20]
 8001b74:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001b78:	615a      	str	r2, [r3, #20]
 /* Enable the UART Transmit Complete Interrupt */
    __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8001b7a:	68da      	ldr	r2, [r3, #12]
 8001b7c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001b80:	60da      	str	r2, [r3, #12]
 8001b82:	bd30      	pop	{r4, r5, pc}
      }
    /* DMA Circular mode */
    else
      {
        /* Disable the peripheral */
        huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
 8001b84:	695a      	ldr	r2, [r3, #20]
 8001b86:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 8001b88:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001b8c:	615a      	str	r2, [r3, #20]

        if(!idle_flag_)
 8001b8e:	4a43      	ldr	r2, [pc, #268]	; (8001c9c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x13c>)
 8001b90:	7810      	ldrb	r0, [r2, #0]
 8001b92:	4614      	mov	r4, r2
 8001b94:	bb20      	cbnz	r0, 8001be0 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x80>
          {
            subscript_in_progress_++;
 8001b96:	4a42      	ldr	r2, [pc, #264]	; (8001ca0 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x140>)
 8001b98:	7811      	ldrb	r1, [r2, #0]
 8001b9a:	3101      	adds	r1, #1
 8001b9c:	b2c9      	uxtb	r1, r1

            if (subscript_in_progress_ == TX_SIZE)
 8001b9e:	2932      	cmp	r1, #50	; 0x32
        /* Disable the peripheral */
        huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);

        if(!idle_flag_)
          {
            subscript_in_progress_++;
 8001ba0:	bf14      	ite	ne
 8001ba2:	7011      	strbne	r1, [r2, #0]

            if (subscript_in_progress_ == TX_SIZE)
                subscript_in_progress_ = 0;
 8001ba4:	7010      	strbeq	r0, [r2, #0]

            if (subscript_in_progress_ != subscript_to_add_)
 8001ba6:	7810      	ldrb	r0, [r2, #0]
 8001ba8:	4a3e      	ldr	r2, [pc, #248]	; (8001ca4 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x144>)
 8001baa:	7812      	ldrb	r2, [r2, #0]
 8001bac:	4282      	cmp	r2, r0
 8001bae:	d015      	beq.n	8001bdc <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x7c>
              {
                __HAL_DMA_DISABLE(huart->hdmatx);
 8001bb0:	682a      	ldr	r2, [r5, #0]
 8001bb2:	6811      	ldr	r1, [r2, #0]
 8001bb4:	f021 0101 	bic.w	r1, r1, #1
 8001bb8:	6011      	str	r1, [r2, #0]
                uint8_t* tmp8 = tx_buffer_unit_[subscript_in_progress_].tx_data_;
                uint32_t * tmp32 = (uint32_t*)&tmp8;
                huart->hdmatx->Instance->NDTR = (uint32_t)tx_buffer_unit_[subscript_in_progress_].tx_len_;
 8001bba:	493b      	ldr	r1, [pc, #236]	; (8001ca8 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x148>)
 8001bbc:	24fb      	movs	r4, #251	; 0xfb
 8001bbe:	fb04 1100 	mla	r1, r4, r0, r1
 8001bc2:	f891 00fa 	ldrb.w	r0, [r1, #250]	; 0xfa
 8001bc6:	6050      	str	r0, [r2, #4]

                huart->hdmatx->Instance->M0AR = *(uint32_t*)tmp32;
 8001bc8:	60d1      	str	r1, [r2, #12]
                /* Enable USARTy DMA TX Channel */
                huart->Instance->CR3 |= USART_CR3_DMAT; //enable dma request in hsuart side
 8001bca:	6959      	ldr	r1, [r3, #20]
 8001bcc:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8001bd0:	6159      	str	r1, [r3, #20]
                __HAL_DMA_ENABLE(huart->hdmatx);
 8001bd2:	6813      	ldr	r3, [r2, #0]
 8001bd4:	f043 0301 	orr.w	r3, r3, #1
 8001bd8:	6013      	str	r3, [r2, #0]
 8001bda:	e001      	b.n	8001be0 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x80>
              }	
            else
              {
                idle_flag_ = true;
 8001bdc:	2301      	movs	r3, #1
 8001bde:	7023      	strb	r3, [r4, #0]
              }

          }
        __HAL_DMA_CLEAR_FLAG(huart->hdmatx, __HAL_DMA_GET_TC_FLAG_INDEX(huart->hdmatx));
 8001be0:	682b      	ldr	r3, [r5, #0]
 8001be2:	4a32      	ldr	r2, [pc, #200]	; (8001cac <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x14c>)
 8001be4:	4293      	cmp	r3, r2
 8001be6:	d913      	bls.n	8001c10 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xb0>
 8001be8:	3218      	adds	r2, #24
 8001bea:	4293      	cmp	r3, r2
 8001bec:	d00a      	beq.n	8001c04 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xa4>
 8001bee:	3218      	adds	r2, #24
 8001bf0:	4293      	cmp	r3, r2
 8001bf2:	d009      	beq.n	8001c08 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xa8>
 8001bf4:	3218      	adds	r2, #24
 8001bf6:	4293      	cmp	r3, r2
 8001bf8:	bf0c      	ite	eq
 8001bfa:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001bfe:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001c02:	e003      	b.n	8001c0c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xac>
 8001c04:	2320      	movs	r3, #32
 8001c06:	e001      	b.n	8001c0c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xac>
 8001c08:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001c0c:	4a28      	ldr	r2, [pc, #160]	; (8001cb0 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x150>)
 8001c0e:	e02d      	b.n	8001c6c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x10c>
 8001c10:	4a28      	ldr	r2, [pc, #160]	; (8001cb4 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x154>)
 8001c12:	4293      	cmp	r3, r2
 8001c14:	d914      	bls.n	8001c40 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xe0>
 8001c16:	f502 7256 	add.w	r2, r2, #856	; 0x358
 8001c1a:	4293      	cmp	r3, r2
 8001c1c:	d00a      	beq.n	8001c34 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xd4>
 8001c1e:	3218      	adds	r2, #24
 8001c20:	4293      	cmp	r3, r2
 8001c22:	d009      	beq.n	8001c38 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xd8>
 8001c24:	3218      	adds	r2, #24
 8001c26:	4293      	cmp	r3, r2
 8001c28:	bf0c      	ite	eq
 8001c2a:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001c2e:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001c32:	e003      	b.n	8001c3c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xdc>
 8001c34:	2320      	movs	r3, #32
 8001c36:	e001      	b.n	8001c3c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0xdc>
 8001c38:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001c3c:	4a1c      	ldr	r2, [pc, #112]	; (8001cb0 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x150>)
 8001c3e:	e02a      	b.n	8001c96 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x136>
 8001c40:	4a1d      	ldr	r2, [pc, #116]	; (8001cb8 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x158>)
 8001c42:	4293      	cmp	r3, r2
 8001c44:	d914      	bls.n	8001c70 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x110>
 8001c46:	3218      	adds	r2, #24
 8001c48:	4293      	cmp	r3, r2
 8001c4a:	d00a      	beq.n	8001c62 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x102>
 8001c4c:	3218      	adds	r2, #24
 8001c4e:	4293      	cmp	r3, r2
 8001c50:	d009      	beq.n	8001c66 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x106>
 8001c52:	3218      	adds	r2, #24
 8001c54:	4293      	cmp	r3, r2
 8001c56:	bf0c      	ite	eq
 8001c58:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001c5c:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001c60:	e003      	b.n	8001c6a <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x10a>
 8001c62:	2320      	movs	r3, #32
 8001c64:	e001      	b.n	8001c6a <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x10a>
 8001c66:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001c6a:	4a14      	ldr	r2, [pc, #80]	; (8001cbc <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x15c>)
 8001c6c:	60d3      	str	r3, [r2, #12]
 8001c6e:	bd30      	pop	{r4, r5, pc}
 8001c70:	4a13      	ldr	r2, [pc, #76]	; (8001cc0 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x160>)
 8001c72:	4293      	cmp	r3, r2
 8001c74:	d00a      	beq.n	8001c8c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x12c>
 8001c76:	3218      	adds	r2, #24
 8001c78:	4293      	cmp	r3, r2
 8001c7a:	d009      	beq.n	8001c90 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x130>
 8001c7c:	3218      	adds	r2, #24
 8001c7e:	4293      	cmp	r3, r2
 8001c80:	bf0c      	ite	eq
 8001c82:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001c86:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8001c8a:	e003      	b.n	8001c94 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x134>
 8001c8c:	2320      	movs	r3, #32
 8001c8e:	e001      	b.n	8001c94 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x134>
 8001c90:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001c94:	4a09      	ldr	r2, [pc, #36]	; (8001cbc <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE12TransmitCpltEP19__DMA_HandleTypeDef+0x15c>)
 8001c96:	6093      	str	r3, [r2, #8]
 8001c98:	bd30      	pop	{r4, r5, pc}
 8001c9a:	bf00      	nop
 8001c9c:	20000a68 	.word	0x20000a68
 8001ca0:	20000a6a 	.word	0x20000a6a
 8001ca4:	20000a69 	.word	0x20000a69
 8001ca8:	20000a6b 	.word	0x20000a6b
 8001cac:	40026458 	.word	0x40026458
 8001cb0:	40026400 	.word	0x40026400
 8001cb4:	400260b8 	.word	0x400260b8
 8001cb8:	40026058 	.word	0x40026058
 8001cbc:	40026000 	.word	0x40026000
 8001cc0:	40026010 	.word	0x40026010

08001cc4 <_ZN8RxBufferI18UART_HandleTypeDefLi400ELi8EE11ReceiveCpltEP19__DMA_HandleTypeDef>:
  static void ReceiveCplt(DMA_HandleTypeDef *hdma)
  {
    Hardware* huart = ( Hardware* )(hdma)->Parent;

    /* DMA Normal mode */
    if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8001cc4:	6803      	ldr	r3, [r0, #0]
 8001cc6:	681b      	ldr	r3, [r3, #0]
 8001cc8:	f413 7280 	ands.w	r2, r3, #256	; 0x100
  bool available() { return ring_buf_->length(); }

  inline uint8_t& rxValue() { return rx_value_; }
  inline RingBuffer<uint8_t, RX_SIZE>* ringBuffer() { return ring_buf_; }

  static void ReceiveCplt(DMA_HandleTypeDef *hdma)
 8001ccc:	b530      	push	{r4, r5, lr}
  {
    Hardware* huart = ( Hardware* )(hdma)->Parent;

    /* DMA Normal mode */
    if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
 8001cce:	d10e      	bne.n	8001cee <_ZN8RxBufferI18UART_HandleTypeDefLi400ELi8EE11ReceiveCpltEP19__DMA_HandleTypeDef+0x2a>
  inline uint8_t& rxValue() { return rx_value_; }
  inline RingBuffer<uint8_t, RX_SIZE>* ringBuffer() { return ring_buf_; }

  static void ReceiveCplt(DMA_HandleTypeDef *hdma)
  {
    Hardware* huart = ( Hardware* )(hdma)->Parent;
 8001cd0:	6b83      	ldr	r3, [r0, #56]	; 0x38
      {
        huart->RxXferCount = 0;

        /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
           in the UART CR3 register */
        huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
 8001cd2:	6819      	ldr	r1, [r3, #0]
    Hardware* huart = ( Hardware* )(hdma)->Parent;

    /* DMA Normal mode */
    if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
      {
        huart->RxXferCount = 0;
 8001cd4:	85da      	strh	r2, [r3, #46]	; 0x2e

        /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
           in the UART CR3 register */
        huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
 8001cd6:	694a      	ldr	r2, [r1, #20]
 8001cd8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001cdc:	614a      	str	r2, [r1, #20]

        /* Check if a transmit Process is ongoing or not */
        if(huart->gState == HAL_UART_STATE_BUSY_TX_RX)
 8001cde:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
 8001ce2:	2a23      	cmp	r2, #35	; 0x23
          huart->gState = HAL_UART_STATE_BUSY_TX;
 8001ce4:	bf0c      	ite	eq
 8001ce6:	2221      	moveq	r2, #33	; 0x21
        else
          huart->gState = HAL_UART_STATE_READY;
 8001ce8:	2220      	movne	r2, #32
 8001cea:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
      }
    //sepecial process
for(int i = 0; i < RX_BURST_SIZE; i++)
    ring_buf_->push(rx_value_[i]);
 8001cee:	4b0a      	ldr	r3, [pc, #40]	; (8001d18 <_ZN8RxBufferI18UART_HandleTypeDefLi400ELi8EE11ReceiveCpltEP19__DMA_HandleTypeDef+0x54>)
 8001cf0:	4d0a      	ldr	r5, [pc, #40]	; (8001d1c <_ZN8RxBufferI18UART_HandleTypeDefLi400ELi8EE11ReceiveCpltEP19__DMA_HandleTypeDef+0x58>)
 8001cf2:	681a      	ldr	r2, [r3, #0]
 8001cf4:	f9b2 3192 	ldrsh.w	r3, [r2, #402]	; 0x192

    buf_[byte_to_add_] = new_value;

    byte_to_add_++;

    if (byte_to_add_ == buffer_length_)
 8001cf8:	f8b2 0194 	ldrh.w	r0, [r2, #404]	; 0x194
 8001cfc:	2100      	movs	r1, #0
    // the process node should have higher priority than the rx it callback
#if 0
    if ((byte_in_progress_ == (byte_to_add_ + 1)) || ( (byte_to_add_ == (buffer_length_ - 1) )&& (byte_in_progress_ == 0)) ) return false;
#endif

    buf_[byte_to_add_] = new_value;
 8001cfe:	5d4c      	ldrb	r4, [r1, r5]
 8001d00:	54d4      	strb	r4, [r2, r3]

    byte_to_add_++;
 8001d02:	3301      	adds	r3, #1
 8001d04:	b21b      	sxth	r3, r3
          huart->gState = HAL_UART_STATE_BUSY_TX;
        else
          huart->gState = HAL_UART_STATE_READY;
      }
    //sepecial process
for(int i = 0; i < RX_BURST_SIZE; i++)
 8001d06:	3101      	adds	r1, #1

    byte_to_add_++;

    if (byte_to_add_ == buffer_length_)
      {
        byte_to_add_ = 0;
 8001d08:	4283      	cmp	r3, r0
 8001d0a:	bf08      	it	eq
 8001d0c:	2300      	moveq	r3, #0
          huart->gState = HAL_UART_STATE_BUSY_TX;
        else
          huart->gState = HAL_UART_STATE_READY;
      }
    //sepecial process
for(int i = 0; i < RX_BURST_SIZE; i++)
 8001d0e:	2908      	cmp	r1, #8
 8001d10:	d1f5      	bne.n	8001cfe <_ZN8RxBufferI18UART_HandleTypeDefLi400ELi8EE11ReceiveCpltEP19__DMA_HandleTypeDef+0x3a>
 8001d12:	f8a2 3192 	strh.w	r3, [r2, #402]	; 0x192
 8001d16:	bd30      	pop	{r4, r5, pc}
 8001d18:	20003b7c 	.word	0x20003b7c
 8001d1c:	20003b71 	.word	0x20003b71

08001d20 <_ZN3ros11Subscriber2IN17aerial_robot_base11DesireCoordE16AttitudeEstimateE15getEndpointTypeEv>:
        this->fun_obj_(obj_, msg);
      }

      virtual const char * getMsgType(){ return this->msg.getType(); }
      virtual const char * getMsgMD5(){ return this->msg.getMD5(); }
      virtual int getEndpointType(){ return endpoint_; }
 8001d20:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8001d22:	4770      	bx	lr

08001d24 <_ZN3ros11Subscriber2IN17aerial_robot_base11DesireCoordE16AttitudeEstimateE10getMsgTypeEv>:
      virtual void callback(unsigned char* data){
        msg.deserialize(data);
        this->fun_obj_(obj_, msg);
      }

      virtual const char * getMsgType(){ return this->msg.getType(); }
 8001d24:	4800      	ldr	r0, [pc, #0]	; (8001d28 <_ZN3ros11Subscriber2IN17aerial_robot_base11DesireCoordE16AttitudeEstimateE10getMsgTypeEv+0x4>)
 8001d26:	4770      	bx	lr
 8001d28:	08008fbc 	.word	0x08008fbc

08001d2c <_ZN3ros11Subscriber2IN17aerial_robot_base11DesireCoordE16AttitudeEstimateE9getMsgMD5Ev>:
      virtual const char * getMsgMD5(){ return this->msg.getMD5(); }
 8001d2c:	4800      	ldr	r0, [pc, #0]	; (8001d30 <_ZN3ros11Subscriber2IN17aerial_robot_base11DesireCoordE16AttitudeEstimateE9getMsgMD5Ev+0x4>)
 8001d2e:	4770      	bx	lr
 8001d30:	08008fda 	.word	0x08008fda

08001d34 <_ZN3ros11Subscriber2IN17aerial_robot_base11DesireCoordE16AttitudeEstimateE8callbackEPh>:
      {
        //std::binder1st t  = std::bind1st(std::mem_fun1_t())
        topic_ = topic_name;
      };

      virtual void callback(unsigned char* data){
 8001d34:	b570      	push	{r4, r5, r6, lr}
 8001d36:	4604      	mov	r4, r0
        msg.deserialize(data);
 8001d38:	f100 050c 	add.w	r5, r0, #12
 8001d3c:	4628      	mov	r0, r5
 8001d3e:	f7ff fe29 	bl	8001994 <_ZN17aerial_robot_base11DesireCoord11deserializeEPh>
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
 8001d42:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        this->fun_obj_(obj_, msg);
 8001d44:	6a20      	ldr	r0, [r4, #32]
 8001d46:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001d48:	f012 0f01 	tst.w	r2, #1
 8001d4c:	ea4f 0262 	mov.w	r2, r2, asr #1
 8001d50:	bf18      	it	ne
 8001d52:	5881      	ldrne	r1, [r0, r2]
 8001d54:	4410      	add	r0, r2
 8001d56:	bf18      	it	ne
 8001d58:	58cb      	ldrne	r3, [r1, r3]
 8001d5a:	4629      	mov	r1, r5
      }
 8001d5c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8001d60:	4718      	bx	r3

08001d62 <_ZNK14rosserial_msgs20RequestParamResponse9serializeEPh>:
      floats_length(0), floats(NULL),
      strings_length(0), strings(NULL)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001d62:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    {
      int offset = 0;
      *(outbuffer + offset++) = ints_length;
 8001d66:	7903      	ldrb	r3, [r0, #4]
 8001d68:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset++) = 0;
 8001d6a:	2300      	movs	r3, #0
      floats_length(0), floats(NULL),
      strings_length(0), strings(NULL)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001d6c:	460c      	mov	r4, r1
    {
      int offset = 0;
      *(outbuffer + offset++) = ints_length;
      *(outbuffer + offset++) = 0;
 8001d6e:	704b      	strb	r3, [r1, #1]
      *(outbuffer + offset++) = 0;
 8001d70:	708b      	strb	r3, [r1, #2]
      *(outbuffer + offset++) = 0;
 8001d72:	70cb      	strb	r3, [r1, #3]
      floats_length(0), floats(NULL),
      strings_length(0), strings(NULL)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001d74:	4607      	mov	r7, r0
 8001d76:	3104      	adds	r1, #4
    {
      int offset = 0;
      *(outbuffer + offset++) = ints_length;
      *(outbuffer + offset++) = 0;
      *(outbuffer + offset++) = 0;
      *(outbuffer + offset++) = 0;
 8001d78:	461a      	mov	r2, r3
      for( uint8_t i = 0; i < ints_length; i++){
 8001d7a:	793d      	ldrb	r5, [r7, #4]
 8001d7c:	1c50      	adds	r0, r2, #1
 8001d7e:	b2d2      	uxtb	r2, r2
 8001d80:	4295      	cmp	r5, r2
 8001d82:	eba1 0304 	sub.w	r3, r1, r4
 8001d86:	f101 0104 	add.w	r1, r1, #4
 8001d8a:	d90f      	bls.n	8001dac <_ZNK14rosserial_msgs20RequestParamResponse9serializeEPh+0x4a>
      union {
        int32_t real;
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
 8001d8c:	68fb      	ldr	r3, [r7, #12]
 8001d8e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
 8001d92:	f801 3c04 	strb.w	r3, [r1, #-4]
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
 8001d96:	0a1a      	lsrs	r2, r3, #8
 8001d98:	f801 2c03 	strb.w	r2, [r1, #-3]
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
 8001d9c:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
 8001d9e:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_intsi;
      u_intsi.real = this->ints[i];
      *(outbuffer + offset + 0) = (u_intsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
 8001da0:	f801 2c02 	strb.w	r2, [r1, #-2]
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
 8001da4:	f801 3c01 	strb.w	r3, [r1, #-1]
      int offset = 0;
      *(outbuffer + offset++) = ints_length;
      *(outbuffer + offset++) = 0;
      *(outbuffer + offset++) = 0;
      *(outbuffer + offset++) = 0;
      for( uint8_t i = 0; i < ints_length; i++){
 8001da8:	4602      	mov	r2, r0
 8001daa:	e7e6      	b.n	8001d7a <_ZNK14rosserial_msgs20RequestParamResponse9serializeEPh+0x18>
      *(outbuffer + offset + 1) = (u_intsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_intsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_intsi.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->ints[i]);
      }
      *(outbuffer + offset++) = floats_length;
 8001dac:	7c3a      	ldrb	r2, [r7, #16]
 8001dae:	54e2      	strb	r2, [r4, r3]
      *(outbuffer + offset++) = 0;
 8001db0:	18e1      	adds	r1, r4, r3
 8001db2:	2200      	movs	r2, #0
 8001db4:	3304      	adds	r3, #4
 8001db6:	704a      	strb	r2, [r1, #1]
      *(outbuffer + offset++) = 0;
 8001db8:	708a      	strb	r2, [r1, #2]
      *(outbuffer + offset++) = 0;
 8001dba:	70ca      	strb	r2, [r1, #3]
 8001dbc:	4423      	add	r3, r4
      for( uint8_t i = 0; i < floats_length; i++){
 8001dbe:	7c38      	ldrb	r0, [r7, #16]
 8001dc0:	1c51      	adds	r1, r2, #1
 8001dc2:	b2d2      	uxtb	r2, r2
 8001dc4:	4290      	cmp	r0, r2
 8001dc6:	eba3 0604 	sub.w	r6, r3, r4
 8001dca:	f103 0304 	add.w	r3, r3, #4
 8001dce:	d90f      	bls.n	8001df0 <_ZNK14rosserial_msgs20RequestParamResponse9serializeEPh+0x8e>
      union {
        float real;
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
 8001dd0:	69b8      	ldr	r0, [r7, #24]
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
 8001dd2:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8001dd6:	f803 2c04 	strb.w	r2, [r3, #-4]
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
 8001dda:	0a10      	lsrs	r0, r2, #8
 8001ddc:	f803 0c03 	strb.w	r0, [r3, #-3]
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
 8001de0:	0c10      	lsrs	r0, r2, #16
      *(outbuffer + offset + 3) = (u_floatsi.base >> (8 * 3)) & 0xFF;
 8001de2:	0e12      	lsrs	r2, r2, #24
 8001de4:	f803 2c01 	strb.w	r2, [r3, #-1]
        uint32_t base;
      } u_floatsi;
      u_floatsi.real = this->floats[i];
      *(outbuffer + offset + 0) = (u_floatsi.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
 8001de8:	f803 0c02 	strb.w	r0, [r3, #-2]
      }
      *(outbuffer + offset++) = floats_length;
      *(outbuffer + offset++) = 0;
      *(outbuffer + offset++) = 0;
      *(outbuffer + offset++) = 0;
      for( uint8_t i = 0; i < floats_length; i++){
 8001dec:	460a      	mov	r2, r1
 8001dee:	e7e6      	b.n	8001dbe <_ZNK14rosserial_msgs20RequestParamResponse9serializeEPh+0x5c>
      *(outbuffer + offset + 1) = (u_floatsi.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_floatsi.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_floatsi.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->floats[i]);
      }
      *(outbuffer + offset++) = strings_length;
 8001df0:	7f3b      	ldrb	r3, [r7, #28]
 8001df2:	55a3      	strb	r3, [r4, r6]
      *(outbuffer + offset++) = 0;
 8001df4:	19a2      	adds	r2, r4, r6
 8001df6:	2300      	movs	r3, #0
 8001df8:	7053      	strb	r3, [r2, #1]
      *(outbuffer + offset++) = 0;
 8001dfa:	7093      	strb	r3, [r2, #2]
      *(outbuffer + offset++) = 0;
 8001dfc:	3604      	adds	r6, #4
 8001dfe:	70d3      	strb	r3, [r2, #3]
      for( uint8_t i = 0; i < strings_length; i++){
 8001e00:	7f3a      	ldrb	r2, [r7, #28]
 8001e02:	b2dd      	uxtb	r5, r3
 8001e04:	42aa      	cmp	r2, r5
 8001e06:	f103 0901 	add.w	r9, r3, #1
 8001e0a:	d915      	bls.n	8001e38 <_ZNK14rosserial_msgs20RequestParamResponse9serializeEPh+0xd6>
      uint32_t length_stringsi = strlen(this->strings[i]);
 8001e0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001e0e:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8001e12:	f7fe fa03 	bl	800021c <strlen>
 8001e16:	ab02      	add	r3, sp, #8
 8001e18:	4680      	mov	r8, r0
 8001e1a:	f843 0d04 	str.w	r0, [r3, #-4]!
      memcpy(outbuffer + offset, &length_stringsi, sizeof(uint32_t));
 8001e1e:	6818      	ldr	r0, [r3, #0]
 8001e20:	51a0      	str	r0, [r4, r6]
      offset += 4;
      memcpy(outbuffer + offset, this->strings[i], length_stringsi);
 8001e22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001e24:	3604      	adds	r6, #4
 8001e26:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
 8001e2a:	19a0      	adds	r0, r4, r6
 8001e2c:	4642      	mov	r2, r8
 8001e2e:	f006 f9fb 	bl	8008228 <memcpy>
      offset += length_stringsi;
 8001e32:	4446      	add	r6, r8
      }
      *(outbuffer + offset++) = strings_length;
      *(outbuffer + offset++) = 0;
      *(outbuffer + offset++) = 0;
      *(outbuffer + offset++) = 0;
      for( uint8_t i = 0; i < strings_length; i++){
 8001e34:	464b      	mov	r3, r9
 8001e36:	e7e3      	b.n	8001e00 <_ZNK14rosserial_msgs20RequestParamResponse9serializeEPh+0x9e>
      offset += 4;
      memcpy(outbuffer + offset, this->strings[i], length_stringsi);
      offset += length_stringsi;
      }
      return offset;
    }
 8001e38:	4630      	mov	r0, r6
 8001e3a:	b003      	add	sp, #12
 8001e3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08001e40 <_ZNK14rosserial_msgs3Log9serializeEPh>:
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001e40:	b573      	push	{r0, r1, r4, r5, r6, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
 8001e42:	7903      	ldrb	r3, [r0, #4]
 8001e44:	700b      	strb	r3, [r1, #0]
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001e46:	4606      	mov	r6, r0
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
 8001e48:	6880      	ldr	r0, [r0, #8]
      level(0),
      msg("")
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001e4a:	460d      	mov	r5, r1
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->level >> (8 * 0)) & 0xFF;
      offset += sizeof(this->level);
      uint32_t length_msg = strlen(this->msg);
 8001e4c:	f7fe f9e6 	bl	800021c <strlen>
 8001e50:	ab02      	add	r3, sp, #8
 8001e52:	4604      	mov	r4, r0
 8001e54:	f843 0d04 	str.w	r0, [r3, #-4]!
      memcpy(outbuffer + offset, &length_msg, sizeof(uint32_t));
 8001e58:	6818      	ldr	r0, [r3, #0]
 8001e5a:	f8c5 0001 	str.w	r0, [r5, #1]
      offset += 4;
      memcpy(outbuffer + offset, this->msg, length_msg);
 8001e5e:	4622      	mov	r2, r4
 8001e60:	68b1      	ldr	r1, [r6, #8]
 8001e62:	1d68      	adds	r0, r5, #5
 8001e64:	f006 f9e0 	bl	8008228 <memcpy>
      offset += length_msg;
      return offset;
    }
 8001e68:	1d60      	adds	r0, r4, #5
 8001e6a:	b002      	add	sp, #8
 8001e6c:	bd70      	pop	{r4, r5, r6, pc}

08001e6e <_ZNK14rosserial_msgs9TopicInfo9serializeEPh>:
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001e6e:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
 8001e72:	8883      	ldrh	r3, [r0, #4]
 8001e74:	700b      	strb	r3, [r1, #0]
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
 8001e76:	8883      	ldrh	r3, [r0, #4]
 8001e78:	0a1b      	lsrs	r3, r3, #8
 8001e7a:	704b      	strb	r3, [r1, #1]
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001e7c:	4606      	mov	r6, r0
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
 8001e7e:	6880      	ldr	r0, [r0, #8]
      md5sum(""),
      buffer_size(0)
    {
    }

    virtual int serialize(unsigned char *outbuffer) const
 8001e80:	460d      	mov	r5, r1
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->topic_id >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (this->topic_id >> (8 * 1)) & 0xFF;
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
 8001e82:	f7fe f9cb 	bl	800021c <strlen>
 8001e86:	ab04      	add	r3, sp, #16
 8001e88:	4604      	mov	r4, r0
 8001e8a:	f843 0d0c 	str.w	r0, [r3, #-12]!
      memcpy(outbuffer + offset, &length_topic_name, sizeof(uint32_t));
 8001e8e:	6818      	ldr	r0, [r3, #0]
 8001e90:	f8c5 0002 	str.w	r0, [r5, #2]
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
 8001e94:	4622      	mov	r2, r4
 8001e96:	68b1      	ldr	r1, [r6, #8]
 8001e98:	1da8      	adds	r0, r5, #6
 8001e9a:	f006 f9c5 	bl	8008228 <memcpy>
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
 8001e9e:	68f0      	ldr	r0, [r6, #12]
 8001ea0:	f7fe f9bc 	bl	800021c <strlen>
 8001ea4:	ab04      	add	r3, sp, #16
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name = strlen(this->topic_name);
      memcpy(outbuffer + offset, &length_topic_name, sizeof(uint32_t));
      offset += 4;
      memcpy(outbuffer + offset, this->topic_name, length_topic_name);
      offset += length_topic_name;
 8001ea6:	f104 0806 	add.w	r8, r4, #6
      uint32_t length_message_type = strlen(this->message_type);
 8001eaa:	f843 0d08 	str.w	r0, [r3, #-8]!
 8001eae:	4607      	mov	r7, r0
      memcpy(outbuffer + offset, &length_message_type, sizeof(uint32_t));
 8001eb0:	6818      	ldr	r0, [r3, #0]
 8001eb2:	f845 0008 	str.w	r0, [r5, r8]
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
 8001eb6:	340a      	adds	r4, #10
 8001eb8:	463a      	mov	r2, r7
 8001eba:	68f1      	ldr	r1, [r6, #12]
 8001ebc:	1928      	adds	r0, r5, r4
 8001ebe:	f006 f9b3 	bl	8008228 <memcpy>
      offset += length_message_type;
      uint32_t length_md5sum = strlen(this->md5sum);
 8001ec2:	6930      	ldr	r0, [r6, #16]
 8001ec4:	f7fe f9aa 	bl	800021c <strlen>
 8001ec8:	ab04      	add	r3, sp, #16
      offset += length_topic_name;
      uint32_t length_message_type = strlen(this->message_type);
      memcpy(outbuffer + offset, &length_message_type, sizeof(uint32_t));
      offset += 4;
      memcpy(outbuffer + offset, this->message_type, length_message_type);
      offset += length_message_type;
 8001eca:	443c      	add	r4, r7
      uint32_t length_md5sum = strlen(this->md5sum);
 8001ecc:	f843 0d04 	str.w	r0, [r3, #-4]!
 8001ed0:	4607      	mov	r7, r0
      memcpy(outbuffer + offset, &length_md5sum, sizeof(uint32_t));
 8001ed2:	6818      	ldr	r0, [r3, #0]
 8001ed4:	5128      	str	r0, [r5, r4]
      offset += 4;
      memcpy(outbuffer + offset, this->md5sum, length_md5sum);
 8001ed6:	3404      	adds	r4, #4
 8001ed8:	463a      	mov	r2, r7
 8001eda:	1928      	adds	r0, r5, r4
 8001edc:	6931      	ldr	r1, [r6, #16]
 8001ede:	f006 f9a3 	bl	8008228 <memcpy>
      offset += length_md5sum;
 8001ee2:	1938      	adds	r0, r7, r4
      union {
        int32_t real;
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
 8001ee4:	6973      	ldr	r3, [r6, #20]
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
 8001ee6:	542b      	strb	r3, [r5, r0]
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
 8001ee8:	4405      	add	r5, r0
 8001eea:	0a1a      	lsrs	r2, r3, #8
 8001eec:	706a      	strb	r2, [r5, #1]
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
      return offset;
    }
 8001eee:	3004      	adds	r0, #4
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
 8001ef0:	0c1a      	lsrs	r2, r3, #16
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
 8001ef2:	0e1b      	lsrs	r3, r3, #24
        uint32_t base;
      } u_buffer_size;
      u_buffer_size.real = this->buffer_size;
      *(outbuffer + offset + 0) = (u_buffer_size.base >> (8 * 0)) & 0xFF;
      *(outbuffer + offset + 1) = (u_buffer_size.base >> (8 * 1)) & 0xFF;
      *(outbuffer + offset + 2) = (u_buffer_size.base >> (8 * 2)) & 0xFF;
 8001ef4:	70aa      	strb	r2, [r5, #2]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
 8001ef6:	70eb      	strb	r3, [r5, #3]
      offset += sizeof(this->buffer_size);
      return offset;
    }
 8001ef8:	b004      	add	sp, #16
 8001efa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001efe <_ZN14rosserial_msgs3Log11deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
 8001efe:	b537      	push	{r0, r1, r2, r4, r5, lr}
    {
      int offset = 0;
      this->level =  ((uint8_t) (*(inbuffer + offset)));
 8001f00:	460b      	mov	r3, r1
      memcpy(outbuffer + offset, this->msg, length_msg);
      offset += length_msg;
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer)
 8001f02:	4604      	mov	r4, r0
    {
      int offset = 0;
      this->level =  ((uint8_t) (*(inbuffer + offset)));
 8001f04:	f813 2b01 	ldrb.w	r2, [r3], #1
 8001f08:	7102      	strb	r2, [r0, #4]
      offset += sizeof(this->level);
      uint32_t length_msg;
      memcpy(&length_msg, (inbuffer + offset), sizeof(uint32_t));
 8001f0a:	6818      	ldr	r0, [r3, #0]
 8001f0c:	9001      	str	r0, [sp, #4]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_msg; ++k){
 8001f0e:	9b01      	ldr	r3, [sp, #4]
 8001f10:	1d4a      	adds	r2, r1, #5
 8001f12:	1d58      	adds	r0, r3, #5
 8001f14:	1a55      	subs	r5, r2, r1
 8001f16:	42a8      	cmp	r0, r5
 8001f18:	d904      	bls.n	8001f24 <_ZN14rosserial_msgs3Log11deserializeEPh+0x26>
          inbuffer[k-1]=inbuffer[k];
 8001f1a:	f812 5b01 	ldrb.w	r5, [r2], #1
 8001f1e:	f802 5c02 	strb.w	r5, [r2, #-2]
      this->level =  ((uint8_t) (*(inbuffer + offset)));
      offset += sizeof(this->level);
      uint32_t length_msg;
      memcpy(&length_msg, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_msg; ++k){
 8001f22:	e7f7      	b.n	8001f14 <_ZN14rosserial_msgs3Log11deserializeEPh+0x16>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_msg-1]=0;
 8001f24:	440b      	add	r3, r1
 8001f26:	2200      	movs	r2, #0
      this->msg = (char *)(inbuffer + offset-1);
 8001f28:	3104      	adds	r1, #4
      memcpy(&length_msg, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_msg; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_msg-1]=0;
 8001f2a:	711a      	strb	r2, [r3, #4]
      this->msg = (char *)(inbuffer + offset-1);
 8001f2c:	60a1      	str	r1, [r4, #8]
      offset += length_msg;
     return offset;
    }
 8001f2e:	b003      	add	sp, #12
 8001f30:	bd30      	pop	{r4, r5, pc}

08001f32 <_ZN14rosserial_msgs9TopicInfo11deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
 8001f32:	b530      	push	{r4, r5, lr}
    {
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
 8001f34:	780b      	ldrb	r3, [r1, #0]
 8001f36:	8083      	strh	r3, [r0, #4]
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
 8001f38:	784a      	ldrb	r2, [r1, #1]
 8001f3a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer)
 8001f3e:	b085      	sub	sp, #20
    {
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
 8001f40:	8083      	strh	r3, [r0, #4]
      *(outbuffer + offset + 3) = (u_buffer_size.base >> (8 * 3)) & 0xFF;
      offset += sizeof(this->buffer_size);
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer)
 8001f42:	4604      	mov	r4, r0
      int offset = 0;
      this->topic_id =  ((uint16_t) (*(inbuffer + offset)));
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name;
      memcpy(&length_topic_name, (inbuffer + offset), sizeof(uint32_t));
 8001f44:	f8d1 0002 	ldr.w	r0, [r1, #2]
 8001f48:	9001      	str	r0, [sp, #4]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_topic_name; ++k){
 8001f4a:	9d01      	ldr	r5, [sp, #4]
 8001f4c:	1d8a      	adds	r2, r1, #6
 8001f4e:	1dab      	adds	r3, r5, #6
 8001f50:	1a50      	subs	r0, r2, r1
 8001f52:	4283      	cmp	r3, r0
 8001f54:	d904      	bls.n	8001f60 <_ZN14rosserial_msgs9TopicInfo11deserializeEPh+0x2e>
          inbuffer[k-1]=inbuffer[k];
 8001f56:	f812 0b01 	ldrb.w	r0, [r2], #1
 8001f5a:	f802 0c02 	strb.w	r0, [r2, #-2]
      this->topic_id |= ((uint16_t) (*(inbuffer + offset + 1))) << (8 * 1);
      offset += sizeof(this->topic_id);
      uint32_t length_topic_name;
      memcpy(&length_topic_name, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_topic_name; ++k){
 8001f5e:	e7f7      	b.n	8001f50 <_ZN14rosserial_msgs9TopicInfo11deserializeEPh+0x1e>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_topic_name-1]=0;
 8001f60:	194a      	adds	r2, r1, r5
 8001f62:	2000      	movs	r0, #0
 8001f64:	7150      	strb	r0, [r2, #5]
      this->topic_name = (char *)(inbuffer + offset-1);
 8001f66:	1d4a      	adds	r2, r1, #5
 8001f68:	60a2      	str	r2, [r4, #8]
      offset += length_topic_name;
      uint32_t length_message_type;
      memcpy(&length_message_type, (inbuffer + offset), sizeof(uint32_t));
 8001f6a:	58c8      	ldr	r0, [r1, r3]
 8001f6c:	9002      	str	r0, [sp, #8]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
 8001f6e:	1d1a      	adds	r2, r3, #4
 8001f70:	9b02      	ldr	r3, [sp, #8]
 8001f72:	f105 000a 	add.w	r0, r5, #10
 8001f76:	4413      	add	r3, r2
 8001f78:	4408      	add	r0, r1
 8001f7a:	1a45      	subs	r5, r0, r1
 8001f7c:	42ab      	cmp	r3, r5
 8001f7e:	d904      	bls.n	8001f8a <_ZN14rosserial_msgs9TopicInfo11deserializeEPh+0x58>
          inbuffer[k-1]=inbuffer[k];
 8001f80:	f810 5b01 	ldrb.w	r5, [r0], #1
 8001f84:	f800 5c02 	strb.w	r5, [r0, #-2]
      this->topic_name = (char *)(inbuffer + offset-1);
      offset += length_topic_name;
      uint32_t length_message_type;
      memcpy(&length_message_type, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
 8001f88:	e7f7      	b.n	8001f7a <_ZN14rosserial_msgs9TopicInfo11deserializeEPh+0x48>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
 8001f8a:	18c8      	adds	r0, r1, r3
      this->message_type = (char *)(inbuffer + offset-1);
 8001f8c:	3a01      	subs	r2, #1
 8001f8e:	440a      	add	r2, r1
      memcpy(&length_message_type, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_message_type; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_message_type-1]=0;
 8001f90:	2500      	movs	r5, #0
 8001f92:	f800 5c01 	strb.w	r5, [r0, #-1]
      this->message_type = (char *)(inbuffer + offset-1);
 8001f96:	60e2      	str	r2, [r4, #12]
      offset += length_message_type;
      uint32_t length_md5sum;
      memcpy(&length_md5sum, (inbuffer + offset), sizeof(uint32_t));
 8001f98:	6800      	ldr	r0, [r0, #0]
 8001f9a:	9003      	str	r0, [sp, #12]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
 8001f9c:	9803      	ldr	r0, [sp, #12]
 8001f9e:	3304      	adds	r3, #4
 8001fa0:	4418      	add	r0, r3
 8001fa2:	18ca      	adds	r2, r1, r3
 8001fa4:	1a55      	subs	r5, r2, r1
 8001fa6:	42a8      	cmp	r0, r5
 8001fa8:	d904      	bls.n	8001fb4 <_ZN14rosserial_msgs9TopicInfo11deserializeEPh+0x82>
          inbuffer[k-1]=inbuffer[k];
 8001faa:	f812 5b01 	ldrb.w	r5, [r2], #1
 8001fae:	f802 5c02 	strb.w	r5, [r2, #-2]
      this->message_type = (char *)(inbuffer + offset-1);
      offset += length_message_type;
      uint32_t length_md5sum;
      memcpy(&length_md5sum, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
 8001fb2:	e7f7      	b.n	8001fa4 <_ZN14rosserial_msgs9TopicInfo11deserializeEPh+0x72>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_md5sum-1]=0;
 8001fb4:	180d      	adds	r5, r1, r0
      this->md5sum = (char *)(inbuffer + offset-1);
 8001fb6:	3b01      	subs	r3, #1
 8001fb8:	440b      	add	r3, r1
      memcpy(&length_md5sum, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_md5sum; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_md5sum-1]=0;
 8001fba:	2200      	movs	r2, #0
 8001fbc:	f805 2c01 	strb.w	r2, [r5, #-1]
      this->md5sum = (char *)(inbuffer + offset-1);
 8001fc0:	6123      	str	r3, [r4, #16]
      u_buffer_size.base = 0;
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->buffer_size = u_buffer_size.real;
 8001fc2:	78ab      	ldrb	r3, [r5, #2]
 8001fc4:	786a      	ldrb	r2, [r5, #1]
 8001fc6:	041b      	lsls	r3, r3, #16
 8001fc8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8001fcc:	5c0a      	ldrb	r2, [r1, r0]
 8001fce:	4313      	orrs	r3, r2
 8001fd0:	78ea      	ldrb	r2, [r5, #3]
      offset += sizeof(this->buffer_size);
     return offset;
    }
 8001fd2:	3004      	adds	r0, #4
      u_buffer_size.base = 0;
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_buffer_size.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->buffer_size = u_buffer_size.real;
 8001fd4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001fd8:	6163      	str	r3, [r4, #20]
      offset += sizeof(this->buffer_size);
     return offset;
    }
 8001fda:	b005      	add	sp, #20
 8001fdc:	bd30      	pop	{r4, r5, pc}

08001fde <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
 8001fde:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    {
      int offset = 0;
      uint8_t ints_lengthT = *(inbuffer + offset++);
 8001fe0:	780d      	ldrb	r5, [r1, #0]
      if(ints_lengthT > ints_length)
 8001fe2:	7903      	ldrb	r3, [r0, #4]
 8001fe4:	42ab      	cmp	r3, r5
      offset += length_stringsi;
      }
      return offset;
    }

    virtual int deserialize(unsigned char *inbuffer)
 8001fe6:	4604      	mov	r4, r0
 8001fe8:	460e      	mov	r6, r1
    {
      int offset = 0;
      uint8_t ints_lengthT = *(inbuffer + offset++);
      if(ints_lengthT > ints_length)
 8001fea:	d204      	bcs.n	8001ff6 <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0x18>
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
 8001fec:	00a9      	lsls	r1, r5, #2
 8001fee:	68c0      	ldr	r0, [r0, #12]
 8001ff0:	f006 f928 	bl	8008244 <realloc>
 8001ff4:	60e0      	str	r0, [r4, #12]
      offset += 3;
      ints_length = ints_lengthT;
 8001ff6:	7125      	strb	r5, [r4, #4]
 8001ff8:	1d32      	adds	r2, r6, #4
 8001ffa:	2100      	movs	r1, #0
      for( uint8_t i = 0; i < ints_length; i++){
 8001ffc:	7923      	ldrb	r3, [r4, #4]
 8001ffe:	1c4f      	adds	r7, r1, #1
 8002000:	b2c9      	uxtb	r1, r1
 8002002:	428b      	cmp	r3, r1
 8002004:	eba2 0506 	sub.w	r5, r2, r6
 8002008:	f102 0204 	add.w	r2, r2, #4
 800200c:	d914      	bls.n	8002038 <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0x5a>
      u_st_ints.base = 0;
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
 800200e:	f812 3c02 	ldrb.w	r3, [r2, #-2]
 8002012:	f812 0c03 	ldrb.w	r0, [r2, #-3]
 8002016:	041b      	lsls	r3, r3, #16
 8002018:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800201c:	f812 0c04 	ldrb.w	r0, [r2, #-4]
 8002020:	4303      	orrs	r3, r0
 8002022:	f812 0c01 	ldrb.w	r0, [r2, #-1]
 8002026:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 800202a:	60a3      	str	r3, [r4, #8]
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
 800202c:	68e3      	ldr	r3, [r4, #12]
 800202e:	68a0      	ldr	r0, [r4, #8]
 8002030:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
      uint8_t ints_lengthT = *(inbuffer + offset++);
      if(ints_lengthT > ints_length)
        this->ints = (int32_t*)realloc(this->ints, ints_lengthT * sizeof(int32_t));
      offset += 3;
      ints_length = ints_lengthT;
      for( uint8_t i = 0; i < ints_length; i++){
 8002034:	4639      	mov	r1, r7
 8002036:	e7e1      	b.n	8001ffc <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0x1e>
      u_st_ints.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_ints = u_st_ints.real;
      offset += sizeof(this->st_ints);
        memcpy( &(this->ints[i]), &(this->st_ints), sizeof(int32_t));
      }
      uint8_t floats_lengthT = *(inbuffer + offset++);
 8002038:	5d77      	ldrb	r7, [r6, r5]
      if(floats_lengthT > floats_length)
 800203a:	7c23      	ldrb	r3, [r4, #16]
 800203c:	42bb      	cmp	r3, r7
 800203e:	d204      	bcs.n	800204a <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0x6c>
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
 8002040:	00b9      	lsls	r1, r7, #2
 8002042:	69a0      	ldr	r0, [r4, #24]
 8002044:	f006 f8fe 	bl	8008244 <realloc>
 8002048:	61a0      	str	r0, [r4, #24]
 800204a:	1d2b      	adds	r3, r5, #4
      offset += 3;
      floats_length = floats_lengthT;
 800204c:	7427      	strb	r7, [r4, #16]
 800204e:	4433      	add	r3, r6
 8002050:	2200      	movs	r2, #0
      for( uint8_t i = 0; i < floats_length; i++){
 8002052:	7c21      	ldrb	r1, [r4, #16]
 8002054:	1c57      	adds	r7, r2, #1
 8002056:	b2d2      	uxtb	r2, r2
 8002058:	4291      	cmp	r1, r2
 800205a:	eba3 0506 	sub.w	r5, r3, r6
 800205e:	f103 0304 	add.w	r3, r3, #4
 8002062:	d914      	bls.n	800208e <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0xb0>
      } u_st_floats;
      u_st_floats.base = 0;
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 0))) << (8 * 0);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 1))) << (8 * 1);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 2))) << (8 * 2);
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
 8002064:	f813 1c02 	ldrb.w	r1, [r3, #-2]
 8002068:	f813 0c03 	ldrb.w	r0, [r3, #-3]
 800206c:	0409      	lsls	r1, r1, #16
 800206e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8002072:	f813 0c04 	ldrb.w	r0, [r3, #-4]
 8002076:	4301      	orrs	r1, r0
 8002078:	f813 0c01 	ldrb.w	r0, [r3, #-1]
      this->st_floats = u_st_floats.real;
 800207c:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 8002080:	6161      	str	r1, [r4, #20]
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
 8002082:	69a1      	ldr	r1, [r4, #24]
 8002084:	6960      	ldr	r0, [r4, #20]
 8002086:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
      uint8_t floats_lengthT = *(inbuffer + offset++);
      if(floats_lengthT > floats_length)
        this->floats = (float*)realloc(this->floats, floats_lengthT * sizeof(float));
      offset += 3;
      floats_length = floats_lengthT;
      for( uint8_t i = 0; i < floats_length; i++){
 800208a:	463a      	mov	r2, r7
 800208c:	e7e1      	b.n	8002052 <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0x74>
      u_st_floats.base |= ((uint32_t) (*(inbuffer + offset + 3))) << (8 * 3);
      this->st_floats = u_st_floats.real;
      offset += sizeof(this->st_floats);
        memcpy( &(this->floats[i]), &(this->st_floats), sizeof(float));
      }
      uint8_t strings_lengthT = *(inbuffer + offset++);
 800208e:	5d77      	ldrb	r7, [r6, r5]
      if(strings_lengthT > strings_length)
 8002090:	7f23      	ldrb	r3, [r4, #28]
 8002092:	42bb      	cmp	r3, r7
 8002094:	d204      	bcs.n	80020a0 <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0xc2>
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
 8002096:	00b9      	lsls	r1, r7, #2
 8002098:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800209a:	f006 f8d3 	bl	8008244 <realloc>
 800209e:	6260      	str	r0, [r4, #36]	; 0x24
      offset += 3;
 80020a0:	1d2b      	adds	r3, r5, #4
      strings_length = strings_lengthT;
 80020a2:	2500      	movs	r5, #0
 80020a4:	7727      	strb	r7, [r4, #28]
      memcpy(&length_st_strings, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
 80020a6:	46ae      	mov	lr, r5
      uint8_t strings_lengthT = *(inbuffer + offset++);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      offset += 3;
      strings_length = strings_lengthT;
      for( uint8_t i = 0; i < strings_length; i++){
 80020a8:	7f22      	ldrb	r2, [r4, #28]
 80020aa:	b2ef      	uxtb	r7, r5
 80020ac:	42ba      	cmp	r2, r7
 80020ae:	d919      	bls.n	80020e4 <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0x106>
      uint32_t length_st_strings;
      memcpy(&length_st_strings, (inbuffer + offset), sizeof(uint32_t));
 80020b0:	58f0      	ldr	r0, [r6, r3]
 80020b2:	9001      	str	r0, [sp, #4]
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
 80020b4:	1d1a      	adds	r2, r3, #4
 80020b6:	9b01      	ldr	r3, [sp, #4]
 80020b8:	18b1      	adds	r1, r6, r2
 80020ba:	4413      	add	r3, r2
 80020bc:	1b88      	subs	r0, r1, r6
 80020be:	4283      	cmp	r3, r0
 80020c0:	d904      	bls.n	80020cc <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0xee>
          inbuffer[k-1]=inbuffer[k];
 80020c2:	f811 0b01 	ldrb.w	r0, [r1], #1
 80020c6:	f801 0c02 	strb.w	r0, [r1, #-2]
      strings_length = strings_lengthT;
      for( uint8_t i = 0; i < strings_length; i++){
      uint32_t length_st_strings;
      memcpy(&length_st_strings, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
 80020ca:	e7f7      	b.n	80020bc <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0xde>
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
 80020cc:	18f1      	adds	r1, r6, r3
      this->st_strings = (char *)(inbuffer + offset-1);
 80020ce:	3a01      	subs	r2, #1
      memcpy(&length_st_strings, (inbuffer + offset), sizeof(uint32_t));
      offset += 4;
      for(unsigned int k= offset; k< offset+length_st_strings; ++k){
          inbuffer[k-1]=inbuffer[k];
      }
      inbuffer[offset+length_st_strings-1]=0;
 80020d0:	f801 ec01 	strb.w	lr, [r1, #-1]
      this->st_strings = (char *)(inbuffer + offset-1);
 80020d4:	4432      	add	r2, r6
 80020d6:	6222      	str	r2, [r4, #32]
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
 80020d8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80020da:	6a21      	ldr	r1, [r4, #32]
 80020dc:	f842 1027 	str.w	r1, [r2, r7, lsl #2]
 80020e0:	3501      	adds	r5, #1
      uint8_t strings_lengthT = *(inbuffer + offset++);
      if(strings_lengthT > strings_length)
        this->strings = (char**)realloc(this->strings, strings_lengthT * sizeof(char*));
      offset += 3;
      strings_length = strings_lengthT;
      for( uint8_t i = 0; i < strings_length; i++){
 80020e2:	e7e1      	b.n	80020a8 <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh+0xca>
      this->st_strings = (char *)(inbuffer + offset-1);
      offset += length_st_strings;
        memcpy( &(this->strings[i]), &(this->st_strings), sizeof(char*));
      }
     return offset;
    }
 80020e4:	4618      	mov	r0, r3
 80020e6:	b003      	add	sp, #12
 80020e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080020ec <_ZN17ComplementaryAHRS10estimationEv>:
    v->y +=  delta[X]  * v_tmp.z - delta[Z]   * v_tmp.x;
  }
  */

  /* core esitmation process, using body frame */
  virtual void estimation() 
 80020ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80020f0:	ed2d 8b04 	vpush	{d8-d9}
 80020f4:	4604      	mov	r4, r0

      rotateV(&EstGb_.V,delta_gyro_angle);
      rotateV(&EstMb_.V,delta_gyro_angle);
 #endif

    float acc_magnitude = acc_b_ * acc_b_; //norm?
 80020f6:	f100 0b04 	add.w	fp, r0, #4
    v->y +=  delta[X]  * v_tmp.z - delta[Z]   * v_tmp.x;
  }
  */

  /* core esitmation process, using body frame */
  virtual void estimation() 
 80020fa:	b08d      	sub	sp, #52	; 0x34

      rotateV(&EstGb_.V,delta_gyro_angle);
      rotateV(&EstMb_.V,delta_gyro_angle);
 #endif

    float acc_magnitude = acc_b_ * acc_b_; //norm?
 80020fc:	4659      	mov	r1, fp
 80020fe:	4658      	mov	r0, fp
    Vector3f est_g_b_tmp = est_g_b_;
 8002100:	f104 06b0 	add.w	r6, r4, #176	; 0xb0

      rotateV(&EstGb_.V,delta_gyro_angle);
      rotateV(&EstMb_.V,delta_gyro_angle);
 #endif

    float acc_magnitude = acc_b_ * acc_b_; //norm?
 8002104:	f003 fed6 	bl	8005eb4 <_ZNK7Vector3IfEmlERKS0_>
    Vector3f est_g_b_tmp = est_g_b_;
 8002108:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    Vector3f est_m_b_tmp = est_m_b_;
 800210c:	f104 05bc 	add.w	r5, r4, #188	; 0xbc
      rotateV(&EstGb_.V,delta_gyro_angle);
      rotateV(&EstMb_.V,delta_gyro_angle);
 #endif

    float acc_magnitude = acc_b_ * acc_b_; //norm?
    Vector3f est_g_b_tmp = est_g_b_;
 8002110:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
    Vector3f est_m_b_tmp = est_m_b_;
 8002114:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8002118:	af03      	add	r7, sp, #12
    est_g_b_ += (est_g_b_tmp % (gyro_b_  * (DELTA_T * GYRO_AMP) )); //rotation by gyro
 800211a:	f104 091c 	add.w	r9, r4, #28
      rotateV(&EstMb_.V,delta_gyro_angle);
 #endif

    float acc_magnitude = acc_b_ * acc_b_; //norm?
    Vector3f est_g_b_tmp = est_g_b_;
    Vector3f est_m_b_tmp = est_m_b_;
 800211e:	e887 0007 	stmia.w	r7, {r0, r1, r2}

      rotateV(&EstGb_.V,delta_gyro_angle);
      rotateV(&EstMb_.V,delta_gyro_angle);
 #endif

    float acc_magnitude = acc_b_ * acc_b_; //norm?
 8002122:	eeb0 8a40 	vmov.f32	s16, s0
    Vector3f est_g_b_tmp = est_g_b_;
    Vector3f est_m_b_tmp = est_m_b_;
    est_g_b_ += (est_g_b_tmp % (gyro_b_  * (DELTA_T * GYRO_AMP) )); //rotation by gyro
 8002126:	4648      	mov	r0, r9
 8002128:	ed9f 0a86 	vldr	s0, [pc, #536]	; 8002344 <_ZN17ComplementaryAHRS10estimationEv+0x258>
 800212c:	f003 ffb2 	bl	8006094 <_ZNK7Vector3IfEmlEf>
 8002130:	a906      	add	r1, sp, #24
 8002132:	4668      	mov	r0, sp
 8002134:	edcd 0a07 	vstr	s1, [sp, #28]
 8002138:	ed8d 1a08 	vstr	s2, [sp, #32]
 800213c:	ed8d 0a06 	vstr	s0, [sp, #24]
 8002140:	f003 fe58 	bl	8005df4 <_ZNK7Vector3IfErmERKS0_>
 8002144:	a909      	add	r1, sp, #36	; 0x24
 8002146:	4630      	mov	r0, r6
 8002148:	edcd 0a0a 	vstr	s1, [sp, #40]	; 0x28
 800214c:	ed8d 1a0b 	vstr	s2, [sp, #44]	; 0x2c
 8002150:	ed8d 0a09 	vstr	s0, [sp, #36]	; 0x24
 8002154:	f003 ff30 	bl	8005fb8 <_ZN7Vector3IfEpLERKS0_>
    est_m_b_ += (est_m_b_tmp % (gyro_b_  * (DELTA_T * GYRO_AMP) )); //rotation by gyro
 8002158:	ed9f 0a7a 	vldr	s0, [pc, #488]	; 8002344 <_ZN17ComplementaryAHRS10estimationEv+0x258>
 800215c:	4648      	mov	r0, r9
 800215e:	f003 ff99 	bl	8006094 <_ZNK7Vector3IfEmlEf>
 8002162:	a906      	add	r1, sp, #24
 8002164:	4638      	mov	r0, r7
 8002166:	ed8d 0a06 	vstr	s0, [sp, #24]
 800216a:	edcd 0a07 	vstr	s1, [sp, #28]
 800216e:	ed8d 1a08 	vstr	s2, [sp, #32]
 8002172:	f003 fe3f 	bl	8005df4 <_ZNK7Vector3IfErmERKS0_>
 8002176:	a909      	add	r1, sp, #36	; 0x24
 8002178:	4628      	mov	r0, r5
 800217a:	ed8d 0a09 	vstr	s0, [sp, #36]	; 0x24
 800217e:	edcd 0a0a 	vstr	s1, [sp, #40]	; 0x28
 8002182:	ed8d 1a0b 	vstr	s2, [sp, #44]	; 0x2c
 8002186:	f003 ff17 	bl	8005fb8 <_ZN7Vector3IfEpLERKS0_>



    if( G_MIN < acc_magnitude && acc_magnitude < G_MAX) valid_acc = 1;
 800218a:	eddf 7a6f 	vldr	s15, [pc, #444]	; 8002348 <_ZN17ComplementaryAHRS10estimationEv+0x25c>
 800218e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8002192:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      rotateV(&EstGb_.V,delta_gyro_angle);
      rotateV(&EstMb_.V,delta_gyro_angle);
 #endif

    float acc_magnitude = acc_b_ * acc_b_; //norm?
    Vector3f est_g_b_tmp = est_g_b_;
 8002196:	46e8      	mov	r8, sp
    est_g_b_ += (est_g_b_tmp % (gyro_b_  * (DELTA_T * GYRO_AMP) )); //rotation by gyro
    est_m_b_ += (est_m_b_tmp % (gyro_b_  * (DELTA_T * GYRO_AMP) )); //rotation by gyro



    if( G_MIN < acc_magnitude && acc_magnitude < G_MAX) valid_acc = 1;
 8002198:	dd0b      	ble.n	80021b2 <_ZN17ComplementaryAHRS10estimationEv+0xc6>
 800219a:	eddf 7a6c 	vldr	s15, [pc, #432]	; 800234c <_ZN17ComplementaryAHRS10estimationEv+0x260>
 800219e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80021a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80021a6:	bf4c      	ite	mi
 80021a8:	f04f 0a01 	movmi.w	sl, #1
 80021ac:	f04f 0a00 	movpl.w	sl, #0
 80021b0:	e001      	b.n	80021b6 <_ZN17ComplementaryAHRS10estimationEv+0xca>
    else valid_acc = 0;
 80021b2:	f04f 0a00 	mov.w	sl, #0
    rpy_[Z] = atan2f( EstMv_.V.z * EstGv_.V.y - EstMv_.V.y * EstGv_.V.z,
                      EstMv_.V.x * invG * sqGY_sqGZ  - (EstMv_.V.y * EstGv_.V.y + EstMv_.V.z * EstGv_.V.z) * invG * EstGv_.V.x ) ;//+ MAG_DECLINIATION;
#endif


    est_g_b_tmp = est_g_b_;
 80021b6:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 80021ba:	e888 0007 	stmia.w	r8, {r0, r1, r2}
    est_m_b_tmp = est_m_b_;
 80021be:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80021c2:	f8df 919c 	ldr.w	r9, [pc, #412]	; 8002360 <_ZN17ComplementaryAHRS10estimationEv+0x274>
 80021c6:	e887 0007 	stmia.w	r7, {r0, r1, r2}

    if ( valid_acc == 1 && cnt == 0)
 80021ca:	f1ba 0f00 	cmp.w	sl, #0
 80021ce:	d022      	beq.n	8002216 <_ZN17ComplementaryAHRS10estimationEv+0x12a>
 80021d0:	f8d9 3000 	ldr.w	r3, [r9]
 80021d4:	b9fb      	cbnz	r3, 8002216 <_ZN17ComplementaryAHRS10estimationEv+0x12a>
      est_g_b_ = (est_g_b_tmp * GYR_CMPF_FACTOR + acc_b_) * INV_GYR_CMPF_FACTOR;
 80021d6:	ed9f 0a5e 	vldr	s0, [pc, #376]	; 8002350 <_ZN17ComplementaryAHRS10estimationEv+0x264>
 80021da:	4640      	mov	r0, r8
 80021dc:	f003 ff5a 	bl	8006094 <_ZNK7Vector3IfEmlEf>
 80021e0:	4659      	mov	r1, fp
 80021e2:	a806      	add	r0, sp, #24
 80021e4:	ed8d 0a06 	vstr	s0, [sp, #24]
 80021e8:	edcd 0a07 	vstr	s1, [sp, #28]
 80021ec:	ed8d 1a08 	vstr	s2, [sp, #32]
 80021f0:	f003 ff90 	bl	8006114 <_ZNK7Vector3IfEplERKS0_>
 80021f4:	a809      	add	r0, sp, #36	; 0x24
 80021f6:	ed8d 0a09 	vstr	s0, [sp, #36]	; 0x24
 80021fa:	ed9f 0a56 	vldr	s0, [pc, #344]	; 8002354 <_ZN17ComplementaryAHRS10estimationEv+0x268>
 80021fe:	edcd 0a0a 	vstr	s1, [sp, #40]	; 0x28
 8002202:	ed8d 1a0b 	vstr	s2, [sp, #44]	; 0x2c
 8002206:	f003 ff45 	bl	8006094 <_ZNK7Vector3IfEmlEf>
 800220a:	ed84 0a2c 	vstr	s0, [r4, #176]	; 0xb0
 800220e:	edc4 0a2d 	vstr	s1, [r4, #180]	; 0xb4
 8002212:	ed84 1a2e 	vstr	s2, [r4, #184]	; 0xb8
    est_m_b_ = (est_m_b_tmp * GYR_CMPFM_FACTOR  + mag_b_) * INV_GYR_CMPFM_FACTOR;
 8002216:	ed9f 0a50 	vldr	s0, [pc, #320]	; 8002358 <_ZN17ComplementaryAHRS10estimationEv+0x26c>
 800221a:	4638      	mov	r0, r7
 800221c:	f003 ff3a 	bl	8006094 <_ZNK7Vector3IfEmlEf>
 8002220:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8002224:	a806      	add	r0, sp, #24
 8002226:	ed8d 1a08 	vstr	s2, [sp, #32]
 800222a:	edcd 0a07 	vstr	s1, [sp, #28]
 800222e:	ed8d 0a06 	vstr	s0, [sp, #24]
 8002232:	f003 ff6f 	bl	8006114 <_ZNK7Vector3IfEplERKS0_>
 8002236:	a809      	add	r0, sp, #36	; 0x24
 8002238:	ed8d 0a09 	vstr	s0, [sp, #36]	; 0x24
 800223c:	ed9f 0a47 	vldr	s0, [pc, #284]	; 800235c <_ZN17ComplementaryAHRS10estimationEv+0x270>
 8002240:	ed8d 1a0b 	vstr	s2, [sp, #44]	; 0x2c
 8002244:	edcd 0a0a 	vstr	s1, [sp, #40]	; 0x28
 8002248:	f003 ff24 	bl	8006094 <_ZNK7Vector3IfEmlEf>

    est_g_v_ = r_ * est_g_b_;
 800224c:	f104 074c 	add.w	r7, r4, #76	; 0x4c
    est_g_b_tmp = est_g_b_;
    est_m_b_tmp = est_m_b_;

    if ( valid_acc == 1 && cnt == 0)
      est_g_b_ = (est_g_b_tmp * GYR_CMPF_FACTOR + acc_b_) * INV_GYR_CMPF_FACTOR;
    est_m_b_ = (est_m_b_tmp * GYR_CMPFM_FACTOR  + mag_b_) * INV_GYR_CMPFM_FACTOR;
 8002250:	ed84 1a31 	vstr	s2, [r4, #196]	; 0xc4
 8002254:	edc4 0a30 	vstr	s1, [r4, #192]	; 0xc0
 8002258:	ed84 0a2f 	vstr	s0, [r4, #188]	; 0xbc

    est_g_v_ = r_ * est_g_b_;
 800225c:	4631      	mov	r1, r6
 800225e:	4638      	mov	r0, r7
 8002260:	f004 f8a8 	bl	80063b4 <_ZNK7Matrix3IfEmlERK7Vector3IfE>
    est_m_v_ = r_ * est_m_b_;
 8002264:	4629      	mov	r1, r5

    if ( valid_acc == 1 && cnt == 0)
      est_g_b_ = (est_g_b_tmp * GYR_CMPF_FACTOR + acc_b_) * INV_GYR_CMPF_FACTOR;
    est_m_b_ = (est_m_b_tmp * GYR_CMPFM_FACTOR  + mag_b_) * INV_GYR_CMPFM_FACTOR;

    est_g_v_ = r_ * est_g_b_;
 8002266:	ed84 1a28 	vstr	s2, [r4, #160]	; 0xa0
    est_m_v_ = r_ * est_m_b_;
 800226a:	4638      	mov	r0, r7

    if ( valid_acc == 1 && cnt == 0)
      est_g_b_ = (est_g_b_tmp * GYR_CMPF_FACTOR + acc_b_) * INV_GYR_CMPF_FACTOR;
    est_m_b_ = (est_m_b_tmp * GYR_CMPFM_FACTOR  + mag_b_) * INV_GYR_CMPFM_FACTOR;

    est_g_v_ = r_ * est_g_b_;
 800226c:	edc4 0a27 	vstr	s1, [r4, #156]	; 0x9c
 8002270:	ed84 0a26 	vstr	s0, [r4, #152]	; 0x98
    est_m_v_ = r_ * est_m_b_;
 8002274:	f004 f89e 	bl	80063b4 <_ZNK7Matrix3IfEmlERK7Vector3IfE>
 8002278:	ed84 0a29 	vstr	s0, [r4, #164]	; 0xa4

    // Attitude of the estimated vector
    float sq_g_x_sq_g_z = est_g_v_.x * est_g_v_.x + est_g_v_.z * est_g_v_.z;
 800227c:	ed94 0a28 	vldr	s0, [r4, #160]	; 0xa0
 8002280:	ed94 7a26 	vldr	s14, [r4, #152]	; 0x98
    float sq_g_y_sq_g_z = est_g_v_.y * est_g_v_.y + est_g_v_.z * est_g_v_.z;
 8002284:	edd4 7a27 	vldr	s15, [r4, #156]	; 0x9c
    if ( valid_acc == 1 && cnt == 0)
      est_g_b_ = (est_g_b_tmp * GYR_CMPF_FACTOR + acc_b_) * INV_GYR_CMPF_FACTOR;
    est_m_b_ = (est_m_b_tmp * GYR_CMPFM_FACTOR  + mag_b_) * INV_GYR_CMPFM_FACTOR;

    est_g_v_ = r_ * est_g_b_;
    est_m_v_ = r_ * est_m_b_;
 8002288:	ed84 1a2b 	vstr	s2, [r4, #172]	; 0xac

    // Attitude of the estimated vector
    float sq_g_x_sq_g_z = est_g_v_.x * est_g_v_.x + est_g_v_.z * est_g_v_.z;
 800228c:	ee20 0a00 	vmul.f32	s0, s0, s0
    if ( valid_acc == 1 && cnt == 0)
      est_g_b_ = (est_g_b_tmp * GYR_CMPF_FACTOR + acc_b_) * INV_GYR_CMPF_FACTOR;
    est_m_b_ = (est_m_b_tmp * GYR_CMPFM_FACTOR  + mag_b_) * INV_GYR_CMPFM_FACTOR;

    est_g_v_ = r_ * est_g_b_;
    est_m_v_ = r_ * est_m_b_;
 8002290:	edc4 0a2a 	vstr	s1, [r4, #168]	; 0xa8

    // Attitude of the estimated vector
    float sq_g_x_sq_g_z = est_g_v_.x * est_g_v_.x + est_g_v_.z * est_g_v_.z;
    float sq_g_y_sq_g_z = est_g_v_.y * est_g_v_.y + est_g_v_.z * est_g_v_.z;
 8002294:	eef0 8a40 	vmov.f32	s17, s0
    float invG = inv_sqrt(sq_g_x_sq_g_z + est_g_v_.y * est_g_v_.y);
 8002298:	eea7 0a07 	vfma.f32	s0, s14, s14
    est_g_v_ = r_ * est_g_b_;
    est_m_v_ = r_ * est_m_b_;

    // Attitude of the estimated vector
    float sq_g_x_sq_g_z = est_g_v_.x * est_g_v_.x + est_g_v_.z * est_g_v_.z;
    float sq_g_y_sq_g_z = est_g_v_.y * est_g_v_.y + est_g_v_.z * est_g_v_.z;
 800229c:	eee7 8aa7 	vfma.f32	s17, s15, s15
    float invG = inv_sqrt(sq_g_x_sq_g_z + est_g_v_.y * est_g_v_.y);
 80022a0:	eea7 0aa7 	vfma.f32	s0, s15, s15
 80022a4:	f004 f904 	bl	80064b0 <_Z8inv_sqrtf>

    rpy_.x = atan2f(est_g_v_.y , est_g_v_.z);
 80022a8:	edd4 0a28 	vldr	s1, [r4, #160]	; 0xa0
    est_m_v_ = r_ * est_m_b_;

    // Attitude of the estimated vector
    float sq_g_x_sq_g_z = est_g_v_.x * est_g_v_.x + est_g_v_.z * est_g_v_.z;
    float sq_g_y_sq_g_z = est_g_v_.y * est_g_v_.y + est_g_v_.z * est_g_v_.z;
    float invG = inv_sqrt(sq_g_x_sq_g_z + est_g_v_.y * est_g_v_.y);
 80022ac:	eeb0 8a40 	vmov.f32	s16, s0

    rpy_.x = atan2f(est_g_v_.y , est_g_v_.z);
 80022b0:	ed94 0a27 	vldr	s0, [r4, #156]	; 0x9c
 80022b4:	f004 fee8 	bl	8007088 <atan2f>
 80022b8:	ed84 0a1c 	vstr	s0, [r4, #112]	; 0x70
    rpy_.y = atan2f(-est_g_v_.x , inv_sqrt(sq_g_y_sq_g_z)* sq_g_y_sq_g_z);
 80022bc:	eeb0 0a68 	vmov.f32	s0, s17
 80022c0:	ed94 9a26 	vldr	s18, [r4, #152]	; 0x98
 80022c4:	f004 f8f4 	bl	80064b0 <_Z8inv_sqrtf>
 80022c8:	eeb1 9a49 	vneg.f32	s18, s18
 80022cc:	ee68 0a80 	vmul.f32	s1, s17, s0
 80022d0:	eeb0 0a49 	vmov.f32	s0, s18
 80022d4:	f004 fed8 	bl	8007088 <atan2f>
    rpy_.z = atan2f( est_m_v_.z * est_g_v_.y - est_m_v_.y * est_g_v_.z,
 80022d8:	ed94 6a2b 	vldr	s12, [r4, #172]	; 0xac
 80022dc:	ed94 7a28 	vldr	s14, [r4, #160]	; 0xa0
 80022e0:	edd4 6a27 	vldr	s13, [r4, #156]	; 0x9c
    float sq_g_x_sq_g_z = est_g_v_.x * est_g_v_.x + est_g_v_.z * est_g_v_.z;
    float sq_g_y_sq_g_z = est_g_v_.y * est_g_v_.y + est_g_v_.z * est_g_v_.z;
    float invG = inv_sqrt(sq_g_x_sq_g_z + est_g_v_.y * est_g_v_.y);

    rpy_.x = atan2f(est_g_v_.y , est_g_v_.z);
    rpy_.y = atan2f(-est_g_v_.x , inv_sqrt(sq_g_y_sq_g_z)* sq_g_y_sq_g_z);
 80022e4:	ed84 0a1d 	vstr	s0, [r4, #116]	; 0x74
    rpy_.z = atan2f( est_m_v_.z * est_g_v_.y - est_m_v_.y * est_g_v_.z,
 80022e8:	ee66 7a07 	vmul.f32	s15, s12, s14
 80022ec:	ed94 0a2a 	vldr	s0, [r4, #168]	; 0xa8
 80022f0:	edd4 0a26 	vldr	s1, [r4, #152]	; 0x98
 80022f4:	eee6 7a80 	vfma.f32	s15, s13, s0
 80022f8:	ee27 0a40 	vnmul.f32	s0, s14, s0
 80022fc:	ee67 7a88 	vmul.f32	s15, s15, s16
 8002300:	eea6 0a26 	vfma.f32	s0, s12, s13
 8002304:	ee60 0ae7 	vnmul.f32	s1, s1, s15
 8002308:	edd4 7a29 	vldr	s15, [r4, #164]	; 0xa4
 800230c:	ee28 8a27 	vmul.f32	s16, s16, s15
 8002310:	eee8 0a88 	vfma.f32	s1, s17, s16
 8002314:	f004 feb8 	bl	8007088 <atan2f>
                      est_m_v_.x * invG * sq_g_y_sq_g_z  - (est_m_v_.y * est_g_v_.y + est_m_v_.z * est_g_v_.z) * invG * est_g_v_.x ) ;//+ MAG_DECLINIATION;
 8002318:	ed84 0a1e 	vstr	s0, [r4, #120]	; 0x78
     //********************************************************************************:
     //** refrence1: https://sites.google.com/site/myimuestimationexperience/sensors/magnetometer
     //** refrence2: http://uav.xenocross.net/hdg.html
     //********************************************************************************
    /* update */
    if(valid_acc) cnt++;
 800231c:	f1ba 0f00 	cmp.w	sl, #0
 8002320:	d004      	beq.n	800232c <_ZN17ComplementaryAHRS10estimationEv+0x240>
 8002322:	f8d9 3000 	ldr.w	r3, [r9]
 8002326:	3301      	adds	r3, #1
 8002328:	f8c9 3000 	str.w	r3, [r9]
    if(cnt == PRESCLAER_ACC) cnt = 0;
 800232c:	f8d9 3000 	ldr.w	r3, [r9]
 8002330:	2b03      	cmp	r3, #3
 8002332:	bf02      	ittt	eq
 8002334:	4b0a      	ldreq	r3, [pc, #40]	; (8002360 <_ZN17ComplementaryAHRS10estimationEv+0x274>)
 8002336:	2200      	moveq	r2, #0
 8002338:	601a      	streq	r2, [r3, #0]
  }
 800233a:	b00d      	add	sp, #52	; 0x34
 800233c:	ecbd 8b04 	vpop	{d8-d9}
 8002340:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002344:	3a955b47 	.word	0x3a955b47
 8002348:	42900000 	.word	0x42900000
 800234c:	43050000 	.word	0x43050000
 8002350:	44160000 	.word	0x44160000
 8002354:	3ada1700 	.word	0x3ada1700
 8002358:	437a0000 	.word	0x437a0000
 800235c:	3b828cc0 	.word	0x3b828cc0
 8002360:	20003b80 	.word	0x20003b80

08002364 <_ZN16AttitudeEstimate19desireCoordCallbackERKN17aerial_robot_base11DesireCoordE>:

  uint32_t last_pub_time_;

  void desireCoordCallback(const aerial_robot_base::DesireCoord& coord_msg)
  {
    estimator_->coordinateUpdate(coord_msg.roll, coord_msg.pitch);
 8002364:	6c80      	ldr	r0, [r0, #72]	; 0x48
 8002366:	ed91 0a01 	vldr	s0, [r1, #4]
 800236a:	edd1 0a02 	vldr	s1, [r1, #8]
  void coordinateUpdate(float desire_attitude_roll, float desire_attitude_pitch)
  {
    desire_attitude_roll_ = desire_attitude_roll; 
    desire_attitude_pitch_ = desire_attitude_pitch; 

    r_.from_euler(desire_attitude_roll_, desire_attitude_pitch_, 0);
 800236e:	ed9f 1a04 	vldr	s2, [pc, #16]	; 8002380 <_ZN16AttitudeEstimate19desireCoordCallbackERKN17aerial_robot_base11DesireCoordE+0x1c>
  ~EstimatorAlgorithm(){}

  /* coodrinate change  */
  void coordinateUpdate(float desire_attitude_roll, float desire_attitude_pitch)
  {
    desire_attitude_roll_ = desire_attitude_roll; 
 8002372:	ed80 0a23 	vstr	s0, [r0, #140]	; 0x8c
    desire_attitude_pitch_ = desire_attitude_pitch; 
 8002376:	edc0 0a24 	vstr	s1, [r0, #144]	; 0x90

    r_.from_euler(desire_attitude_roll_, desire_attitude_pitch_, 0);
 800237a:	304c      	adds	r0, #76	; 0x4c
 800237c:	f003 bf68 	b.w	8006250 <_ZN7Matrix3IfE10from_eulerEfff>
 8002380:	00000000 	.word	0x00000000

08002384 <_ZN3IMUD1Ev>:
class IMU : public SENSOR_<Imugyro>
{
public:
	IMU(SPI_HandleTypeDef* hspi, ros::NodeHandle* nh);
	IMU(){};
	~IMU(){}
 8002384:	b510      	push	{r4, lr}
 8002386:	4604      	mov	r4, r0
      }
#endif

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
 8002388:	68c0      	ldr	r0, [r0, #12]

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
 800238a:	b108      	cbz	r0, 8002390 <_ZN3IMUD1Ev+0xc>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 800238c:	f004 fd68 	bl	8006e60 <_ZdlPv>
      }
#endif

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }
 8002390:	6820      	ldr	r0, [r4, #0]

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
 8002392:	b108      	cbz	r0, 8002398 <_ZN3IMUD1Ev+0x14>
 8002394:	f004 fd64 	bl	8006e60 <_ZdlPv>
 8002398:	4620      	mov	r0, r4
 800239a:	bd10      	pop	{r4, pc}

0800239c <_ZN3ros9Publisher7publishEPKNS_3MsgE>:
      Publisher( const char * topic_name, Msg * msg, int endpoint=rosserial_msgs::TopicInfo::ID_PUBLISHER) :
        topic_(topic_name), 
        msg_(msg),
        endpoint_(endpoint) {};

      int publish( const Msg * msg ) { return nh_->publish(id_, msg); };
 800239c:	68c3      	ldr	r3, [r0, #12]
 800239e:	681a      	ldr	r2, [r3, #0]
 80023a0:	b410      	push	{r4}
 80023a2:	6814      	ldr	r4, [r2, #0]
 80023a4:	460a      	mov	r2, r1
 80023a6:	6881      	ldr	r1, [r0, #8]
 80023a8:	4618      	mov	r0, r3
 80023aa:	4623      	mov	r3, r4
 80023ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80023b0:	4718      	bx	r3
	...

080023b4 <_ZN13StateEstimateC1Ev>:
#include "state_estimate/pos/pos_estimate.h"

class StateEstimate
{
public:
  StateEstimate()
 80023b4:	b510      	push	{r4, lr}
    Imu():
      stamp(),
      acc_data(),
      gyro_data(),
      mag_data(),
      angles()
 80023b6:	4a16      	ldr	r2, [pc, #88]	; (8002410 <_ZN13StateEstimateC1Ev+0x5c>)

    Barometer():
      stamp(),
      altitude(0),
      pressure(0),
      temperature(0)
 80023b8:	4c16      	ldr	r4, [pc, #88]	; (8002414 <_ZN13StateEstimateC1Ev+0x60>)
 80023ba:	6182      	str	r2, [r0, #24]
  class Time
  {
    public:
      uint32_t sec, nsec;

      Time() : sec(0), nsec(0) {}
 80023bc:	2100      	movs	r1, #0
 80023be:	2200      	movs	r2, #0
 80023c0:	66c4      	str	r4, [r0, #108]	; 0x6c

    Gps():
      stamp(),
      location(),
      velocity(),
      sat_num(0)
 80023c2:	4c15      	ldr	r4, [pc, #84]	; (8002418 <_ZN13StateEstimateC1Ev+0x64>)
 80023c4:	61c1      	str	r1, [r0, #28]
 80023c6:	6201      	str	r1, [r0, #32]
 80023c8:	6242      	str	r2, [r0, #36]	; 0x24
 80023ca:	6282      	str	r2, [r0, #40]	; 0x28
 80023cc:	62c2      	str	r2, [r0, #44]	; 0x2c
 80023ce:	6302      	str	r2, [r0, #48]	; 0x30
 80023d0:	6342      	str	r2, [r0, #52]	; 0x34
 80023d2:	6382      	str	r2, [r0, #56]	; 0x38
 80023d4:	63c2      	str	r2, [r0, #60]	; 0x3c
 80023d6:	6402      	str	r2, [r0, #64]	; 0x40
 80023d8:	6442      	str	r2, [r0, #68]	; 0x44
 80023da:	6482      	str	r2, [r0, #72]	; 0x48
 80023dc:	64c2      	str	r2, [r0, #76]	; 0x4c
 80023de:	6502      	str	r2, [r0, #80]	; 0x50
 80023e0:	6701      	str	r1, [r0, #112]	; 0x70
 80023e2:	6741      	str	r1, [r0, #116]	; 0x74
 80023e4:	6782      	str	r2, [r0, #120]	; 0x78
 80023e6:	67c2      	str	r2, [r0, #124]	; 0x7c
 80023e8:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 80023ec:	f8c0 4094 	str.w	r4, [r0, #148]	; 0x94
 80023f0:	f8c0 1098 	str.w	r1, [r0, #152]	; 0x98
 80023f4:	f8c0 109c 	str.w	r1, [r0, #156]	; 0x9c
 80023f8:	f8c0 20a0 	str.w	r2, [r0, #160]	; 0xa0
 80023fc:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
 8002400:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
 8002404:	f8c0 20ac 	str.w	r2, [r0, #172]	; 0xac
 8002408:	f880 10b0 	strb.w	r1, [r0, #176]	; 0xb0
  {
  }
 800240c:	bd10      	pop	{r4, pc}
 800240e:	bf00      	nop
 8002410:	08008db0 	.word	0x08008db0
 8002414:	08008e04 	.word	0x08008e04
 8002418:	08008e1c 	.word	0x08008e1c

0800241c <_Z18SystemClock_Configv>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 800241c:	b530      	push	{r4, r5, lr}
 800241e:	b095      	sub	sp, #84	; 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();
 8002420:	2300      	movs	r3, #0
 8002422:	4a26      	ldr	r2, [pc, #152]	; (80024bc <_Z18SystemClock_Configv+0xa0>)
 8002424:	9300      	str	r3, [sp, #0]
 8002426:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8002428:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 800242c:	6411      	str	r1, [r2, #64]	; 0x40
 800242e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8002430:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8002434:	9200      	str	r2, [sp, #0]
 8002436:	9a00      	ldr	r2, [sp, #0]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002438:	4a21      	ldr	r2, [pc, #132]	; (80024c0 <_Z18SystemClock_Configv+0xa4>)
 800243a:	9301      	str	r3, [sp, #4]
 800243c:	6811      	ldr	r1, [r2, #0]
 800243e:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
 8002442:	6011      	str	r1, [r2, #0]
 8002444:	6812      	ldr	r2, [r2, #0]
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8002446:	930e      	str	r3, [sp, #56]	; 0x38

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002448:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 800244c:	9201      	str	r2, [sp, #4]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
 800244e:	2308      	movs	r3, #8

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002450:	9a01      	ldr	r2, [sp, #4]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
 8002452:	930f      	str	r3, [sp, #60]	; 0x3c
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8002454:	2201      	movs	r2, #1

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8002456:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8002458:	920a      	str	r2, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 100;
 800245a:	2364      	movs	r3, #100	; 0x64

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 800245c:	2210      	movs	r2, #16
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
 800245e:	2504      	movs	r5, #4
  RCC_OscInitStruct.PLL.PLLR = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002460:	a807      	add	r0, sp, #28

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8002462:	9407      	str	r4, [sp, #28]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 8002464:	920b      	str	r2, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002466:	940d      	str	r4, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 100;
 8002468:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800246a:	9411      	str	r4, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLQ = 4;
 800246c:	9512      	str	r5, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLR = 2;
 800246e:	9413      	str	r4, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002470:	f002 fcb2 	bl	8004dd8 <HAL_RCC_OscConfig>
 8002474:	b100      	cbz	r0, 8002478 <_Z18SystemClock_Configv+0x5c>
 8002476:	e7fe      	b.n	8002476 <_Z18SystemClock_Configv+0x5a>
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
 8002478:	230f      	movs	r3, #15
 800247a:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800247c:	9004      	str	r0, [sp, #16]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800247e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8002482:	9006      	str	r0, [sp, #24]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 8002484:	2103      	movs	r1, #3
 8002486:	a802      	add	r0, sp, #8

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002488:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800248a:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 800248c:	f002 fbe4 	bl	8004c58 <HAL_RCC_ClockConfig>
 8002490:	4604      	mov	r4, r0
 8002492:	b100      	cbz	r0, 8002496 <_Z18SystemClock_Configv+0x7a>
 8002494:	e7fe      	b.n	8002494 <_Z18SystemClock_Configv+0x78>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8002496:	f002 fc79 	bl	8004d8c <HAL_RCC_GetHCLKFreq>
 800249a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800249e:	fbb0 f0f3 	udiv	r0, r0, r3
 80024a2:	f001 ff63 	bl	800436c <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80024a6:	4628      	mov	r0, r5
 80024a8:	f001 ff76 	bl	8004398 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80024ac:	4622      	mov	r2, r4
 80024ae:	4621      	mov	r1, r4
 80024b0:	f04f 30ff 	mov.w	r0, #4294967295
 80024b4:	f001 ff1a 	bl	80042ec <HAL_NVIC_SetPriority>
}
 80024b8:	b015      	add	sp, #84	; 0x54
 80024ba:	bd30      	pop	{r4, r5, pc}
 80024bc:	40023800 	.word	0x40023800
 80024c0:	40007000 	.word	0x40007000

080024c4 <_Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void _Error_Handler(char * file, int line)
{
 80024c4:	e7fe      	b.n	80024c4 <_Error_Handler>
	...

080024c8 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_>:
         int MAX_RX_BUFFER=400,
			int RX_BURST_SIZE=RX_BURST_MODE>
class UartDriver{
public:

  UartDriver(Hardware *huart): huart_(huart)
 80024c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80024ca:	4604      	mov	r4, r0
 80024cc:	6001      	str	r1, [r0, #0]
  {
    rx_ = new RxBuffer<Hardware, MAX_RX_BUFFER, RX_BURST_SIZE>(huart_);
 80024ce:	2004      	movs	r0, #4
 80024d0:	f004 fb7c 	bl	8006bcc <_Znwj>

template<class Hardware, int RX_SIZE, int RX_BURST_SIZE>
class RxBuffer
{
public:
  RxBuffer(Hardware *huart):huart_(huart)
 80024d4:	6823      	ldr	r3, [r4, #0]
 80024d6:	6003      	str	r3, [r0, #0]
class UartDriver{
public:

  UartDriver(Hardware *huart): huart_(huart)
  {
    rx_ = new RxBuffer<Hardware, MAX_RX_BUFFER, RX_BURST_SIZE>(huart_);
 80024d8:	4605      	mov	r5, r0
class RxBuffer
{
public:
  RxBuffer(Hardware *huart):huart_(huart)
  {
    ring_buf_ = new RingBuffer<uint8_t, RX_SIZE>();
 80024da:	f44f 70cb 	mov.w	r0, #406	; 0x196
 80024de:	f004 fb75 	bl	8006bcc <_Znwj>
class RingBuffer
{
public:
  RingBuffer()
  {
    byte_in_progress_ = 0;
 80024e2:	2300      	movs	r3, #0
 80024e4:	f8a0 3190 	strh.w	r3, [r0, #400]	; 0x190
    byte_to_add_ = 0;
 80024e8:	f8a0 3192 	strh.w	r3, [r0, #402]	; 0x192
    buffer_length_ = (uint16_t)SIZE;
 80024ec:	f44f 73c8 	mov.w	r3, #400	; 0x190
 80024f0:	f8a0 3194 	strh.w	r3, [r0, #404]	; 0x194
class RxBuffer
{
public:
  RxBuffer(Hardware *huart):huart_(huart)
  {
    ring_buf_ = new RingBuffer<uint8_t, RX_SIZE>();
 80024f4:	4b23      	ldr	r3, [pc, #140]	; (8002584 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xbc>)
    //RX
    HAL_UART_Receive_DMA(huart_, rx_value_, RX_BURST_SIZE); //1byte receive protocal
 80024f6:	4924      	ldr	r1, [pc, #144]	; (8002588 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xc0>)
class RxBuffer
{
public:
  RxBuffer(Hardware *huart):huart_(huart)
  {
    ring_buf_ = new RingBuffer<uint8_t, RX_SIZE>();
 80024f8:	6018      	str	r0, [r3, #0]
    //RX
    HAL_UART_Receive_DMA(huart_, rx_value_, RX_BURST_SIZE); //1byte receive protocal
 80024fa:	2208      	movs	r2, #8
 80024fc:	6828      	ldr	r0, [r5, #0]
 80024fe:	f003 fae1 	bl	8005ac4 <HAL_UART_Receive_DMA>
    huart_->hdmarx->XferCpltCallback = ReceiveCplt;
 8002502:	682b      	ldr	r3, [r5, #0]
 8002504:	4921      	ldr	r1, [pc, #132]	; (800258c <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xc4>)
 8002506:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002508:	63d1      	str	r1, [r2, #60]	; 0x3c
    __HAL_UART_DISABLE_IT(huart_, UART_IT_RXNE);
 800250a:	681a      	ldr	r2, [r3, #0]
 800250c:	68d3      	ldr	r3, [r2, #12]
 800250e:	f023 0320 	bic.w	r3, r3, #32
 8002512:	60d3      	str	r3, [r2, #12]
public:

  UartDriver(Hardware *huart): huart_(huart)
  {
    rx_ = new RxBuffer<Hardware, MAX_RX_BUFFER, RX_BURST_SIZE>(huart_);
    tx_ = new TxBuffer<Hardware, MAX_TX_BUFFER, MAX_TX_BUFFER_LENGTH>(huart_);
 8002514:	2004      	movs	r0, #4
class UartDriver{
public:

  UartDriver(Hardware *huart): huart_(huart)
  {
    rx_ = new RxBuffer<Hardware, MAX_RX_BUFFER, RX_BURST_SIZE>(huart_);
 8002516:	6065      	str	r5, [r4, #4]
    tx_ = new TxBuffer<Hardware, MAX_TX_BUFFER, MAX_TX_BUFFER_LENGTH>(huart_);
 8002518:	f004 fb58 	bl	8006bcc <_Znwj>
class TxBuffer
{
public:
  TxBuffer(Hardware *huart): huart_(huart)
  {
    idle_flag_ = true;
 800251c:	4b1c      	ldr	r3, [pc, #112]	; (8002590 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xc8>)
    subscript_in_progress_ = 0;
 800251e:	491d      	ldr	r1, [pc, #116]	; (8002594 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xcc>)
 8002520:	f8df e078 	ldr.w	lr, [pc, #120]	; 800259c <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xd4>
class TxBuffer
{
public:
  TxBuffer(Hardware *huart): huart_(huart)
  {
    idle_flag_ = true;
 8002524:	2201      	movs	r2, #1
public:

  UartDriver(Hardware *huart): huart_(huart)
  {
    rx_ = new RxBuffer<Hardware, MAX_RX_BUFFER, RX_BURST_SIZE>(huart_);
    tx_ = new TxBuffer<Hardware, MAX_TX_BUFFER, MAX_TX_BUFFER_LENGTH>(huart_);
 8002526:	4605      	mov	r5, r0
 8002528:	6820      	ldr	r0, [r4, #0]
class TxBuffer
{
public:
  TxBuffer(Hardware *huart): huart_(huart)
  {
    idle_flag_ = true;
 800252a:	701a      	strb	r2, [r3, #0]
    subscript_in_progress_ = 0;
 800252c:	2300      	movs	r3, #0
 800252e:	700b      	strb	r3, [r1, #0]
    subscript_to_add_ = 0;
 8002530:	4919      	ldr	r1, [pc, #100]	; (8002598 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xd0>)

template<class Hardware, int TX_SIZE, int BUFFER_LENGTH>
class TxBuffer
{
public:
  TxBuffer(Hardware *huart): huart_(huart)
 8002532:	6028      	str	r0, [r5, #0]
  {
    idle_flag_ = true;
    subscript_in_progress_ = 0;
    subscript_to_add_ = 0;
 8002534:	700b      	strb	r3, [r1, #0]

    for(int i = 0; i < TX_SIZE; i++) 
 8002536:	f243 1706 	movw	r7, #12550	; 0x3106
 800253a:	eb03 060e 	add.w	r6, r3, lr
      {
        tx_buffer_unit_[i].tx_len_ = 1;
        for(int j = 0; j < BUFFER_LENGTH; j++)
 800253e:	2100      	movs	r1, #0
    subscript_in_progress_ = 0;
    subscript_to_add_ = 0;

    for(int i = 0; i < TX_SIZE; i++) 
      {
        tx_buffer_unit_[i].tx_len_ = 1;
 8002540:	f886 20fa 	strb.w	r2, [r6, #250]	; 0xfa
        for(int j = 0; j < BUFFER_LENGTH; j++)
          tx_buffer_unit_[i].tx_data_[j]  = 1;
 8002544:	5472      	strb	r2, [r6, r1]
    subscript_to_add_ = 0;

    for(int i = 0; i < TX_SIZE; i++) 
      {
        tx_buffer_unit_[i].tx_len_ = 1;
        for(int j = 0; j < BUFFER_LENGTH; j++)
 8002546:	3101      	adds	r1, #1
 8002548:	29fa      	cmp	r1, #250	; 0xfa
 800254a:	d1fb      	bne.n	8002544 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0x7c>
 800254c:	33fb      	adds	r3, #251	; 0xfb
  {
    idle_flag_ = true;
    subscript_in_progress_ = 0;
    subscript_to_add_ = 0;

    for(int i = 0; i < TX_SIZE; i++) 
 800254e:	42bb      	cmp	r3, r7
 8002550:	d1f3      	bne.n	800253a <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0x72>
        for(int j = 0; j < BUFFER_LENGTH; j++)
          tx_buffer_unit_[i].tx_data_[j]  = 1;
      }

    //TX
    HAL_UART_Transmit_DMA(huart_, (uint8_t*)tx_buffer_unit_[0].tx_data_, tx_buffer_unit_[0].tx_len_);
 8002552:	4b12      	ldr	r3, [pc, #72]	; (800259c <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xd4>)
 8002554:	f893 20fa 	ldrb.w	r2, [r3, #250]	; 0xfa
 8002558:	4619      	mov	r1, r3
 800255a:	f003 fa79 	bl	8005a50 <HAL_UART_Transmit_DMA>


    huart_->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAT);
 800255e:	682a      	ldr	r2, [r5, #0]
 8002560:	6811      	ldr	r1, [r2, #0]
 8002562:	694b      	ldr	r3, [r1, #20]
 8002564:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002568:	614b      	str	r3, [r1, #20]
    huart_->hdmatx->XferCpltCallback = TransmitCplt;
 800256a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800256c:	4a0c      	ldr	r2, [pc, #48]	; (80025a0 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xd8>)
 800256e:	63da      	str	r2, [r3, #60]	; 0x3c

  UartDriver(Hardware *huart): huart_(huart)
  {
    rx_ = new RxBuffer<Hardware, MAX_RX_BUFFER, RX_BURST_SIZE>(huart_);
    tx_ = new TxBuffer<Hardware, MAX_TX_BUFFER, MAX_TX_BUFFER_LENGTH>(huart_);
  }
 8002570:	4620      	mov	r0, r4
public:

  UartDriver(Hardware *huart): huart_(huart)
  {
    rx_ = new RxBuffer<Hardware, MAX_RX_BUFFER, RX_BURST_SIZE>(huart_);
    tx_ = new TxBuffer<Hardware, MAX_TX_BUFFER, MAX_TX_BUFFER_LENGTH>(huart_);
 8002572:	60a5      	str	r5, [r4, #8]
  }
 8002574:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002576:	e7ff      	b.n	8002578 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_+0xb0>
public:

  UartDriver(Hardware *huart): huart_(huart)
  {
    rx_ = new RxBuffer<Hardware, MAX_RX_BUFFER, RX_BURST_SIZE>(huart_);
    tx_ = new TxBuffer<Hardware, MAX_TX_BUFFER, MAX_TX_BUFFER_LENGTH>(huart_);
 8002578:	4628      	mov	r0, r5
 800257a:	f004 fc71 	bl	8006e60 <_ZdlPv>
 800257e:	f003 ffd3 	bl	8006528 <__cxa_end_cleanup>
 8002582:	bf00      	nop
 8002584:	20003b7c 	.word	0x20003b7c
 8002588:	20003b71 	.word	0x20003b71
 800258c:	08001cc5 	.word	0x08001cc5
 8002590:	20000a68 	.word	0x20000a68
 8002594:	20000a6a 	.word	0x20000a6a
 8002598:	20000a69 	.word	0x20000a69
 800259c:	20000a6b 	.word	0x20000a6b
 80025a0:	08001b61 	.word	0x08001b61

080025a4 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE9advertiseERNS_9PublisherE>:
    /********************************************************************
     * Topic Management
     */

    /* Register a new publisher */
    bool advertise(Publisher & p)
 80025a4:	b510      	push	{r4, lr}
 80025a6:	f500 7206 	add.w	r2, r0, #536	; 0x218
    {
      for(int i = 0; i < MAX_PUBLISHERS; i++){
 80025aa:	2300      	movs	r3, #0
        if(publishers[i] == 0){ // empty slot
 80025ac:	f852 4f04 	ldr.w	r4, [r2, #4]!
 80025b0:	b944      	cbnz	r4, 80025c4 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE9advertiseERNS_9PublisherE+0x20>
          publishers[i] = &p;
 80025b2:	eb00 0283 	add.w	r2, r0, r3, lsl #2
          p.id_ = i+100+MAX_SUBSCRIBERS;
 80025b6:	3378      	adds	r3, #120	; 0x78
    /* Register a new publisher */
    bool advertise(Publisher & p)
    {
      for(int i = 0; i < MAX_PUBLISHERS; i++){
        if(publishers[i] == 0){ // empty slot
          publishers[i] = &p;
 80025b8:	f8c2 121c 	str.w	r1, [r2, #540]	; 0x21c
          p.id_ = i+100+MAX_SUBSCRIBERS;
          p.nh_ = this;
 80025bc:	60c8      	str	r0, [r1, #12]
    bool advertise(Publisher & p)
    {
      for(int i = 0; i < MAX_PUBLISHERS; i++){
        if(publishers[i] == 0){ // empty slot
          publishers[i] = &p;
          p.id_ = i+100+MAX_SUBSCRIBERS;
 80025be:	608b      	str	r3, [r1, #8]
          p.nh_ = this;
          return true;
 80025c0:	2001      	movs	r0, #1
 80025c2:	bd10      	pop	{r4, pc}
     */

    /* Register a new publisher */
    bool advertise(Publisher & p)
    {
      for(int i = 0; i < MAX_PUBLISHERS; i++){
 80025c4:	3301      	adds	r3, #1
 80025c6:	2b14      	cmp	r3, #20
 80025c8:	d1f0      	bne.n	80025ac <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE9advertiseERNS_9PublisherE+0x8>
          p.id_ = i+100+MAX_SUBSCRIBERS;
          p.nh_ = this;
          return true;
        }
      }
      return false;
 80025ca:	2000      	movs	r0, #0
    }
 80025cc:	bd10      	pop	{r4, pc}
	...

080025d0 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE>:
  static const uint8_t PUB_PRESCALER = 1;
  //This is hHard coding, 1000Hz /2 = 500Hz

  static const uint8_t PUB_HZ = 2; // 500Hz

  void init(IMU* imu, ros::NodeHandle* nh)
 80025d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  {
    nh_ = nh;
 80025d2:	4604      	mov	r4, r0
  static const uint8_t PUB_PRESCALER = 1;
  //This is hHard coding, 1000Hz /2 = 500Hz

  static const uint8_t PUB_HZ = 2; // 500Hz

  void init(IMU* imu, ros::NodeHandle* nh)
 80025d4:	4606      	mov	r6, r0
  {
    nh_ = nh;
 80025d6:	f844 2b08 	str.w	r2, [r4], #8

    imu_pub_  = new ros::Publisher("imu", &imu_msg_);
 80025da:	2014      	movs	r0, #20
  static const uint8_t PUB_PRESCALER = 1;
  //This is hHard coding, 1000Hz /2 = 500Hz

  static const uint8_t PUB_HZ = 2; // 500Hz

  void init(IMU* imu, ros::NodeHandle* nh)
 80025dc:	460f      	mov	r7, r1
  {
    nh_ = nh;

    imu_pub_  = new ros::Publisher("imu", &imu_msg_);
 80025de:	f004 faf5 	bl	8006bcc <_Znwj>
  {
    public:
      Publisher( const char * topic_name, Msg * msg, int endpoint=rosserial_msgs::TopicInfo::ID_PUBLISHER) :
        topic_(topic_name), 
        msg_(msg),
        endpoint_(endpoint) {};
 80025e2:	4b40      	ldr	r3, [pc, #256]	; (80026e4 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x114>)
 80025e4:	6070      	str	r0, [r6, #4]
 80025e6:	2500      	movs	r5, #0
 80025e8:	e880 0018 	stmia.w	r0, {r3, r4}
 80025ec:	4601      	mov	r1, r0
 80025ee:	6105      	str	r5, [r0, #16]
    nh_->advertise(*imu_pub_);
 80025f0:	6830      	ldr	r0, [r6, #0]
 80025f2:	f7ff ffd7 	bl	80025a4 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE9advertiseERNS_9PublisherE>

    desire_coord_sub_ = new ros::Subscriber2<aerial_robot_base::DesireCoord, AttitudeEstimate> ("/desire_coordinate", &AttitudeEstimate::desireCoordCallback, this );
 80025f6:	2030      	movs	r0, #48	; 0x30
 80025f8:	f004 fae8 	bl	8006bcc <_Znwj>
    public:
      typedef void(T::*CallbackT)(const MsgT&);
      MsgT msg;

      Subscriber2(const char * topic_name, CallbackT cb, T *obj,  int endpoint=rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
        obj_(obj), fun_obj_(cb), endpoint_(endpoint)
 80025fc:	4b3a      	ldr	r3, [pc, #232]	; (80026e8 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x118>)
 80025fe:	6003      	str	r3, [r0, #0]

    DesireCoord():
      roll(0),
      pitch(0),
      yaw(0),
      coord_type(0)
 8002600:	4b3a      	ldr	r3, [pc, #232]	; (80026ec <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x11c>)
 8002602:	60c3      	str	r3, [r0, #12]
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }
 8002604:	4b3a      	ldr	r3, [pc, #232]	; (80026f0 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x120>)
 8002606:	6243      	str	r3, [r0, #36]	; 0x24
    nh_->subscribe<aerial_robot_base::DesireCoord, AttitudeEstimate>(*desire_coord_sub_);
 8002608:	6832      	ldr	r2, [r6, #0]
 800260a:	7705      	strb	r5, [r0, #28]
 800260c:	2301      	movs	r3, #1
 800260e:	2400      	movs	r4, #0
 8002610:	62c3      	str	r3, [r0, #44]	; 0x2c
      {
        //std::binder1st t  = std::bind1st(std::mem_fun1_t())
        topic_ = topic_name;
 8002612:	4b38      	ldr	r3, [pc, #224]	; (80026f4 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x124>)
 8002614:	6083      	str	r3, [r0, #8]
 8002616:	6104      	str	r4, [r0, #16]
 8002618:	6144      	str	r4, [r0, #20]
 800261a:	6184      	str	r4, [r0, #24]
    public:
      typedef void(T::*CallbackT)(const MsgT&);
      MsgT msg;

      Subscriber2(const char * topic_name, CallbackT cb, T *obj,  int endpoint=rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
        obj_(obj), fun_obj_(cb), endpoint_(endpoint)
 800261c:	6206      	str	r6, [r0, #32]
 800261e:	6285      	str	r5, [r0, #40]	; 0x28
    nh_ = nh;

    imu_pub_  = new ros::Publisher("imu", &imu_msg_);
    nh_->advertise(*imu_pub_);

    desire_coord_sub_ = new ros::Subscriber2<aerial_robot_base::DesireCoord, AttitudeEstimate> ("/desire_coordinate", &AttitudeEstimate::desireCoordCallback, this );
 8002620:	6470      	str	r0, [r6, #68]	; 0x44
 8002622:	f502 711a 	add.w	r1, r2, #616	; 0x268
      return false;
    }
    /* Register a new subscriber, which is a member of class*/
    template<typename MsgT, class T>
    bool subscribe(Subscriber2< MsgT, T> & s){
      for(int i = 0; i < MAX_SUBSCRIBERS; i++){
 8002626:	462b      	mov	r3, r5
        if(subscribers[i] == 0){ // empty slot
 8002628:	f851 5f04 	ldr.w	r5, [r1, #4]!
 800262c:	b935      	cbnz	r5, 800263c <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x6c>
          subscribers[i] = (Subscriber_*) &s;
 800262e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
          s.id_ = i+100;
 8002632:	3364      	adds	r3, #100	; 0x64
    /* Register a new subscriber, which is a member of class*/
    template<typename MsgT, class T>
    bool subscribe(Subscriber2< MsgT, T> & s){
      for(int i = 0; i < MAX_SUBSCRIBERS; i++){
        if(subscribers[i] == 0){ // empty slot
          subscribers[i] = (Subscriber_*) &s;
 8002634:	f8c2 026c 	str.w	r0, [r2, #620]	; 0x26c
          s.id_ = i+100;
 8002638:	6043      	str	r3, [r0, #4]
 800263a:	e002      	b.n	8002642 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x72>
      return false;
    }
    /* Register a new subscriber, which is a member of class*/
    template<typename MsgT, class T>
    bool subscribe(Subscriber2< MsgT, T> & s){
      for(int i = 0; i < MAX_SUBSCRIBERS; i++){
 800263c:	3301      	adds	r3, #1
 800263e:	2b14      	cmp	r3, #20
 8002640:	d1f2      	bne.n	8002628 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x58>
    nh_->subscribe<aerial_robot_base::DesireCoord, AttitudeEstimate>(*desire_coord_sub_);

    imu_ = imu;
 8002642:	64f7      	str	r7, [r6, #76]	; 0x4c

    last_pub_time_ = HAL_GetTick();
 8002644:	f001 fcf0 	bl	8004028 <HAL_GetTick>
 8002648:	6530      	str	r0, [r6, #80]	; 0x50

#if ESTIMATE_TYPE == COMPLEMENTARY
    estimator_ = new ComplementaryAHRS();
 800264a:	20c8      	movs	r0, #200	; 0xc8
 800264c:	f004 fabe 	bl	8006bcc <_Znwj>
    float        q1, q2, q3, q4;

    // constructor creates a quaternion equivalent
    // to roll=0, pitch=0, yaw=0
    Quaternion() {
        q1 = 1; q2 = q3 = q4 = 0;
 8002650:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
{
public:
  EstimatorAlgorithm():
    acc_b_(), acc_v_(), gyro_b_(), gyro_v_(), mag_b_(), mag_v_(),q_(),
    desire_attitude_roll_(0), desire_attitude_pitch_(0),
    abs_rel_(ABSOLUTE_COORD)
 8002654:	2200      	movs	r2, #0
 8002656:	67c3      	str	r3, [r0, #124]	; 0x7c
public:
    T        x, y, z;

    // trivial ctor
    Vector3<T>() {
        x = y = z = 0;
 8002658:	60c4      	str	r4, [r0, #12]
 800265a:	6084      	str	r4, [r0, #8]
 800265c:	6044      	str	r4, [r0, #4]
 800265e:	6184      	str	r4, [r0, #24]
 8002660:	6144      	str	r4, [r0, #20]
 8002662:	6104      	str	r4, [r0, #16]
 8002664:	6244      	str	r4, [r0, #36]	; 0x24
 8002666:	6204      	str	r4, [r0, #32]
 8002668:	61c4      	str	r4, [r0, #28]
 800266a:	6304      	str	r4, [r0, #48]	; 0x30
 800266c:	62c4      	str	r4, [r0, #44]	; 0x2c
 800266e:	6284      	str	r4, [r0, #40]	; 0x28
 8002670:	63c4      	str	r4, [r0, #60]	; 0x3c
 8002672:	6384      	str	r4, [r0, #56]	; 0x38
 8002674:	6344      	str	r4, [r0, #52]	; 0x34
 8002676:	6484      	str	r4, [r0, #72]	; 0x48
 8002678:	6444      	str	r4, [r0, #68]	; 0x44
 800267a:	6404      	str	r4, [r0, #64]	; 0x40
 800267c:	6544      	str	r4, [r0, #84]	; 0x54
 800267e:	6504      	str	r4, [r0, #80]	; 0x50
 8002680:	6604      	str	r4, [r0, #96]	; 0x60
 8002682:	6584      	str	r4, [r0, #88]	; 0x58
 8002684:	6684      	str	r4, [r0, #104]	; 0x68
 8002686:	6644      	str	r4, [r0, #100]	; 0x64
 8002688:	6784      	str	r4, [r0, #120]	; 0x78
 800268a:	6744      	str	r4, [r0, #116]	; 0x74
 800268c:	6704      	str	r4, [r0, #112]	; 0x70
 800268e:	f8c0 4088 	str.w	r4, [r0, #136]	; 0x88
 8002692:	f8c0 4084 	str.w	r4, [r0, #132]	; 0x84
 8002696:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80
 800269a:	f8c0 408c 	str.w	r4, [r0, #140]	; 0x8c
 800269e:	f8c0 4090 	str.w	r4, [r0, #144]	; 0x90
    // zero the matrix
    void        zero(void);

    // setup the identity matrix
    void        identity(void) {
        a.x = b.y = c.z = 1;
 80026a2:	66c3      	str	r3, [r0, #108]	; 0x6c
 80026a4:	65c3      	str	r3, [r0, #92]	; 0x5c
 80026a6:	64c3      	str	r3, [r0, #76]	; 0x4c
 80026a8:	f880 2094 	strb.w	r2, [r0, #148]	; 0x94
class ComplementaryAHRS: public EstimatorAlgorithm
{
public:
  ComplementaryAHRS():EstimatorAlgorithm(),
                      est_g_v_(),  est_m_v_(),
                       est_g_b_(), est_m_b_()
 80026ac:	4b12      	ldr	r3, [pc, #72]	; (80026f8 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x128>)
 80026ae:	6003      	str	r3, [r0, #0]
 80026b0:	f8c0 40a0 	str.w	r4, [r0, #160]	; 0xa0
 80026b4:	f8c0 409c 	str.w	r4, [r0, #156]	; 0x9c
 80026b8:	f8c0 4098 	str.w	r4, [r0, #152]	; 0x98
 80026bc:	f8c0 40ac 	str.w	r4, [r0, #172]	; 0xac
 80026c0:	f8c0 40a8 	str.w	r4, [r0, #168]	; 0xa8
 80026c4:	f8c0 40a4 	str.w	r4, [r0, #164]	; 0xa4
 80026c8:	f8c0 40b8 	str.w	r4, [r0, #184]	; 0xb8
 80026cc:	f8c0 40b4 	str.w	r4, [r0, #180]	; 0xb4
 80026d0:	f8c0 40b0 	str.w	r4, [r0, #176]	; 0xb0
 80026d4:	f8c0 40c4 	str.w	r4, [r0, #196]	; 0xc4
 80026d8:	f8c0 40c0 	str.w	r4, [r0, #192]	; 0xc0
 80026dc:	f8c0 40bc 	str.w	r4, [r0, #188]	; 0xbc
 80026e0:	64b0      	str	r0, [r6, #72]	; 0x48
 80026e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80026e4:	0800906f 	.word	0x0800906f
 80026e8:	08008dec 	.word	0x08008dec
 80026ec:	08008dc8 	.word	0x08008dc8
 80026f0:	08002365 	.word	0x08002365
 80026f4:	08009073 	.word	0x08009073
 80026f8:	08008de0 	.word	0x08008de0

080026fc <main>:

}
/* USER CODE END 0 */

int main(void)
{
 80026fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80026fe:	f001 fc71 	bl	8003fe4 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8002702:	f7ff fe8b 	bl	800241c <_Z18SystemClock_Configv>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8002706:	f7fe ff2d 	bl	8001564 <MX_GPIO_Init>
  MX_DMA_Init();
 800270a:	f7fe ff09 	bl	8001520 <MX_DMA_Init>
  MX_USART1_UART_Init();
 800270e:	f000 fe8d 	bl	800342c <MX_USART1_UART_Init>
  MX_SPI1_Init();
 8002712:	f000 fddf 	bl	80032d4 <MX_SPI1_Init>
  MX_ADC1_Init();
 8002716:	f7fe fead 	bl	8001474 <MX_ADC1_Init>
  }

  int getBaud(){return baud_;}

  void init(serial_class* huart){
    iostream_ = new UartDriver<serial_class>(huart);
 800271a:	200c      	movs	r0, #12
 800271c:	f004 fa56 	bl	8006bcc <_Znwj>
 8002720:	4941      	ldr	r1, [pc, #260]	; (8002828 <main+0x12c>)
 8002722:	4604      	mov	r4, r0
 8002724:	f7ff fed0 	bl	80024c8 <_ZN10UartDriverI18UART_HandleTypeDefLi50ELi250ELi400ELi8EEC1EPS0_>
 8002728:	4d40      	ldr	r5, [pc, #256]	; (800282c <main+0x130>)
 800272a:	6820      	ldr	r0, [r4, #0]
  }
  ~UartDriver(){}

  void begin(uint32_t baud_rate)
  {
    huart_->Init.BaudRate = baud_rate;
 800272c:	68eb      	ldr	r3, [r5, #12]
  }

  int getBaud(){return baud_;}

  void init(serial_class* huart){
    iostream_ = new UartDriver<serial_class>(huart);
 800272e:	60ac      	str	r4, [r5, #8]
  }
  ~UartDriver(){}

  void begin(uint32_t baud_rate)
  {
    huart_->Init.BaudRate = baud_rate;
 8002730:	6043      	str	r3, [r0, #4]
    HAL_UART_Init(huart_);
 8002732:	f003 f95f 	bl	80059f4 <HAL_UART_Init>
    }

    /* Start a named seiral port */
    void initNode(typename Hardware::serial_class* port){
      hardware_.init(port);
      mode_ = 0;
 8002736:	2600      	movs	r6, #0
  /* USER CODE BEGIN 2 */
  /**********************************/
  {
	  nh_.initNode(&huart1);
	  /* ugv ros node */
	  testnode = new RosNode(&nh_);
 8002738:	2070      	movs	r0, #112	; 0x70
 800273a:	f8c5 62bc 	str.w	r6, [r5, #700]	; 0x2bc
      bytes_ = 0;
 800273e:	f8c5 62c0 	str.w	r6, [r5, #704]	; 0x2c0
      index_ = 0;
 8002742:	f8c5 62c8 	str.w	r6, [r5, #712]	; 0x2c8
      topic_ = 0;
 8002746:	f8c5 62c4 	str.w	r6, [r5, #708]	; 0x2c4
 800274a:	f004 fa3f 	bl	8006bcc <_Znwj>
  {
    public:
      int8_t data;

    Int8():
      data(0)
 800274e:	4b38      	ldr	r3, [pc, #224]	; (8002830 <main+0x134>)
 8002750:	60c3      	str	r3, [r0, #12]
      geometry_msgs::Vector3 linear;
      geometry_msgs::Vector3 angular;

    Twist():
      linear(),
      angular()
 8002752:	4b38      	ldr	r3, [pc, #224]	; (8002834 <main+0x138>)
 8002754:	6183      	str	r3, [r0, #24]
      double z;

    Vector3():
      x(0),
      y(0),
      z(0)
 8002756:	2200      	movs	r2, #0
 8002758:	2300      	movs	r3, #0
 800275a:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
 800275e:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
 8002762:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
 8002766:	e9c0 2312 	strd	r2, r3, [r0, #72]	; 0x48
 800276a:	e9c0 2314 	strd	r2, r3, [r0, #80]	; 0x50
 800276e:	e9c0 2316 	strd	r2, r3, [r0, #88]	; 0x58

class RosNode
{
public:
	RosNode(ros::NodeHandle* nh)
{
 8002772:	2300      	movs	r3, #0
 8002774:	4930      	ldr	r1, [pc, #192]	; (8002838 <main+0x13c>)
 8002776:	6603      	str	r3, [r0, #96]	; 0x60
 8002778:	6643      	str	r3, [r0, #100]	; 0x64
 800277a:	f649 6334 	movw	r3, #40500	; 0x9e34
 800277e:	4604      	mov	r4, r0
 8002780:	7406      	strb	r6, [r0, #16]
 8002782:	6201      	str	r1, [r0, #32]
 8002784:	6401      	str	r1, [r0, #64]	; 0x40
 8002786:	f8a0 3068 	strh.w	r3, [r0, #104]	; 0x68
 800278a:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
		/* ros node initialize */
		nh_ = nh;
 800278e:	6005      	str	r5, [r0, #0]

		/* ros publisher initialize */
		radioflag_pub_ = new ros::Publisher("radioflag",&radioflag_msg);
 8002790:	2014      	movs	r0, #20
 8002792:	f004 fa1b 	bl	8006bcc <_Znwj>
 8002796:	4b29      	ldr	r3, [pc, #164]	; (800283c <main+0x140>)
 8002798:	6003      	str	r3, [r0, #0]
 800279a:	f104 030c 	add.w	r3, r4, #12
 800279e:	6043      	str	r3, [r0, #4]
 80027a0:	6106      	str	r6, [r0, #16]
 80027a2:	6060      	str	r0, [r4, #4]
		odom_pub_ = new ros::Publisher("odometry/raw",&odom_msg);
 80027a4:	2014      	movs	r0, #20
 80027a6:	f004 fa11 	bl	8006bcc <_Znwj>
 80027aa:	4b25      	ldr	r3, [pc, #148]	; (8002840 <main+0x144>)
 80027ac:	6003      	str	r3, [r0, #0]
 80027ae:	2600      	movs	r6, #0
 80027b0:	f104 0318 	add.w	r3, r4, #24
 80027b4:	6043      	str	r3, [r0, #4]
 80027b6:	60a0      	str	r0, [r4, #8]
 80027b8:	6106      	str	r6, [r0, #16]
		//publish the msgs
		nh_->advertise(*radioflag_pub_);
 80027ba:	e894 0003 	ldmia.w	r4, {r0, r1}
 80027be:	f7ff fef1 	bl	80025a4 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE9advertiseERNS_9PublisherE>
		nh_->advertise(*odom_pub_);
 80027c2:	68a1      	ldr	r1, [r4, #8]
 80027c4:	6820      	ldr	r0, [r4, #0]
	  /* Sensors */
#if IMU_FLAG
	  imu_.init(&hspi1, &nh_);
 80027c6:	4c1f      	ldr	r4, [pc, #124]	; (8002844 <main+0x148>)
 80027c8:	f7ff feec 	bl	80025a4 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE9advertiseERNS_9PublisherE>
 80027cc:	f5a4 7243 	sub.w	r2, r4, #780	; 0x30c
 80027d0:	491d      	ldr	r1, [pc, #116]	; (8002848 <main+0x14c>)
 80027d2:	4620      	mov	r0, r4
 80027d4:	f001 f874 	bl	80038c0 <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE>
      }
    else
      {
        attitude_estimate_flag_ = true;
        imu_ = imu;
        attitude_estimator_.init(imu_, nh_);
 80027d8:	f5a4 7243 	sub.w	r2, r4, #780	; 0x30c
      {
        attitude_estimate_flag_ = false;
      }
    else
      {
        attitude_estimate_flag_ = true;
 80027dc:	2701      	movs	r7, #1
        imu_ = imu;
        attitude_estimator_.init(imu_, nh_);
 80027de:	4621      	mov	r1, r4
 80027e0:	f502 6086 	add.w	r0, r2, #1072	; 0x430
  }
  ~StateEstimate(){}

void  init(IMU* imu, Baro* baro, GPS* gps, ros::NodeHandle* nh)
  {
    nh_ = nh;
 80027e4:	f8c5 5420 	str.w	r5, [r5, #1056]	; 0x420
      {
        attitude_estimate_flag_ = false;
      }
    else
      {
        attitude_estimate_flag_ = true;
 80027e8:	f885 74dc 	strb.w	r7, [r5, #1244]	; 0x4dc
        imu_ = imu;
 80027ec:	f8c5 4424 	str.w	r4, [r5, #1060]	; 0x424
        attitude_estimator_.init(imu_, nh_);
 80027f0:	f7ff feee 	bl	80025d0 <_ZN16AttitudeEstimate4initEP3IMUPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE>
      }

    if(baro == NULL)
      {
        altitude_estimate_flag_ = false;
 80027f4:	f885 64dd 	strb.w	r6, [r5, #1245]	; 0x4dd
        altitude_estimator_.init(imu_, baro_, nh_);
      }

    if(gps == NULL)
      {
        pos_estimate_flag_ = false;
 80027f8:	f885 64de 	strb.w	r6, [r5, #1246]	; 0x4de
	  /* State Estimation */
	  estimator_.init(&imu_, NULL, NULL, &nh_);  // imu  => att
#endif

	  /* all process can start right now! */
	  start_process_flag_ = true;
 80027fc:	f885 74e0 	strb.w	r7, [r5, #1248]	; 0x4e0
 8002800:	e003      	b.n	800280a <main+0x10e>
 8002802:	e00c      	b.n	800281e <main+0x122>
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
	  if(start_process_flag_)
		  HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13);
	  HAL_Delay(100);
 8002804:	2064      	movs	r0, #100	; 0x64
 8002806:	f001 fc15 	bl	8004034 <HAL_Delay>
  while (1)
  {
  /* USER CODE END WHILE */

  /* USER CODE BEGIN 3 */
	  if(start_process_flag_)
 800280a:	f895 34e0 	ldrb.w	r3, [r5, #1248]	; 0x4e0
 800280e:	2b00      	cmp	r3, #0
 8002810:	d0f8      	beq.n	8002804 <main+0x108>
		  HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13);
 8002812:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8002816:	480d      	ldr	r0, [pc, #52]	; (800284c <main+0x150>)
 8002818:	f002 f9ec 	bl	8004bf4 <HAL_GPIO_TogglePin>
 800281c:	e7f2      	b.n	8002804 <main+0x108>
  /* USER CODE BEGIN 2 */
  /**********************************/
  {
	  nh_.initNode(&huart1);
	  /* ugv ros node */
	  testnode = new RosNode(&nh_);
 800281e:	4620      	mov	r0, r4
 8002820:	f004 fb1e 	bl	8006e60 <_ZdlPv>
 8002824:	f003 fe80 	bl	8006528 <__cxa_end_cleanup>
 8002828:	20003c9c 	.word	0x20003c9c
 800282c:	20000530 	.word	0x20000530
 8002830:	08008d54 	.word	0x08008d54
 8002834:	08008d84 	.word	0x08008d84
 8002838:	08008d6c 	.word	0x08008d6c
 800283c:	08009086 	.word	0x08009086
 8002840:	08009090 	.word	0x08009090
 8002844:	2000083c 	.word	0x2000083c
 8002848:	20003b84 	.word	0x20003b84
 800284c:	40020800 	.word	0x40020800

08002850 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE3nowEv>:

      this->setNow(t.data);
      last_sync_receive_time = hardware_.time();
    }

    Time now()
 8002850:	b538      	push	{r3, r4, r5, lr}
 8002852:	460d      	mov	r5, r1
 8002854:	4604      	mov	r4, r0

  void write(uint8_t* data, int length){
    iostream_->write(data, length);
  }

  uint32_t time(){return HAL_GetTick();}
 8002856:	f001 fbe7 	bl	8004028 <HAL_GetTick>
    {
      uint32_t ms = hardware_.time();
      Time current_time;
      current_time.sec = ms/1000 + sec_offset;
 800285a:	696a      	ldr	r2, [r5, #20]
 800285c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8002860:	fbb0 f3f1 	udiv	r3, r0, r1
 8002864:	441a      	add	r2, r3
      current_time.nsec = (ms%1000)*1000000UL + nsec_offset;
 8002866:	fb01 0013 	mls	r0, r1, r3, r0

    Time now()
    {
      uint32_t ms = hardware_.time();
      Time current_time;
      current_time.sec = ms/1000 + sec_offset;
 800286a:	6022      	str	r2, [r4, #0]
      current_time.nsec = (ms%1000)*1000000UL + nsec_offset;
 800286c:	69ab      	ldr	r3, [r5, #24]
 800286e:	4a05      	ldr	r2, [pc, #20]	; (8002884 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE3nowEv+0x34>)
 8002870:	4621      	mov	r1, r4
 8002872:	fb02 3300 	mla	r3, r2, r0, r3
 8002876:	f841 3f04 	str.w	r3, [r1, #4]!
      normalizeSecNSec(current_time.sec, current_time.nsec);
 800287a:	4620      	mov	r0, r4
 800287c:	f001 fb6a 	bl	8003f54 <_ZN3ros16normalizeSecNSecERmS0_>
      return current_time;
    }
 8002880:	4620      	mov	r0, r4
 8002882:	bd38      	pop	{r3, r4, r5, pc}
 8002884:	000f4240 	.word	0x000f4240

08002888 <_ZN16AttitudeEstimate7publishEv>:
      }

  }

  /* send message via ros protocal */
  void publish()
 8002888:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800288c:	4604      	mov	r4, r0
 800288e:	b09e      	sub	sp, #120	; 0x78
  {
    uint32_t now_time = HAL_GetTick();
 8002890:	f001 fbca 	bl	8004028 <HAL_GetTick>
    if( now_time - last_pub_time_ >= PUB_INTERVAL)
 8002894:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8002896:	1ac3      	subs	r3, r0, r3
 8002898:	2b01      	cmp	r3, #1
 800289a:	d957      	bls.n	800294c <_ZN16AttitudeEstimate7publishEv+0xc4>
      {
        last_pub_time_ = now_time;
        imu_msg_.stamp = nh_->now();
 800289c:	4625      	mov	r5, r4
  void publish()
  {
    uint32_t now_time = HAL_GetTick();
    if( now_time - last_pub_time_ >= PUB_INTERVAL)
      {
        last_pub_time_ = now_time;
 800289e:	6520      	str	r0, [r4, #80]	; 0x50
        imu_msg_.stamp = nh_->now();
 80028a0:	f855 1b0c 	ldr.w	r1, [r5], #12
 80028a4:	4668      	mov	r0, sp
 80028a6:	f7ff ffd3 	bl	8002850 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE3nowEv>
 80028aa:	e89d 0003 	ldmia.w	sp, {r0, r1}
 80028ae:	e885 0003 	stmia.w	r5, {r0, r1}
 80028b2:	4626      	mov	r6, r4
 80028b4:	f04f 0e00 	mov.w	lr, #0
#if 0 //virtual coord
            imu_msg_.gyro_data[i] = estimator_->getGyroV()[i];
            imu_msg_.mag_data[i] = estimator_->getMagV()[i];
            imu_msg_.acc_data[i] = estimator_->getAccV()[i];
#else //raw data
            imu_msg_.gyro_data[i] = imu_->getGyro()[i];
 80028b8:	ab03      	add	r3, sp, #12
 80028ba:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
	static const uint8_t RESET_CALIB_CMD = 0x00;
	static const uint8_t MPU_ACC_GYRO_CALIB_CMD = 0x01;
	static const uint8_t MPU_MAG_CALIB_CMD = 0x02;

	Vector3f  getAcc(){return acc_;}
	Vector3f  getGyro(){return gyro_;}
 80028bc:	f105 0294 	add.w	r2, r5, #148	; 0x94
 80028c0:	ca07      	ldmia	r2, {r0, r1, r2}
 80028c2:	f10d 0c6c 	add.w	ip, sp, #108	; 0x6c
 80028c6:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
 80028ca:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 80028ce:	eb03 0c0e 	add.w	ip, r3, lr
 80028d2:	af18      	add	r7, sp, #96	; 0x60
 80028d4:	e887 0007 	stmia.w	r7, {r0, r1, r2}
 80028d8:	f8dc 2000 	ldr.w	r2, [ip]
 80028dc:	6232      	str	r2, [r6, #32]
	Vector3f  getMag(){return mag_;}
 80028de:	f105 02a0 	add.w	r2, r5, #160	; 0xa0
 80028e2:	ca07      	ldmia	r2, {r0, r1, r2}
            imu_msg_.mag_data[i] = imu_->getMag()[i];
 80028e4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 80028e8:	af12      	add	r7, sp, #72	; 0x48
 80028ea:	f10d 0854 	add.w	r8, sp, #84	; 0x54
 80028ee:	e887 0007 	stmia.w	r7, {r0, r1, r2}
 80028f2:	e888 0007 	stmia.w	r8, {r0, r1, r2}
 80028f6:	f8dc 2000 	ldr.w	r2, [ip]
 80028fa:	62f2      	str	r2, [r6, #44]	; 0x2c
	/* calibration cmd form ROS */
	static const uint8_t RESET_CALIB_CMD = 0x00;
	static const uint8_t MPU_ACC_GYRO_CALIB_CMD = 0x01;
	static const uint8_t MPU_MAG_CALIB_CMD = 0x02;

	Vector3f  getAcc(){return acc_;}
 80028fc:	3588      	adds	r5, #136	; 0x88
 80028fe:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8002902:	af0f      	add	r7, sp, #60	; 0x3c
 8002904:	e887 0007 	stmia.w	r7, {r0, r1, r2}
            imu_msg_.acc_data[i] = imu_->getAcc()[i];
 8002908:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800290c:	ad0c      	add	r5, sp, #48	; 0x30
 800290e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 8002912:	f8dc 2000 	ldr.w	r2, [ip]
 8002916:	6172      	str	r2, [r6, #20]
  static const uint8_t RELATIVE_COORD = 1;
  static const uint8_t X = 0;
  static const uint8_t Y = 1;
  static const uint8_t Z = 2;

  Vector3f getAngles(){return rpy_;}
 8002918:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800291a:	3270      	adds	r2, #112	; 0x70
 800291c:	ca07      	ldmia	r2, {r0, r1, r2}
#endif
            imu_msg_.angles[i] = estimator_->getAngles()[i];
 800291e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8002922:	af09      	add	r7, sp, #36	; 0x24
 8002924:	ad06      	add	r5, sp, #24
 8002926:	f10e 0e04 	add.w	lr, lr, #4
 800292a:	e887 0007 	stmia.w	r7, {r0, r1, r2}
 800292e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    uint32_t now_time = HAL_GetTick();
    if( now_time - last_pub_time_ >= PUB_INTERVAL)
      {
        last_pub_time_ = now_time;
        imu_msg_.stamp = nh_->now();
        for(int i = 0; i < 3 ; i ++)
 8002932:	f1be 0f0c 	cmp.w	lr, #12
#else //raw data
            imu_msg_.gyro_data[i] = imu_->getGyro()[i];
            imu_msg_.mag_data[i] = imu_->getMag()[i];
            imu_msg_.acc_data[i] = imu_->getAcc()[i];
#endif
            imu_msg_.angles[i] = estimator_->getAngles()[i];
 8002936:	f8dc 2000 	ldr.w	r2, [ip]
 800293a:	63b2      	str	r2, [r6, #56]	; 0x38
 800293c:	f106 0604 	add.w	r6, r6, #4
    uint32_t now_time = HAL_GetTick();
    if( now_time - last_pub_time_ >= PUB_INTERVAL)
      {
        last_pub_time_ = now_time;
        imu_msg_.stamp = nh_->now();
        for(int i = 0; i < 3 ; i ++)
 8002940:	d1bb      	bne.n	80028ba <_ZN16AttitudeEstimate7publishEv+0x32>
            imu_msg_.acc_data[i] = imu_->getAcc()[i];
#endif
            imu_msg_.angles[i] = estimator_->getAngles()[i];
          }

        imu_pub_->publish(&imu_msg_);
 8002942:	f104 0108 	add.w	r1, r4, #8
 8002946:	6860      	ldr	r0, [r4, #4]
 8002948:	f7ff fd28 	bl	800239c <_ZN3ros9Publisher7publishEPKNS_3MsgE>
      }
  }
 800294c:	b01e      	add	sp, #120	; 0x78
 800294e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002952 <_ZN13StateEstimate6updateEv>:
        gps_ = gps;
        pos_estimator_.init(imu_, gps_, nh_);
      }
  }

  void update()
 8002952:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  {
    if(attitude_estimate_flag_) attitude_estimator_.update();
 8002956:	f890 30bc 	ldrb.w	r3, [r0, #188]	; 0xbc
        gps_ = gps;
        pos_estimator_.init(imu_, gps_, nh_);
      }
  }

  void update()
 800295a:	b09e      	sub	sp, #120	; 0x78
 800295c:	4604      	mov	r4, r0
  {
    if(attitude_estimate_flag_) attitude_estimator_.update();
 800295e:	2b00      	cmp	r3, #0
 8002960:	d074      	beq.n	8002a4c <_ZN13StateEstimate6updateEv+0xfa>
  }

  void update()
  {

    if(imu_->getUpdate())
 8002962:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8002964:	f890 3110 	ldrb.w	r3, [r0, #272]	; 0x110
 8002968:	2b00      	cmp	r3, #0
 800296a:	d06f      	beq.n	8002a4c <_ZN13StateEstimate6updateEv+0xfa>
      {
        /* attitude estimation */
        if(!imu_->getCalibrated()) return;
 800296c:	f000 fe4c 	bl	8003608 <_ZN3IMU13getCalibratedEv>
 8002970:	2800      	cmp	r0, #0
 8002972:	d06b      	beq.n	8002a4c <_ZN13StateEstimate6updateEv+0xfa>
        estimator_->update(imu_->getGyro(), imu_->getAcc(), imu_->getMag());
 8002974:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8002976:	6da5      	ldr	r5, [r4, #88]	; 0x58
	Vector3f  getGyro(){return gyro_;}
 8002978:	f103 0294 	add.w	r2, r3, #148	; 0x94
 800297c:	ca07      	ldmia	r2, {r0, r1, r2}
 800297e:	ae1b      	add	r6, sp, #108	; 0x6c
 8002980:	e886 0007 	stmia.w	r6, {r0, r1, r2}
 8002984:	af18      	add	r7, sp, #96	; 0x60
 8002986:	ae09      	add	r6, sp, #36	; 0x24
 8002988:	e887 0007 	stmia.w	r7, {r0, r1, r2}
 800298c:	e886 0007 	stmia.w	r6, {r0, r1, r2}
	/* calibration cmd form ROS */
	static const uint8_t RESET_CALIB_CMD = 0x00;
	static const uint8_t MPU_ACC_GYRO_CALIB_CMD = 0x01;
	static const uint8_t MPU_MAG_CALIB_CMD = 0x02;

	Vector3f  getAcc(){return acc_;}
 8002990:	f103 0288 	add.w	r2, r3, #136	; 0x88
 8002994:	ca07      	ldmia	r2, {r0, r1, r2}
 8002996:	af15      	add	r7, sp, #84	; 0x54
 8002998:	e887 0007 	stmia.w	r7, {r0, r1, r2}
 800299c:	f10d 0e48 	add.w	lr, sp, #72	; 0x48
 80029a0:	af06      	add	r7, sp, #24
	Vector3f  getGyro(){return gyro_;}
	Vector3f  getMag(){return mag_;}
 80029a2:	33a0      	adds	r3, #160	; 0xa0
 80029a4:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
 80029a8:	e887 0007 	stmia.w	r7, {r0, r1, r2}
 80029ac:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80029b0:	f10d 0c3c 	add.w	ip, sp, #60	; 0x3c
 80029b4:	ab03      	add	r3, sp, #12
 80029b6:	f10d 0e30 	add.w	lr, sp, #48	; 0x30
 80029ba:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
 80029be:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
 80029c2:	e883 0007 	stmia.w	r3, {r0, r1, r2}


  void update(const Vector3f& gyro, const Vector3f& acc, const Vector3f& mag)
  {
    /* the sensor data in body frame */
    acc_b_ = acc;
 80029c6:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 80029ca:	f105 0e04 	add.w	lr, r5, #4
 80029ce:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
    gyro_b_ = gyro;
 80029d2:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 80029d6:	f105 071c 	add.w	r7, r5, #28
 80029da:	e887 0007 	stmia.w	r7, {r0, r1, r2}
    mag_b_ = mag;
 80029de:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

    /* the sensor data in virtual frame */
    acc_v_ = r_* acc_b_;
 80029e2:	f105 084c 	add.w	r8, r5, #76	; 0x4c
  void update(const Vector3f& gyro, const Vector3f& acc, const Vector3f& mag)
  {
    /* the sensor data in body frame */
    acc_b_ = acc;
    gyro_b_ = gyro;
    mag_b_ = mag;
 80029e6:	f105 0634 	add.w	r6, r5, #52	; 0x34
 80029ea:	e886 0007 	stmia.w	r6, {r0, r1, r2}

    /* the sensor data in virtual frame */
    acc_v_ = r_* acc_b_;
 80029ee:	4671      	mov	r1, lr
 80029f0:	4640      	mov	r0, r8
 80029f2:	f003 fcdf 	bl	80063b4 <_ZNK7Matrix3IfEmlERK7Vector3IfE>
    gyro_v_ = r_*  gyro_b_;
 80029f6:	4639      	mov	r1, r7
    acc_b_ = acc;
    gyro_b_ = gyro;
    mag_b_ = mag;

    /* the sensor data in virtual frame */
    acc_v_ = r_* acc_b_;
 80029f8:	ed85 0a04 	vstr	s0, [r5, #16]
 80029fc:	edc5 0a05 	vstr	s1, [r5, #20]
 8002a00:	ed85 1a06 	vstr	s2, [r5, #24]
    gyro_v_ = r_*  gyro_b_;
 8002a04:	4640      	mov	r0, r8
 8002a06:	f003 fcd5 	bl	80063b4 <_ZNK7Matrix3IfEmlERK7Vector3IfE>
    mag_v_ = r_ * mag_b_;
 8002a0a:	4631      	mov	r1, r6
    gyro_b_ = gyro;
    mag_b_ = mag;

    /* the sensor data in virtual frame */
    acc_v_ = r_* acc_b_;
    gyro_v_ = r_*  gyro_b_;
 8002a0c:	ed85 0a0a 	vstr	s0, [r5, #40]	; 0x28
 8002a10:	edc5 0a0b 	vstr	s1, [r5, #44]	; 0x2c
 8002a14:	ed85 1a0c 	vstr	s2, [r5, #48]	; 0x30
    mag_v_ = r_ * mag_b_;
 8002a18:	4640      	mov	r0, r8
 8002a1a:	f003 fccb 	bl	80063b4 <_ZNK7Matrix3IfEmlERK7Vector3IfE>
    arm_mat_mult_f32(&desire_attitude_R_, &acc_b_vec_, &acc_v_vec_);
    arm_mat_mult_f32(&desire_attitude_R_, &gyro_b_vec_, &gyro_v_vec_);
    arm_mat_mult_f32(&desire_attitude_R_, &mag_b_vec_, &mag_v_vec_);
    */

    estimation();
 8002a1e:	682b      	ldr	r3, [r5, #0]
    mag_b_ = mag;

    /* the sensor data in virtual frame */
    acc_v_ = r_* acc_b_;
    gyro_v_ = r_*  gyro_b_;
    mag_v_ = r_ * mag_b_;
 8002a20:	ed85 0a10 	vstr	s0, [r5, #64]	; 0x40
    arm_mat_mult_f32(&desire_attitude_R_, &acc_b_vec_, &acc_v_vec_);
    arm_mat_mult_f32(&desire_attitude_R_, &gyro_b_vec_, &gyro_v_vec_);
    arm_mat_mult_f32(&desire_attitude_R_, &mag_b_vec_, &mag_v_vec_);
    */

    estimation();
 8002a24:	681b      	ldr	r3, [r3, #0]
    mag_b_ = mag;

    /* the sensor data in virtual frame */
    acc_v_ = r_* acc_b_;
    gyro_v_ = r_*  gyro_b_;
    mag_v_ = r_ * mag_b_;
 8002a26:	edc5 0a11 	vstr	s1, [r5, #68]	; 0x44
    arm_mat_mult_f32(&desire_attitude_R_, &acc_b_vec_, &acc_v_vec_);
    arm_mat_mult_f32(&desire_attitude_R_, &gyro_b_vec_, &gyro_v_vec_);
    arm_mat_mult_f32(&desire_attitude_R_, &mag_b_vec_, &mag_v_vec_);
    */

    estimation();
 8002a2a:	4628      	mov	r0, r5
    mag_b_ = mag;

    /* the sensor data in virtual frame */
    acc_v_ = r_* acc_b_;
    gyro_v_ = r_*  gyro_b_;
    mag_v_ = r_ * mag_b_;
 8002a2c:	ed85 1a12 	vstr	s2, [r5, #72]	; 0x48
    arm_mat_mult_f32(&desire_attitude_R_, &acc_b_vec_, &acc_v_vec_);
    arm_mat_mult_f32(&desire_attitude_R_, &gyro_b_vec_, &gyro_v_vec_);
    arm_mat_mult_f32(&desire_attitude_R_, &mag_b_vec_, &mag_v_vec_);
    */

    estimation();
 8002a30:	4798      	blx	r3

        /* send message to ros*/
        if(nh_->connected())  publish();
 8002a32:	6920      	ldr	r0, [r4, #16]
 8002a34:	6803      	ldr	r3, [r0, #0]
 8002a36:	689b      	ldr	r3, [r3, #8]
 8002a38:	4798      	blx	r3
 8002a3a:	b118      	cbz	r0, 8002a44 <_ZN13StateEstimate6updateEv+0xf2>
 8002a3c:	f104 0010 	add.w	r0, r4, #16
 8002a40:	f7ff ff22 	bl	8002888 <_ZN16AttitudeEstimate7publishEv>
	//void update();
	uint16_t update(uint16_t queue_size = DEFAULT_DATA_SIZE);
	void ledOutput();

	bool getUpdate() { return update_; }
	void setUpdate(bool update) { update_ = update; }
 8002a44:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8002a46:	2200      	movs	r2, #0
 8002a48:	f883 2110 	strb.w	r2, [r3, #272]	; 0x110
    if(altitude_estimate_flag_) altitude_estimator_.update();
 8002a4c:	f894 30bd 	ldrb.w	r3, [r4, #189]	; 0xbd
 8002a50:	b30b      	cbz	r3, 8002a96 <_ZN13StateEstimate6updateEv+0x144>
 8002a52:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    baro_= baro;
  }

  void update()
  {
    if(baro_->getUpdate())
 8002a56:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8002a5a:	b1e3      	cbz	r3, 8002a96 <_ZN13StateEstimate6updateEv+0x144>
  //nav-ekf


  void publish()
  {
    baro_msg_.stamp = nh_->now();
 8002a5c:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8002a5e:	4668      	mov	r0, sp
 8002a60:	f7ff fef6 	bl	8002850 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE3nowEv>
 8002a64:	e89d 0003 	ldmia.w	sp, {r0, r1}
 8002a68:	f104 0370 	add.w	r3, r4, #112	; 0x70
 8002a6c:	e883 0003 	stmia.w	r3, {r0, r1}
    baro_msg_.pressure = baro_->getPressure();
 8002a70:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    baro_msg_.temperature = baro_->getTemperature();
    baro_msg_.altitude = baro_->getAltitude();
    baro_pub_->publish(&baro_msg_);
 8002a74:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8002a76:	681a      	ldr	r2, [r3, #0]


  void publish()
  {
    baro_msg_.stamp = nh_->now();
    baro_msg_.pressure = baro_->getPressure();
 8002a78:	67e2      	str	r2, [r4, #124]	; 0x7c
 8002a7a:	689a      	ldr	r2, [r3, #8]
    baro_msg_.temperature = baro_->getTemperature();
 8002a7c:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
 8002a80:	68db      	ldr	r3, [r3, #12]
    baro_msg_.altitude = baro_->getAltitude();
 8002a82:	67a3      	str	r3, [r4, #120]	; 0x78
    baro_pub_->publish(&baro_msg_);
 8002a84:	f104 016c 	add.w	r1, r4, #108	; 0x6c
 8002a88:	f7ff fc88 	bl	800239c <_ZN3ros9Publisher7publishEPKNS_3MsgE>
  float getClimbRate(void);
  // get last time sample was taken (in ms)
  uint32_t getLastUpdate(void) const { return last_timer_; }

  bool getUpdate() { return update_; }
  void setUpdate(bool update) { update_ = update; }
 8002a8c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8002a90:	2200      	movs	r2, #0
 8002a92:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    if(pos_estimate_flag_) pos_estimator_.update();
 8002a96:	f894 30be 	ldrb.w	r3, [r4, #190]	; 0xbe
 8002a9a:	b3b3      	cbz	r3, 8002b0a <_ZN13StateEstimate6updateEv+0x1b8>
 8002a9c:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
    gps_ = gps;
  }

  void update()
  {
    if(gps_->getUpdate())
 8002aa0:	f893 3072 	ldrb.w	r3, [r3, #114]	; 0x72
 8002aa4:	b38b      	cbz	r3, 8002b0a <_ZN13StateEstimate6updateEv+0x1b8>
  GPS* gps_;
  //nav-ekf2

  void publish()
  {
    gps_msg_.stamp = nh_->now();
 8002aa6:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 8002aaa:	4668      	mov	r0, sp
 8002aac:	f7ff fed0 	bl	8002850 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE3nowEv>
 8002ab0:	e89d 0003 	ldmia.w	sp, {r0, r1}
 8002ab4:	f104 0398 	add.w	r3, r4, #152	; 0x98
 8002ab8:	e883 0003 	stmia.w	r3, {r0, r1}

    gps_msg_.location[0] = gps_->getGosState().location.lat; // lat
 8002abc:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
    gps_msg_.velocity[0] = gps_->getGosState().velocity.x;
    gps_msg_.velocity[1] = gps_->getGosState().velocity.y;

    gps_msg_.sat_num = gps_->getGosState().num_sats;

    gps_pub_->publish(&gps_msg_);
 8002ac0:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
  virtual bool is_configured(void) { return true; }
  virtual void inject_data(uint8_t *data, uint8_t len) { return; }

  GPS_State getGosState()
  {
    return state;
 8002ac4:	f8d3 201e 	ldr.w	r2, [r3, #30]
 8002ac8:	ee07 2a90 	vmov	s15, r2

  void publish()
  {
    gps_msg_.stamp = nh_->now();

    gps_msg_.location[0] = gps_->getGosState().location.lat; // lat
 8002acc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    gps_msg_.velocity[0] = gps_->getGosState().velocity.x;
    gps_msg_.velocity[1] = gps_->getGosState().velocity.y;

    gps_msg_.sat_num = gps_->getGosState().num_sats;

    gps_pub_->publish(&gps_msg_);
 8002ad0:	f104 0194 	add.w	r1, r4, #148	; 0x94

  void publish()
  {
    gps_msg_.stamp = nh_->now();

    gps_msg_.location[0] = gps_->getGosState().location.lat; // lat
 8002ad4:	edc4 7a28 	vstr	s15, [r4, #160]	; 0xa0
 8002ad8:	f8d3 2022 	ldr.w	r2, [r3, #34]	; 0x22
 8002adc:	ee07 2a90 	vmov	s15, r2
    gps_msg_.location[1] = gps_->getGosState().location.lng; // lng
 8002ae0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002ae4:	edc4 7a29 	vstr	s15, [r4, #164]	; 0xa4
 8002ae8:	6b9a      	ldr	r2, [r3, #56]	; 0x38

    gps_msg_.velocity[0] = gps_->getGosState().velocity.x;
 8002aea:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
 8002aee:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    gps_msg_.velocity[1] = gps_->getGosState().velocity.y;
 8002af0:	f8c4 20ac 	str.w	r2, [r4, #172]	; 0xac
 8002af4:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34

    gps_msg_.sat_num = gps_->getGosState().num_sats;
 8002af8:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0

    gps_pub_->publish(&gps_msg_);
 8002afc:	f7ff fc4e 	bl	800239c <_ZN3ros9Publisher7publishEPKNS_3MsgE>
  {
    return (uint16_t)GPS_RX_SIZE;
  }

  bool getUpdate() { return update_; }
  void setUpdate(bool update) { update_ = update; }
 8002b00:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 8002b04:	2200      	movs	r2, #0
 8002b06:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72
  }
 8002b0a:	b01e      	add	sp, #120	; 0x78
 8002b0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002b10 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh>:
          }
        __HAL_DMA_CLEAR_FLAG(huart->hdmatx, __HAL_DMA_GET_TC_FLAG_INDEX(huart->hdmatx));
      }
  }

  void write(uint8_t * new_data, uint8_t new_size)
 8002b10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  {
    //if (subscript_in_progress_ == subscript_to_add_) idle_flag_= false;

    //if subscript comes around and get to one in progress_, then wait.
    if (subscript_in_progress_ == subscript_to_add_ + 1 || ( subscript_to_add_ == TX_SIZE - 1 && subscript_in_progress_ == 0) )
 8002b14:	4b51      	ldr	r3, [pc, #324]	; (8002c5c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x14c>)
 8002b16:	4d52      	ldr	r5, [pc, #328]	; (8002c60 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x150>)
 8002b18:	781c      	ldrb	r4, [r3, #0]
 8002b1a:	782b      	ldrb	r3, [r5, #0]
          }
        __HAL_DMA_CLEAR_FLAG(huart->hdmatx, __HAL_DMA_GET_TC_FLAG_INDEX(huart->hdmatx));
      }
  }

  void write(uint8_t * new_data, uint8_t new_size)
 8002b1c:	4607      	mov	r7, r0
  {
    //if (subscript_in_progress_ == subscript_to_add_) idle_flag_= false;

    //if subscript comes around and get to one in progress_, then wait.
    if (subscript_in_progress_ == subscript_to_add_ + 1 || ( subscript_to_add_ == TX_SIZE - 1 && subscript_in_progress_ == 0) )
 8002b1e:	1c5e      	adds	r6, r3, #1
 8002b20:	42b4      	cmp	r4, r6
 8002b22:	d0fd      	beq.n	8002b20 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x10>
 8002b24:	2b31      	cmp	r3, #49	; 0x31
 8002b26:	d101      	bne.n	8002b2c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x1c>
 8002b28:	2c00      	cmp	r4, #0
 8002b2a:	d0f9      	beq.n	8002b20 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x10>
		while(subscript_in_progress_ == subscript_to_add_ + 1 || ( subscript_to_add_ == TX_SIZE - 1 && subscript_in_progress_ == 0)){}
      //  return;
      }


    tx_buffer_unit_[subscript_to_add_].tx_len_ = new_size;
 8002b2c:	f8df 8150 	ldr.w	r8, [pc, #336]	; 8002c80 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x170>
 8002b30:	20fb      	movs	r0, #251	; 0xfb
 8002b32:	fb00 8003 	mla	r0, r0, r3, r8
    memcpy(tx_buffer_unit_[subscript_to_add_].tx_data_, new_data, new_size);

    //speed slows down?
    //memcpy(tx_data_[subscript_to_add_], new_data, new_size);

    subscript_to_add_++;
 8002b36:	b2f6      	uxtb	r6, r6
		while(subscript_in_progress_ == subscript_to_add_ + 1 || ( subscript_to_add_ == TX_SIZE - 1 && subscript_in_progress_ == 0)){}
      //  return;
      }


    tx_buffer_unit_[subscript_to_add_].tx_len_ = new_size;
 8002b38:	f880 20fa 	strb.w	r2, [r0, #250]	; 0xfa
    memcpy(tx_buffer_unit_[subscript_to_add_].tx_data_, new_data, new_size);
 8002b3c:	f005 fb74 	bl	8008228 <memcpy>
    //memcpy(tx_data_[subscript_to_add_], new_data, new_size);

    subscript_to_add_++;

    //if subscript reaches end make to go back to front
    if (subscript_to_add_ == TX_SIZE)
 8002b40:	2e32      	cmp	r6, #50	; 0x32
      subscript_to_add_ = 0;
 8002b42:	bf04      	itt	eq
 8002b44:	2300      	moveq	r3, #0
 8002b46:	702b      	strbeq	r3, [r5, #0]

    // enable and start DMA transfer
    if (idle_flag_ )
 8002b48:	4b46      	ldr	r3, [pc, #280]	; (8002c64 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x154>)
    memcpy(tx_buffer_unit_[subscript_to_add_].tx_data_, new_data, new_size);

    //speed slows down?
    //memcpy(tx_data_[subscript_to_add_], new_data, new_size);

    subscript_to_add_++;
 8002b4a:	bf18      	it	ne
 8002b4c:	702e      	strbne	r6, [r5, #0]
    //if subscript reaches end make to go back to front
    if (subscript_to_add_ == TX_SIZE)
      subscript_to_add_ = 0;

    // enable and start DMA transfer
    if (idle_flag_ )
 8002b4e:	781a      	ldrb	r2, [r3, #0]
 8002b50:	4641      	mov	r1, r8
 8002b52:	2a00      	cmp	r2, #0
 8002b54:	d07f      	beq.n	8002c56 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x146>
      {
        // check the needs to enable and start DMA transfer
        if ((subscript_in_progress_ == (subscript_to_add_-1)) || (subscript_in_progress_ == TX_SIZE -1 && subscript_to_add_ == 0)) idle_flag_= false;
 8002b56:	782a      	ldrb	r2, [r5, #0]
 8002b58:	1e50      	subs	r0, r2, #1
 8002b5a:	4284      	cmp	r4, r0
 8002b5c:	d002      	beq.n	8002b64 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x54>
 8002b5e:	2c31      	cmp	r4, #49	; 0x31
 8002b60:	d102      	bne.n	8002b68 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x58>
 8002b62:	b90a      	cbnz	r2, 8002b68 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x58>
 8002b64:	2200      	movs	r2, #0
 8002b66:	701a      	strb	r2, [r3, #0]

        huart_->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
 8002b68:	6838      	ldr	r0, [r7, #0]
 8002b6a:	6802      	ldr	r2, [r0, #0]
 8002b6c:	6953      	ldr	r3, [r2, #20]
 8002b6e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002b72:	6153      	str	r3, [r2, #20]
        __HAL_DMA_DISABLE(huart_->hdmatx);
 8002b74:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8002b76:	681b      	ldr	r3, [r3, #0]
 8002b78:	6818      	ldr	r0, [r3, #0]
 8002b7a:	f020 0001 	bic.w	r0, r0, #1
 8002b7e:	6018      	str	r0, [r3, #0]
        uint8_t* tmp8 = tx_buffer_unit_[subscript_in_progress_].tx_data_;
        uint32_t *tmp32 = (uint32_t*)&tmp8;
        huart_->hdmatx->Instance->NDTR = (uint32_t)tx_buffer_unit_[subscript_in_progress_].tx_len_;
 8002b80:	20fb      	movs	r0, #251	; 0xfb
 8002b82:	fb00 1404 	mla	r4, r0, r4, r1
 8002b86:	f894 10fa 	ldrb.w	r1, [r4, #250]	; 0xfa
 8002b8a:	6059      	str	r1, [r3, #4]

        huart_->hdmatx->Instance->M0AR = *(uint32_t*)tmp32;
 8002b8c:	60dc      	str	r4, [r3, #12]
        /* Enable USARTy DMA TX Channel */
        huart_->Instance->CR3 |= USART_CR3_DMAT;
 8002b8e:	6951      	ldr	r1, [r2, #20]
 8002b90:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8002b94:	6151      	str	r1, [r2, #20]
        __HAL_DMA_ENABLE(huart_->hdmatx);
 8002b96:	681a      	ldr	r2, [r3, #0]
 8002b98:	f042 0201 	orr.w	r2, r2, #1
 8002b9c:	601a      	str	r2, [r3, #0]
        __HAL_DMA_CLEAR_FLAG(huart_->hdmatx, __HAL_DMA_GET_TC_FLAG_INDEX(huart_->hdmatx));
 8002b9e:	4a32      	ldr	r2, [pc, #200]	; (8002c68 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x158>)
 8002ba0:	4293      	cmp	r3, r2
 8002ba2:	d913      	bls.n	8002bcc <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xbc>
 8002ba4:	3218      	adds	r2, #24
 8002ba6:	4293      	cmp	r3, r2
 8002ba8:	d00a      	beq.n	8002bc0 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xb0>
 8002baa:	3218      	adds	r2, #24
 8002bac:	4293      	cmp	r3, r2
 8002bae:	d009      	beq.n	8002bc4 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xb4>
 8002bb0:	3218      	adds	r2, #24
 8002bb2:	4293      	cmp	r3, r2
 8002bb4:	bf0c      	ite	eq
 8002bb6:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8002bba:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8002bbe:	e003      	b.n	8002bc8 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xb8>
 8002bc0:	2320      	movs	r3, #32
 8002bc2:	e001      	b.n	8002bc8 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xb8>
 8002bc4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8002bc8:	4a28      	ldr	r2, [pc, #160]	; (8002c6c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x15c>)
 8002bca:	e02d      	b.n	8002c28 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x118>
 8002bcc:	4a28      	ldr	r2, [pc, #160]	; (8002c70 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x160>)
 8002bce:	4293      	cmp	r3, r2
 8002bd0:	d914      	bls.n	8002bfc <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xec>
 8002bd2:	f502 7256 	add.w	r2, r2, #856	; 0x358
 8002bd6:	4293      	cmp	r3, r2
 8002bd8:	d00a      	beq.n	8002bf0 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xe0>
 8002bda:	3218      	adds	r2, #24
 8002bdc:	4293      	cmp	r3, r2
 8002bde:	d009      	beq.n	8002bf4 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xe4>
 8002be0:	3218      	adds	r2, #24
 8002be2:	4293      	cmp	r3, r2
 8002be4:	bf0c      	ite	eq
 8002be6:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8002bea:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8002bee:	e003      	b.n	8002bf8 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xe8>
 8002bf0:	2320      	movs	r3, #32
 8002bf2:	e001      	b.n	8002bf8 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0xe8>
 8002bf4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8002bf8:	4a1c      	ldr	r2, [pc, #112]	; (8002c6c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x15c>)
 8002bfa:	e02b      	b.n	8002c54 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x144>
 8002bfc:	4a1d      	ldr	r2, [pc, #116]	; (8002c74 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x164>)
 8002bfe:	4293      	cmp	r3, r2
 8002c00:	d915      	bls.n	8002c2e <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x11e>
 8002c02:	3218      	adds	r2, #24
 8002c04:	4293      	cmp	r3, r2
 8002c06:	d00a      	beq.n	8002c1e <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x10e>
 8002c08:	3218      	adds	r2, #24
 8002c0a:	4293      	cmp	r3, r2
 8002c0c:	d009      	beq.n	8002c22 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x112>
 8002c0e:	3218      	adds	r2, #24
 8002c10:	4293      	cmp	r3, r2
 8002c12:	bf0c      	ite	eq
 8002c14:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8002c18:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8002c1c:	e003      	b.n	8002c26 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x116>
 8002c1e:	2320      	movs	r3, #32
 8002c20:	e001      	b.n	8002c26 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x116>
 8002c22:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8002c26:	4a14      	ldr	r2, [pc, #80]	; (8002c78 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x168>)
 8002c28:	60d3      	str	r3, [r2, #12]
 8002c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002c2e:	4a13      	ldr	r2, [pc, #76]	; (8002c7c <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x16c>)
 8002c30:	4293      	cmp	r3, r2
 8002c32:	d00a      	beq.n	8002c4a <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x13a>
 8002c34:	3218      	adds	r2, #24
 8002c36:	4293      	cmp	r3, r2
 8002c38:	d009      	beq.n	8002c4e <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x13e>
 8002c3a:	3218      	adds	r2, #24
 8002c3c:	4293      	cmp	r3, r2
 8002c3e:	bf0c      	ite	eq
 8002c40:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8002c44:	f04f 6300 	movne.w	r3, #134217728	; 0x8000000
 8002c48:	e003      	b.n	8002c52 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x142>
 8002c4a:	2320      	movs	r3, #32
 8002c4c:	e001      	b.n	8002c52 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x142>
 8002c4e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8002c52:	4a09      	ldr	r2, [pc, #36]	; (8002c78 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh+0x168>)
 8002c54:	6093      	str	r3, [r2, #8]
 8002c56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002c5a:	bf00      	nop
 8002c5c:	20000a6a 	.word	0x20000a6a
 8002c60:	20000a69 	.word	0x20000a69
 8002c64:	20000a68 	.word	0x20000a68
 8002c68:	40026458 	.word	0x40026458
 8002c6c:	40026400 	.word	0x40026400
 8002c70:	400260b8 	.word	0x400260b8
 8002c74:	40026058 	.word	0x40026058
 8002c78:	40026000 	.word	0x40026000
 8002c7c:	40026010 	.word	0x40026010
 8002c80:	20000a6b 	.word	0x20000a6b

08002c84 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE>:
      configured_ = true;
    }

    virtual int publish(int id, const Msg * msg)
    {
      if(id >= 100 && !configured_)
 8002c84:	2963      	cmp	r1, #99	; 0x63
            }
        }
      configured_ = true;
    }

    virtual int publish(int id, const Msg * msg)
 8002c86:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8002c88:	4604      	mov	r4, r0
 8002c8a:	460e      	mov	r6, r1
    {
      if(id >= 100 && !configured_)
 8002c8c:	dd03      	ble.n	8002c96 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE+0x12>
 8002c8e:	f890 52d0 	ldrb.w	r5, [r0, #720]	; 0x2d0
 8002c92:	2d00      	cmp	r5, #0
 8002c94:	d04b      	beq.n	8002d2e <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE+0xaa>
        return 0;

      /* serialize message */
      uint16_t l = msg->serialize(message_out+7);
 8002c96:	6813      	ldr	r3, [r2, #0]
 8002c98:	f504 7191 	add.w	r1, r4, #290	; 0x122
 8002c9c:	681b      	ldr	r3, [r3, #0]
 8002c9e:	4610      	mov	r0, r2
 8002ca0:	4798      	blx	r3

      /* setup the header */
      message_out[0] = 0xff;
 8002ca2:	22ff      	movs	r2, #255	; 0xff
 8002ca4:	f884 211b 	strb.w	r2, [r4, #283]	; 0x11b
      message_out[1] = PROTOCOL_VER;
 8002ca8:	22fe      	movs	r2, #254	; 0xfe
    {
      if(id >= 100 && !configured_)
        return 0;

      /* serialize message */
      uint16_t l = msg->serialize(message_out+7);
 8002caa:	b283      	uxth	r3, r0

      /* setup the header */
      message_out[0] = 0xff;
      message_out[1] = PROTOCOL_VER;
 8002cac:	f884 211c 	strb.w	r2, [r4, #284]	; 0x11c
      message_out[2] = (uint8_t) ((uint16_t)l&255);
 8002cb0:	b2c2      	uxtb	r2, r0
      message_out[3] = (uint8_t) ((uint16_t)l>>8);
 8002cb2:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8002cb6:	f884 011e 	strb.w	r0, [r4, #286]	; 0x11e
      message_out[4] = 255 - ((message_out[2] + message_out[3])%256);
 8002cba:	4410      	add	r0, r2
 8002cbc:	43c0      	mvns	r0, r0
      message_out[5] = (uint8_t) ((int16_t)id&255);
 8002cbe:	f884 6120 	strb.w	r6, [r4, #288]	; 0x120
      message_out[6] = (uint8_t) ((int16_t)id>>8);
 8002cc2:	f346 2607 	sbfx	r6, r6, #8, #8
      uint16_t l = msg->serialize(message_out+7);

      /* setup the header */
      message_out[0] = 0xff;
      message_out[1] = PROTOCOL_VER;
      message_out[2] = (uint8_t) ((uint16_t)l&255);
 8002cc6:	f884 211d 	strb.w	r2, [r4, #285]	; 0x11d
      message_out[3] = (uint8_t) ((uint16_t)l>>8);
      message_out[4] = 255 - ((message_out[2] + message_out[3])%256);
 8002cca:	f884 011f 	strb.w	r0, [r4, #287]	; 0x11f
      message_out[5] = (uint8_t) ((int16_t)id&255);
      message_out[6] = (uint8_t) ((int16_t)id>>8);
 8002cce:	f884 6121 	strb.w	r6, [r4, #289]	; 0x121
 8002cd2:	f204 101f 	addw	r0, r4, #287	; 0x11f

      /* calculate checksum */
      int chk = 0;
      for(int i =5; i<l+7; i++)
 8002cd6:	2105      	movs	r1, #5
      message_out[4] = 255 - ((message_out[2] + message_out[3])%256);
      message_out[5] = (uint8_t) ((int16_t)id&255);
      message_out[6] = (uint8_t) ((int16_t)id>>8);

      /* calculate checksum */
      int chk = 0;
 8002cd8:	2200      	movs	r2, #0
      for(int i =5; i<l+7; i++)
 8002cda:	1d9e      	adds	r6, r3, #6
 8002cdc:	42b1      	cmp	r1, r6
 8002cde:	dc04      	bgt.n	8002cea <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE+0x66>
        chk += message_out[i];
 8002ce0:	f810 5f01 	ldrb.w	r5, [r0, #1]!
      message_out[5] = (uint8_t) ((int16_t)id&255);
      message_out[6] = (uint8_t) ((int16_t)id>>8);

      /* calculate checksum */
      int chk = 0;
      for(int i =5; i<l+7; i++)
 8002ce4:	3101      	adds	r1, #1
        chk += message_out[i];
 8002ce6:	442a      	add	r2, r5
      message_out[5] = (uint8_t) ((int16_t)id&255);
      message_out[6] = (uint8_t) ((int16_t)id>>8);

      /* calculate checksum */
      int chk = 0;
      for(int i =5; i<l+7; i++)
 8002ce8:	e7f8      	b.n	8002cdc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE+0x58>
        chk += message_out[i];
      l += 7;
      message_out[l++] = 255 - (chk%256);
 8002cea:	f103 0508 	add.w	r5, r3, #8
 8002cee:	3307      	adds	r3, #7
 8002cf0:	b2ad      	uxth	r5, r5
 8002cf2:	fa14 f383 	uxtah	r3, r4, r3
 8002cf6:	43d2      	mvns	r2, r2
        {
          uint8_t reminder = l % DMA_TX_BURST_SIZE;
          if(reminder != 0) l = (l / DMA_TX_BURST_SIZE + 1) * DMA_TX_BURST_SIZE;
        }

      if( l <= OUTPUT_SIZE ){
 8002cf8:	2dff      	cmp	r5, #255	; 0xff
      /* calculate checksum */
      int chk = 0;
      for(int i =5; i<l+7; i++)
        chk += message_out[i];
      l += 7;
      message_out[l++] = 255 - (chk%256);
 8002cfa:	f883 211b 	strb.w	r2, [r3, #283]	; 0x11b
        {
          uint8_t reminder = l % DMA_TX_BURST_SIZE;
          if(reminder != 0) l = (l / DMA_TX_BURST_SIZE + 1) * DMA_TX_BURST_SIZE;
        }

      if( l <= OUTPUT_SIZE ){
 8002cfe:	d807      	bhi.n	8002d10 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE+0x8c>
 8002d00:	68a3      	ldr	r3, [r4, #8]
    write(&data_byte, 1);
  }

  void write(uint8_t * data_byte, uint8_t size)
  {
    tx_->write(data_byte, size);
 8002d02:	b2ea      	uxtb	r2, r5
 8002d04:	f204 111b 	addw	r1, r4, #283	; 0x11b
 8002d08:	6898      	ldr	r0, [r3, #8]
 8002d0a:	f7ff ff01 	bl	8002b10 <_ZN8TxBufferI18UART_HandleTypeDefLi50ELi250EE5writeEPhh>
 8002d0e:	e00e      	b.n	8002d2e <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE+0xaa>
      enum { ERROR = 3 };
      enum { FATAL = 4 };

    Log():
      level(0),
      msg("")
 8002d10:	4b08      	ldr	r3, [pc, #32]	; (8002d34 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE+0xb0>)
 8002d12:	9301      	str	r3, [sp, #4]
     */

  private:
    void log(char byte, const char * msg){
      rosserial_msgs::Log l;
      l.level= byte;
 8002d14:	2303      	movs	r3, #3
 8002d16:	f88d 3008 	strb.w	r3, [sp, #8]
      l.msg = (char*)msg;
 8002d1a:	4b07      	ldr	r3, [pc, #28]	; (8002d38 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE7publishEiPKNS_3MsgE+0xb4>)
 8002d1c:	9303      	str	r3, [sp, #12]
      publish(rosserial_msgs::TopicInfo::ID_LOG, &l);
 8002d1e:	6823      	ldr	r3, [r4, #0]
 8002d20:	aa01      	add	r2, sp, #4
 8002d22:	681b      	ldr	r3, [r3, #0]
 8002d24:	2107      	movs	r1, #7
 8002d26:	4620      	mov	r0, r4
 8002d28:	4798      	blx	r3
      if( l <= OUTPUT_SIZE ){
        hardware_.write(message_out, l);
        return l;
      }else{
        logerror("Message from device dropped: message larger than buffer.");
        return -1;
 8002d2a:	f04f 35ff 	mov.w	r5, #4294967295
      }
    }
 8002d2e:	4628      	mov	r0, r5
 8002d30:	b004      	add	sp, #16
 8002d32:	bd70      	pop	{r4, r5, r6, pc}
 8002d34:	08008d24 	.word	0x08008d24
 8002d38:	0800909d 	.word	0x0800909d

08002d3c <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15requestSyncTimeEv>:

    /********************************************************************
     * Time functions
     */

    void requestSyncTime()
 8002d3c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  {
    public:
      ros::Time data;

    Time():
      data()
 8002d3e:	4b08      	ldr	r3, [pc, #32]	; (8002d60 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15requestSyncTimeEv+0x24>)
 8002d40:	9301      	str	r3, [sp, #4]
 8002d42:	2300      	movs	r3, #0
 8002d44:	9302      	str	r3, [sp, #8]
 8002d46:	9303      	str	r3, [sp, #12]
    {
      std_msgs::Time t;
      publish(TopicInfo::ID_TIME, &t);
 8002d48:	6803      	ldr	r3, [r0, #0]
 8002d4a:	aa01      	add	r2, sp, #4
 8002d4c:	681b      	ldr	r3, [r3, #0]
 8002d4e:	210a      	movs	r1, #10

    /********************************************************************
     * Time functions
     */

    void requestSyncTime()
 8002d50:	4604      	mov	r4, r0
    {
      std_msgs::Time t;
      publish(TopicInfo::ID_TIME, &t);
 8002d52:	4798      	blx	r3

  void write(uint8_t* data, int length){
    iostream_->write(data, length);
  }

  uint32_t time(){return HAL_GetTick();}
 8002d54:	f001 f968 	bl	8004028 <HAL_GetTick>
      rt_time = hardware_.time();
 8002d58:	6120      	str	r0, [r4, #16]
    }
 8002d5a:	b004      	add	sp, #16
 8002d5c:	bd10      	pop	{r4, pc}
 8002d5e:	bf00      	nop
 8002d60:	08008cf4 	.word	0x08008cf4

08002d64 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15negotiateTopicsEv>:
        }
      }
      return false;
    }

    void negotiateTopics()
 8002d64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002d68:	b086      	sub	sp, #24
    TopicInfo():
      topic_id(0),
      topic_name(""),
      message_type(""),
      md5sum(""),
      buffer_size(0)
 8002d6a:	4b2a      	ldr	r3, [pc, #168]	; (8002e14 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15negotiateTopicsEv+0xb0>)
 8002d6c:	9300      	str	r3, [sp, #0]
 8002d6e:	2200      	movs	r2, #0
 8002d70:	4b29      	ldr	r3, [pc, #164]	; (8002e18 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15negotiateTopicsEv+0xb4>)
 8002d72:	f8ad 2004 	strh.w	r2, [sp, #4]
 8002d76:	4604      	mov	r4, r0
 8002d78:	9302      	str	r3, [sp, #8]
 8002d7a:	9303      	str	r3, [sp, #12]
 8002d7c:	9304      	str	r3, [sp, #16]
 8002d7e:	9205      	str	r2, [sp, #20]
 8002d80:	f500 7606 	add.w	r6, r0, #536	; 0x218
 8002d84:	f500 751a 	add.w	r5, r0, #616	; 0x268
            {
              ti.topic_id = publishers[i]->id_;
              ti.topic_name = (char *) publishers[i]->topic_;
              ti.message_type = (char *) publishers[i]->msg_->getType();
              ti.md5sum = (char *) publishers[i]->msg_->getMD5();
              ti.buffer_size = OUTPUT_SIZE;
 8002d88:	27ff      	movs	r7, #255	; 0xff
    {
      rosserial_msgs::TopicInfo ti;
      int i;
      for(i = 0; i < MAX_PUBLISHERS; i++)
        {
          if(publishers[i] != 0) // non-empty slot
 8002d8a:	f856 3f04 	ldr.w	r3, [r6, #4]!
 8002d8e:	b1bb      	cbz	r3, 8002dc0 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15negotiateTopicsEv+0x5c>
            {
              ti.topic_id = publishers[i]->id_;
              ti.topic_name = (char *) publishers[i]->topic_;
              ti.message_type = (char *) publishers[i]->msg_->getType();
 8002d90:	6858      	ldr	r0, [r3, #4]
      int i;
      for(i = 0; i < MAX_PUBLISHERS; i++)
        {
          if(publishers[i] != 0) // non-empty slot
            {
              ti.topic_id = publishers[i]->id_;
 8002d92:	689a      	ldr	r2, [r3, #8]
 8002d94:	f8ad 2004 	strh.w	r2, [sp, #4]
              ti.topic_name = (char *) publishers[i]->topic_;
 8002d98:	681a      	ldr	r2, [r3, #0]
              ti.message_type = (char *) publishers[i]->msg_->getType();
 8002d9a:	6803      	ldr	r3, [r0, #0]
      for(i = 0; i < MAX_PUBLISHERS; i++)
        {
          if(publishers[i] != 0) // non-empty slot
            {
              ti.topic_id = publishers[i]->id_;
              ti.topic_name = (char *) publishers[i]->topic_;
 8002d9c:	9202      	str	r2, [sp, #8]
              ti.message_type = (char *) publishers[i]->msg_->getType();
 8002d9e:	689b      	ldr	r3, [r3, #8]
 8002da0:	4798      	blx	r3
              ti.md5sum = (char *) publishers[i]->msg_->getMD5();
 8002da2:	6833      	ldr	r3, [r6, #0]
        {
          if(publishers[i] != 0) // non-empty slot
            {
              ti.topic_id = publishers[i]->id_;
              ti.topic_name = (char *) publishers[i]->topic_;
              ti.message_type = (char *) publishers[i]->msg_->getType();
 8002da4:	9003      	str	r0, [sp, #12]
              ti.md5sum = (char *) publishers[i]->msg_->getMD5();
 8002da6:	6858      	ldr	r0, [r3, #4]
 8002da8:	6803      	ldr	r3, [r0, #0]
 8002daa:	68db      	ldr	r3, [r3, #12]
 8002dac:	4798      	blx	r3
 8002dae:	6831      	ldr	r1, [r6, #0]
              ti.buffer_size = OUTPUT_SIZE;
              publish( publishers[i]->getEndpointType(), &ti );
 8002db0:	6823      	ldr	r3, [r4, #0]
          if(publishers[i] != 0) // non-empty slot
            {
              ti.topic_id = publishers[i]->id_;
              ti.topic_name = (char *) publishers[i]->topic_;
              ti.message_type = (char *) publishers[i]->msg_->getType();
              ti.md5sum = (char *) publishers[i]->msg_->getMD5();
 8002db2:	9004      	str	r0, [sp, #16]
              ti.buffer_size = OUTPUT_SIZE;
 8002db4:	9705      	str	r7, [sp, #20]
              publish( publishers[i]->getEndpointType(), &ti );
 8002db6:	681b      	ldr	r3, [r3, #0]
 8002db8:	6909      	ldr	r1, [r1, #16]
 8002dba:	466a      	mov	r2, sp
 8002dbc:	4620      	mov	r0, r4
 8002dbe:	4798      	blx	r3

    void negotiateTopics()
    {
      rosserial_msgs::TopicInfo ti;
      int i;
      for(i = 0; i < MAX_PUBLISHERS; i++)
 8002dc0:	42ae      	cmp	r6, r5
 8002dc2:	d1e2      	bne.n	8002d8a <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15negotiateTopicsEv+0x26>
 8002dc4:	f504 762e 	add.w	r6, r4, #696	; 0x2b8
            {
              ti.topic_id = subscribers[i]->id_;
              ti.topic_name = (char *) subscribers[i]->topic_;
              ti.message_type = (char *) subscribers[i]->getMsgType();
              ti.md5sum = (char *) subscribers[i]->getMsgMD5();
              ti.buffer_size = INPUT_SIZE;
 8002dc8:	27ff      	movs	r7, #255	; 0xff
              publish( publishers[i]->getEndpointType(), &ti );
            }
        }
      for(i = 0; i < MAX_SUBSCRIBERS; i++)
        {
          if(subscribers[i] != 0) // non-empty slot
 8002dca:	f855 0f04 	ldr.w	r0, [r5, #4]!
 8002dce:	b1c8      	cbz	r0, 8002e04 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15negotiateTopicsEv+0xa0>
            {
              ti.topic_id = subscribers[i]->id_;
 8002dd0:	6843      	ldr	r3, [r0, #4]
 8002dd2:	f8ad 3004 	strh.w	r3, [sp, #4]
              ti.topic_name = (char *) subscribers[i]->topic_;
 8002dd6:	6883      	ldr	r3, [r0, #8]
 8002dd8:	9302      	str	r3, [sp, #8]
              ti.message_type = (char *) subscribers[i]->getMsgType();
 8002dda:	6803      	ldr	r3, [r0, #0]
 8002ddc:	689b      	ldr	r3, [r3, #8]
 8002dde:	4798      	blx	r3
 8002de0:	9003      	str	r0, [sp, #12]
              ti.md5sum = (char *) subscribers[i]->getMsgMD5();
 8002de2:	6828      	ldr	r0, [r5, #0]
 8002de4:	6803      	ldr	r3, [r0, #0]
 8002de6:	68db      	ldr	r3, [r3, #12]
 8002de8:	4798      	blx	r3
              ti.buffer_size = INPUT_SIZE;
              publish( subscribers[i]->getEndpointType(), &ti );
 8002dea:	6823      	ldr	r3, [r4, #0]
          if(subscribers[i] != 0) // non-empty slot
            {
              ti.topic_id = subscribers[i]->id_;
              ti.topic_name = (char *) subscribers[i]->topic_;
              ti.message_type = (char *) subscribers[i]->getMsgType();
              ti.md5sum = (char *) subscribers[i]->getMsgMD5();
 8002dec:	9004      	str	r0, [sp, #16]
              ti.buffer_size = INPUT_SIZE;
              publish( subscribers[i]->getEndpointType(), &ti );
 8002dee:	6828      	ldr	r0, [r5, #0]
 8002df0:	f8d3 8000 	ldr.w	r8, [r3]
 8002df4:	6803      	ldr	r3, [r0, #0]
            {
              ti.topic_id = subscribers[i]->id_;
              ti.topic_name = (char *) subscribers[i]->topic_;
              ti.message_type = (char *) subscribers[i]->getMsgType();
              ti.md5sum = (char *) subscribers[i]->getMsgMD5();
              ti.buffer_size = INPUT_SIZE;
 8002df6:	9705      	str	r7, [sp, #20]
              publish( subscribers[i]->getEndpointType(), &ti );
 8002df8:	685b      	ldr	r3, [r3, #4]
 8002dfa:	4798      	blx	r3
 8002dfc:	466a      	mov	r2, sp
 8002dfe:	4601      	mov	r1, r0
 8002e00:	4620      	mov	r0, r4
 8002e02:	47c0      	blx	r8
              ti.md5sum = (char *) publishers[i]->msg_->getMD5();
              ti.buffer_size = OUTPUT_SIZE;
              publish( publishers[i]->getEndpointType(), &ti );
            }
        }
      for(i = 0; i < MAX_SUBSCRIBERS; i++)
 8002e04:	42ae      	cmp	r6, r5
 8002e06:	d1e0      	bne.n	8002dca <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15negotiateTopicsEv+0x66>
              ti.md5sum = (char *) subscribers[i]->getMsgMD5();
              ti.buffer_size = INPUT_SIZE;
              publish( subscribers[i]->getEndpointType(), &ti );
            }
        }
      configured_ = true;
 8002e08:	2301      	movs	r3, #1
 8002e0a:	f884 32d0 	strb.w	r3, [r4, #720]	; 0x2d0
    }
 8002e0e:	b006      	add	sp, #24
 8002e10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002e14:	08008d0c 	.word	0x08008d0c
 8002e18:	080090d5 	.word	0x080090d5

08002e1c <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8syncTimeEPh>:
      std_msgs::Time t;
      publish(TopicInfo::ID_TIME, &t);
      rt_time = hardware_.time();
    }

    void syncTime(uint8_t * data)
 8002e1c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8002e1e:	4b1c      	ldr	r3, [pc, #112]	; (8002e90 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8syncTimeEPh+0x74>)
 8002e20:	9301      	str	r3, [sp, #4]
 8002e22:	4604      	mov	r4, r0
 8002e24:	2300      	movs	r3, #0
 8002e26:	9302      	str	r3, [sp, #8]
 8002e28:	9303      	str	r3, [sp, #12]
 8002e2a:	460d      	mov	r5, r1
 8002e2c:	f001 f8fc 	bl	8004028 <HAL_GetTick>
    {
      std_msgs::Time t;
      uint32_t offset = hardware_.time() - rt_time;
 8002e30:	6922      	ldr	r2, [r4, #16]

      t.deserialize(data);
 8002e32:	4629      	mov	r1, r5
    }

    void syncTime(uint8_t * data)
    {
      std_msgs::Time t;
      uint32_t offset = hardware_.time() - rt_time;
 8002e34:	1a86      	subs	r6, r0, r2

      t.deserialize(data);
 8002e36:	a801      	add	r0, sp, #4
 8002e38:	f7fe fc00 	bl	800163c <_ZN8std_msgs4Time11deserializeEPh>
      t.data.sec += offset/1000;
 8002e3c:	9b02      	ldr	r3, [sp, #8]
 8002e3e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8002e42:	fbb6 f2f5 	udiv	r2, r6, r5
 8002e46:	4413      	add	r3, r2
 8002e48:	9302      	str	r3, [sp, #8]
      t.data.nsec += (offset%1000)*1000000UL;
 8002e4a:	fb05 6212 	mls	r2, r5, r2, r6
 8002e4e:	9b03      	ldr	r3, [sp, #12]
 8002e50:	4e10      	ldr	r6, [pc, #64]	; (8002e94 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8syncTimeEPh+0x78>)
 8002e52:	fb06 3202 	mla	r2, r6, r2, r3
 8002e56:	9203      	str	r2, [sp, #12]
 8002e58:	f001 f8e6 	bl	8004028 <HAL_GetTick>
    }

    void setNow( Time & new_now )
    {
      uint32_t ms = hardware_.time();
      sec_offset = new_now.sec - ms/1000 - 1;
 8002e5c:	9a02      	ldr	r2, [sp, #8]
 8002e5e:	fbb0 f3f5 	udiv	r3, r0, r5
 8002e62:	3a01      	subs	r2, #1
 8002e64:	1ad2      	subs	r2, r2, r3
 8002e66:	6162      	str	r2, [r4, #20]
      nsec_offset = new_now.nsec - (ms%1000)*1000000UL + 1000000000UL;
 8002e68:	9903      	ldr	r1, [sp, #12]
 8002e6a:	4a0b      	ldr	r2, [pc, #44]	; (8002e98 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8syncTimeEPh+0x7c>)
 8002e6c:	fb05 0013 	mls	r0, r5, r3, r0
 8002e70:	440a      	add	r2, r1
 8002e72:	4621      	mov	r1, r4
 8002e74:	fb06 2310 	mls	r3, r6, r0, r2
 8002e78:	f841 3f18 	str.w	r3, [r1, #24]!
      normalizeSecNSec(sec_offset, nsec_offset);
 8002e7c:	f104 0014 	add.w	r0, r4, #20
 8002e80:	f001 f868 	bl	8003f54 <_ZN3ros16normalizeSecNSecERmS0_>
 8002e84:	f001 f8d0 	bl	8004028 <HAL_GetTick>
      t.deserialize(data);
      t.data.sec += offset/1000;
      t.data.nsec += (offset%1000)*1000000UL;

      this->setNow(t.data);
      last_sync_receive_time = hardware_.time();
 8002e88:	f8c4 02d8 	str.w	r0, [r4, #728]	; 0x2d8
    }
 8002e8c:	b004      	add	sp, #16
 8002e8e:	bd70      	pop	{r4, r5, r6, pc}
 8002e90:	08008cf4 	.word	0x08008cf4
 8002e94:	000f4240 	.word	0x000f4240
 8002e98:	3b9aca00 	.word	0x3b9aca00

08002e9c <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv>:
    /* This function goes in your loop() function, it handles
     *  serial input and callbacks for subscribers.
     */


    virtual int spinOnce(){
 8002e9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002ea0:	4604      	mov	r4, r0
 8002ea2:	f001 f8c1 	bl	8004028 <HAL_GetTick>

      /* restart if timed out */
      uint32_t c_time = hardware_.time();
      if( (c_time - last_sync_receive_time) > (SYNC_SECONDS*2200) ){
 8002ea6:	f8d4 32d8 	ldr.w	r3, [r4, #728]	; 0x2d8
 8002eaa:	f642 22f8 	movw	r2, #11000	; 0x2af8
 8002eae:	1ac3      	subs	r3, r0, r3
 8002eb0:	4293      	cmp	r3, r2
        configured_ = false;
 8002eb2:	bf84      	itt	hi
 8002eb4:	2300      	movhi	r3, #0
 8002eb6:	f884 32d0 	strbhi.w	r3, [r4, #720]	; 0x2d0
      }

      /* reset if message has timed out */
      if ( mode_ != MODE_FIRST_FF){
 8002eba:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
 8002ebe:	4607      	mov	r7, r0
 8002ec0:	b133      	cbz	r3, 8002ed0 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x34>
        if (c_time > last_msg_timeout_time){
 8002ec2:	f8d4 32dc 	ldr.w	r3, [r4, #732]	; 0x2dc
 8002ec6:	4283      	cmp	r3, r0
          mode_ = MODE_FIRST_FF;
 8002ec8:	bf3c      	itt	cc
 8002eca:	2300      	movcc	r3, #0
 8002ecc:	f8c4 32bc 	strcc.w	r3, [r4, #700]	; 0x2bc
    uint8_t r_data;
    ring_buf_->pop(r_data);
    return  r_data;
  }

  bool available() { return ring_buf_->length(); }
 8002ed0:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 80030c4 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x228>
      {
        pop_value =  buf_[byte_in_progress_];

        byte_in_progress_++;
        if (byte_in_progress_ == buffer_length_)
          byte_in_progress_ = 0;
 8002ed4:	f04f 0800 	mov.w	r8, #0
                param_recieved= true;
              }else if(topic_ == TopicInfo::ID_TX_STOP){
                configured_ = false;
              }else{
                if(subscribers[topic_-100])
                  subscribers[topic_-100]->callback( message_in );
 8002ed8:	f104 091c 	add.w	r9, r4, #28
    uint8_t r_data;
    ring_buf_->pop(r_data);
    return  r_data;
  }

  bool available() { return ring_buf_->length(); }
 8002edc:	f8da 2000 	ldr.w	r2, [sl]
    return true;
  }

  uint16_t length()
  {
    if(byte_to_add_ - byte_in_progress_ >= 0)
 8002ee0:	f9b2 1192 	ldrsh.w	r1, [r2, #402]	; 0x192
 8002ee4:	f9b2 3190 	ldrsh.w	r3, [r2, #400]	; 0x190
 8002ee8:	1acd      	subs	r5, r1, r3
      return (byte_to_add_ - byte_in_progress_);
    else 
      return (byte_to_add_ - (buffer_length_ - byte_in_progress_));
 8002eea:	bf42      	ittt	mi
 8002eec:	f8b2 0194 	ldrhmi.w	r0, [r2, #404]	; 0x194
 8002ef0:	18cd      	addmi	r5, r1, r3
 8002ef2:	1a2d      	submi	r5, r5, r0
 8002ef4:	b2ad      	uxth	r5, r5
    return true;
  }

  int read()
  {
    if(!available()) return -1;
 8002ef6:	2d00      	cmp	r5, #0
 8002ef8:	f000 80cf 	beq.w	800309a <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x1fe>
  }
  ~RingBuffer(){  }

  bool pop(T& pop_value)
  {
    if (byte_in_progress_ != byte_to_add_)
 8002efc:	4299      	cmp	r1, r3
 8002efe:	d00a      	beq.n	8002f16 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x7a>
      {
        pop_value =  buf_[byte_in_progress_];
 8002f00:	5cd6      	ldrb	r6, [r2, r3]

        byte_in_progress_++;
        if (byte_in_progress_ == buffer_length_)
 8002f02:	f8b2 1194 	ldrh.w	r1, [r2, #404]	; 0x194
  {
    if (byte_in_progress_ != byte_to_add_)
      {
        pop_value =  buf_[byte_in_progress_];

        byte_in_progress_++;
 8002f06:	3301      	adds	r3, #1
 8002f08:	b21b      	sxth	r3, r3
        if (byte_in_progress_ == buffer_length_)
 8002f0a:	428b      	cmp	r3, r1
  {
    if (byte_in_progress_ != byte_to_add_)
      {
        pop_value =  buf_[byte_in_progress_];

        byte_in_progress_++;
 8002f0c:	f8a2 3190 	strh.w	r3, [r2, #400]	; 0x190
        if (byte_in_progress_ == buffer_length_)
          byte_in_progress_ = 0;
 8002f10:	bf08      	it	eq
 8002f12:	f8a2 8190 	strheq.w	r8, [r2, #400]	; 0x190
      while( true )
        {
          int data = hardware_.read();
          if( data < 0 )
            break;
          checksum_ += data;
 8002f16:	f8d4 22cc 	ldr.w	r2, [r4, #716]	; 0x2cc
          if( mode_ == MODE_MESSAGE ){        /* message data being recieved */
 8002f1a:	f8d4 52bc 	ldr.w	r5, [r4, #700]	; 0x2bc
      while( true )
        {
          int data = hardware_.read();
          if( data < 0 )
            break;
          checksum_ += data;
 8002f1e:	4432      	add	r2, r6
          if( mode_ == MODE_MESSAGE ){        /* message data being recieved */
 8002f20:	2d07      	cmp	r5, #7
      while( true )
        {
          int data = hardware_.read();
          if( data < 0 )
            break;
          checksum_ += data;
 8002f22:	f8c4 22cc 	str.w	r2, [r4, #716]	; 0x2cc
          if( mode_ == MODE_MESSAGE ){        /* message data being recieved */
 8002f26:	d10f      	bne.n	8002f48 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xac>
            message_in[index_++] = data;
 8002f28:	f8d4 32c8 	ldr.w	r3, [r4, #712]	; 0x2c8
 8002f2c:	1c5a      	adds	r2, r3, #1
 8002f2e:	4423      	add	r3, r4
 8002f30:	f8c4 22c8 	str.w	r2, [r4, #712]	; 0x2c8
 8002f34:	771e      	strb	r6, [r3, #28]
            bytes_--;
 8002f36:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
 8002f3a:	3b01      	subs	r3, #1
 8002f3c:	f8c4 32c0 	str.w	r3, [r4, #704]	; 0x2c0
            if(bytes_ == 0)                  /* is message complete? if so, checksum */
 8002f40:	2b00      	cmp	r3, #0
 8002f42:	d1cb      	bne.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
              mode_ = MODE_MSG_CHECKSUM;
 8002f44:	2308      	movs	r3, #8
 8002f46:	e01a      	b.n	8002f7e <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xe2>
          }else if( mode_ == MODE_FIRST_FF ){
 8002f48:	b9a5      	cbnz	r5, 8002f74 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xd8>
            if(data == 0xff){
 8002f4a:	2eff      	cmp	r6, #255	; 0xff
 8002f4c:	d107      	bne.n	8002f5e <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xc2>
              mode_++;
 8002f4e:	2301      	movs	r3, #1
 8002f50:	f8c4 32bc 	str.w	r3, [r4, #700]	; 0x2bc
              last_msg_timeout_time = c_time + MSG_TIMEOUT;
 8002f54:	f107 0314 	add.w	r3, r7, #20
 8002f58:	f8c4 32dc 	str.w	r3, [r4, #732]	; 0x2dc
 8002f5c:	e7be      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>

  void write(uint8_t* data, int length){
    iostream_->write(data, length);
  }

  uint32_t time(){return HAL_GetTick();}
 8002f5e:	f001 f863 	bl	8004028 <HAL_GetTick>
            }
            else if( hardware_.time() - c_time > (SYNC_SECONDS)){
 8002f62:	1bc0      	subs	r0, r0, r7
 8002f64:	2805      	cmp	r0, #5
 8002f66:	d9b9      	bls.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
              /* We have been stuck in spinOnce too long, return error */
              configured_=false;
 8002f68:	f884 52d0 	strb.w	r5, [r4, #720]	; 0x2d0
              return -2;
 8002f6c:	f06f 0001 	mvn.w	r0, #1
 8002f70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            }
          }else if( mode_ == MODE_PROTOCOL_VER ){
 8002f74:	2d01      	cmp	r5, #1
 8002f76:	d10f      	bne.n	8002f98 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xfc>
            if(data == PROTOCOL_VER){
 8002f78:	2efe      	cmp	r6, #254	; 0xfe
 8002f7a:	d103      	bne.n	8002f84 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xe8>
              mode_++;
 8002f7c:	2302      	movs	r3, #2
 8002f7e:	f8c4 32bc 	str.w	r3, [r4, #700]	; 0x2bc
 8002f82:	e7ab      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
            }else{
              mode_ = MODE_FIRST_FF;
              if (configured_ == false)
 8002f84:	f894 32d0 	ldrb.w	r3, [r4, #720]	; 0x2d0
            }
          }else if( mode_ == MODE_PROTOCOL_VER ){
            if(data == PROTOCOL_VER){
              mode_++;
            }else{
              mode_ = MODE_FIRST_FF;
 8002f88:	f8c4 82bc 	str.w	r8, [r4, #700]	; 0x2bc
              if (configured_ == false)
 8002f8c:	2b00      	cmp	r3, #0
 8002f8e:	d1a5      	bne.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
                requestSyncTime(); 	/* send a msg back showing our protocol version */
 8002f90:	4620      	mov	r0, r4
 8002f92:	f7ff fed3 	bl	8002d3c <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15requestSyncTimeEv>
 8002f96:	e7a1      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
            }
          }else if( mode_ == MODE_SIZE_L ){   /* bottom half of message size */
 8002f98:	2d02      	cmp	r5, #2
 8002f9a:	d105      	bne.n	8002fa8 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x10c>
            bytes_ = data;
 8002f9c:	f8c4 62c0 	str.w	r6, [r4, #704]	; 0x2c0
            index_ = 0;
 8002fa0:	f8c4 82c8 	str.w	r8, [r4, #712]	; 0x2c8
            mode_++;
 8002fa4:	2303      	movs	r3, #3
 8002fa6:	e020      	b.n	8002fea <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x14e>
            checksum_ = data;               /* first byte for calculating size checksum */
          }else if( mode_ == MODE_SIZE_H ){   /* top half of message size */
 8002fa8:	2d03      	cmp	r5, #3
 8002faa:	d107      	bne.n	8002fbc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x120>
            bytes_ += data<<8;
 8002fac:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
 8002fb0:	eb03 2306 	add.w	r3, r3, r6, lsl #8
 8002fb4:	f8c4 32c0 	str.w	r3, [r4, #704]	; 0x2c0
            mode_++;
 8002fb8:	2304      	movs	r3, #4
 8002fba:	e7e0      	b.n	8002f7e <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xe2>
          }else if( mode_ == MODE_SIZE_CHECKSUM ){
 8002fbc:	2d04      	cmp	r5, #4
 8002fbe:	d10f      	bne.n	8002fe0 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x144>
            if( (checksum_%256) == 255)
 8002fc0:	4b3f      	ldr	r3, [pc, #252]	; (80030c0 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x224>)
 8002fc2:	4013      	ands	r3, r2
 8002fc4:	2b00      	cmp	r3, #0
 8002fc6:	bfbe      	ittt	lt
 8002fc8:	f103 33ff 	addlt.w	r3, r3, #4294967295
 8002fcc:	f063 03ff 	ornlt	r3, r3, #255	; 0xff
 8002fd0:	3301      	addlt	r3, #1
 8002fd2:	2bff      	cmp	r3, #255	; 0xff
 8002fd4:	d101      	bne.n	8002fda <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x13e>
              mode_++;
 8002fd6:	2305      	movs	r3, #5
 8002fd8:	e7d1      	b.n	8002f7e <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xe2>
            else
              mode_ = MODE_FIRST_FF;          /* Abandon the frame if the msg len is wrong */
 8002fda:	f8c4 82bc 	str.w	r8, [r4, #700]	; 0x2bc
 8002fde:	e77d      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
          }else if( mode_ == MODE_TOPIC_L ){  /* bottom half of topic id */
 8002fe0:	2d05      	cmp	r5, #5
 8002fe2:	d107      	bne.n	8002ff4 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x158>
            topic_ = data;
 8002fe4:	f8c4 62c4 	str.w	r6, [r4, #708]	; 0x2c4
            mode_++;
 8002fe8:	2306      	movs	r3, #6
 8002fea:	f8c4 32bc 	str.w	r3, [r4, #700]	; 0x2bc
            checksum_ = data;               /* first byte included in checksum */
 8002fee:	f8c4 62cc 	str.w	r6, [r4, #716]	; 0x2cc
 8002ff2:	e773      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
          }else if( mode_ == MODE_TOPIC_H ){  /* top half of topic id */
 8002ff4:	2d06      	cmp	r5, #6
 8002ff6:	d10b      	bne.n	8003010 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x174>
            topic_ += data<<8;
 8002ff8:	f8d4 32c4 	ldr.w	r3, [r4, #708]	; 0x2c4
 8002ffc:	eb03 2306 	add.w	r3, r3, r6, lsl #8
 8003000:	f8c4 32c4 	str.w	r3, [r4, #708]	; 0x2c4
            mode_ = MODE_MESSAGE;
 8003004:	2307      	movs	r3, #7
 8003006:	f8c4 32bc 	str.w	r3, [r4, #700]	; 0x2bc
            if(bytes_ == 0)
 800300a:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
 800300e:	e797      	b.n	8002f40 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0xa4>
              mode_ = MODE_MSG_CHECKSUM;
          }else if( mode_ == MODE_MSG_CHECKSUM ){ /* do checksum */
 8003010:	2d08      	cmp	r5, #8
 8003012:	f47f af63 	bne.w	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
            mode_ = MODE_FIRST_FF;
            if( (checksum_%256) == 255){
 8003016:	4b2a      	ldr	r3, [pc, #168]	; (80030c0 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x224>)
            topic_ += data<<8;
            mode_ = MODE_MESSAGE;
            if(bytes_ == 0)
              mode_ = MODE_MSG_CHECKSUM;
          }else if( mode_ == MODE_MSG_CHECKSUM ){ /* do checksum */
            mode_ = MODE_FIRST_FF;
 8003018:	f8c4 82bc 	str.w	r8, [r4, #700]	; 0x2bc
            if( (checksum_%256) == 255){
 800301c:	4013      	ands	r3, r2
 800301e:	2b00      	cmp	r3, #0
 8003020:	bfbe      	ittt	lt
 8003022:	f103 33ff 	addlt.w	r3, r3, #4294967295
 8003026:	f063 03ff 	ornlt	r3, r3, #255	; 0xff
 800302a:	3301      	addlt	r3, #1
 800302c:	2bff      	cmp	r3, #255	; 0xff
 800302e:	f47f af55 	bne.w	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
              if(topic_ == TopicInfo::ID_PUBLISHER){
 8003032:	f8d4 32c4 	ldr.w	r3, [r4, #708]	; 0x2c4
 8003036:	b96b      	cbnz	r3, 8003054 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x1b8>
                requestSyncTime();
 8003038:	4620      	mov	r0, r4
 800303a:	f7ff fe7f 	bl	8002d3c <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15requestSyncTimeEv>
                negotiateTopics();
 800303e:	4620      	mov	r0, r4
 8003040:	f7ff fe90 	bl	8002d64 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15negotiateTopicsEv>
                last_sync_time = c_time;
 8003044:	f8c4 72d4 	str.w	r7, [r4, #724]	; 0x2d4
                last_sync_receive_time = c_time;
 8003048:	f8c4 72d8 	str.w	r7, [r4, #728]	; 0x2d8
                return -1;
 800304c:	f04f 30ff 	mov.w	r0, #4294967295
 8003050:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
              }else if(topic_ == TopicInfo::ID_TIME){
 8003054:	2b0a      	cmp	r3, #10
 8003056:	d104      	bne.n	8003062 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x1c6>
                syncTime(message_in);
 8003058:	4649      	mov	r1, r9
 800305a:	4620      	mov	r0, r4
 800305c:	f7ff fede 	bl	8002e1c <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8syncTimeEPh>
 8003060:	e73c      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
              }else if (topic_ == TopicInfo::ID_PARAMETER_REQUEST){
 8003062:	2b06      	cmp	r3, #6
 8003064:	d108      	bne.n	8003078 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x1dc>
                req_param_resp.deserialize(message_in);
 8003066:	4649      	mov	r1, r9
 8003068:	f504 7039 	add.w	r0, r4, #740	; 0x2e4
 800306c:	f7fe ffb7 	bl	8001fde <_ZN14rosserial_msgs20RequestParamResponse11deserializeEPh>
                param_recieved= true;
 8003070:	2301      	movs	r3, #1
 8003072:	f884 32e0 	strb.w	r3, [r4, #736]	; 0x2e0
 8003076:	e731      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
              }else if(topic_ == TopicInfo::ID_TX_STOP){
 8003078:	2b0b      	cmp	r3, #11
 800307a:	d102      	bne.n	8003082 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x1e6>
                configured_ = false;
 800307c:	f884 82d0 	strb.w	r8, [r4, #720]	; 0x2d0
 8003080:	e72c      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
              }else{
                if(subscribers[topic_-100])
 8003082:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8003086:	f8d3 00dc 	ldr.w	r0, [r3, #220]	; 0xdc
 800308a:	2800      	cmp	r0, #0
 800308c:	f43f af26 	beq.w	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
                  subscribers[topic_-100]->callback( message_in );
 8003090:	6803      	ldr	r3, [r0, #0]
 8003092:	4649      	mov	r1, r9
 8003094:	681b      	ldr	r3, [r3, #0]
 8003096:	4798      	blx	r3
 8003098:	e720      	b.n	8002edc <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x40>
            }
          }
        }

      /* occasionally sync time */
      if( configured_ && ((c_time-last_sync_time) > (SYNC_SECONDS*500) )){
 800309a:	f894 32d0 	ldrb.w	r3, [r4, #720]	; 0x2d0
 800309e:	b15b      	cbz	r3, 80030b8 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x21c>
 80030a0:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 80030a4:	f640 12c4 	movw	r2, #2500	; 0x9c4
 80030a8:	1afb      	subs	r3, r7, r3
 80030aa:	4293      	cmp	r3, r2
 80030ac:	d904      	bls.n	80030b8 <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv+0x21c>
        requestSyncTime();
 80030ae:	4620      	mov	r0, r4
 80030b0:	f7ff fe44 	bl	8002d3c <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE15requestSyncTimeEv>
        last_sync_time = c_time;
 80030b4:	f8c4 72d4 	str.w	r7, [r4, #724]	; 0x2d4
      }

      return 0;
 80030b8:	4628      	mov	r0, r5
    }
 80030ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80030be:	bf00      	nop
 80030c0:	800000ff 	.word	0x800000ff
 80030c4:	20003b7c 	.word	0x20003b7c

080030c8 <HAL_SYSTICK_Callback>:
static int counter = 0;

// attitude estimate and  control is at sys timer it callback
// update interrupt
void HAL_SYSTICK_Callback(void)
{
 80030c8:	b538      	push	{r3, r4, r5, lr}
	static uint32_t last_time = HAL_GetTick();
 80030ca:	4d15      	ldr	r5, [pc, #84]	; (8003120 <HAL_SYSTICK_Callback+0x58>)
 80030cc:	f8d5 34e4 	ldr.w	r3, [r5, #1252]	; 0x4e4
 80030d0:	07db      	lsls	r3, r3, #31
 80030d2:	d404      	bmi.n	80030de <HAL_SYSTICK_Callback+0x16>
 80030d4:	f000 ffa8 	bl	8004028 <HAL_GetTick>
 80030d8:	2301      	movs	r3, #1
 80030da:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
	uint32_t now_time = HAL_GetTick();


	/* ros spin func, mainly subscribing  data from ROS network */
	nh_.spinOnce();
 80030de:	4c10      	ldr	r4, [pc, #64]	; (8003120 <HAL_SYSTICK_Callback+0x58>)
// attitude estimate and  control is at sys timer it callback
// update interrupt
void HAL_SYSTICK_Callback(void)
{
	static uint32_t last_time = HAL_GetTick();
	uint32_t now_time = HAL_GetTick();
 80030e0:	f000 ffa2 	bl	8004028 <HAL_GetTick>


	/* ros spin func, mainly subscribing  data from ROS network */
	nh_.spinOnce();
 80030e4:	4620      	mov	r0, r4
 80030e6:	f7ff fed9 	bl	8002e9c <_ZN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EE8spinOnceEv>

	if(!start_process_flag_)
 80030ea:	f895 34e0 	ldrb.w	r3, [r5, #1248]	; 0x4e0
 80030ee:	b1b3      	cbz	r3, 800311e <HAL_SYSTICK_Callback+0x56>
		return;
	/* please check whether connection between ros and mcu is build */
	if(nh_.connected())
 80030f0:	f894 32d0 	ldrb.w	r3, [r4, #720]	; 0x2d0
 80030f4:	b19b      	cbz	r3, 800311e <HAL_SYSTICK_Callback+0x56>
	{
		/* publish message */
			/* state estimate */
		if(counter++>8)
 80030f6:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
 80030fa:	2b08      	cmp	r3, #8
 80030fc:	dc03      	bgt.n	8003106 <HAL_SYSTICK_Callback+0x3e>
 80030fe:	3301      	adds	r3, #1
 8003100:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
 8003104:	bd38      	pop	{r3, r4, r5, pc}
		{
			counter = 0;
 8003106:	2300      	movs	r3, #0
			imu_.update();
 8003108:	210a      	movs	r1, #10
 800310a:	f504 7043 	add.w	r0, r4, #780	; 0x30c
	{
		/* publish message */
			/* state estimate */
		if(counter++>8)
		{
			counter = 0;
 800310e:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
			imu_.update();
 8003112:	f000 ff05 	bl	8003f20 <_ZN3IMU6updateEt>
//				estimator_.attitude_estimator_.imu_msg_.gyro_data[i] = estimator_.attitude_estimator_.imu_->getGyro()[i];
//				estimator_.attitude_estimator_.imu_msg_.mag_data[i] = estimator_.attitude_estimator_.imu_->getMag()[i];
//				estimator_.attitude_estimator_.imu_msg_.acc_data[i] = estimator_.attitude_estimator_.imu_->getAcc()[i];
//			}
//			estimator_.attitude_estimator_.imu_pub_->publish(&estimator_.attitude_estimator_.imu_msg_);
			estimator_.update();
 8003116:	f504 6084 	add.w	r0, r4, #1056	; 0x420
 800311a:	f7ff fc1a 	bl	8002952 <_ZN13StateEstimate6updateEv>
 800311e:	bd38      	pop	{r3, r4, r5, pc}
 8003120:	20000530 	.word	0x20000530

08003124 <_GLOBAL__sub_I_nh_>:
  /* User can add his own implementation to report the HAL error return state */
  while(1) 
  {
  }
  /* USER CODE END Error_Handler_Debug */ 
}
 8003124:	b538      	push	{r3, r4, r5, lr}

    /*
     * Setup Functions
     */
  public:
    NodeHandle_() : configured_(false) {
 8003126:	4b63      	ldr	r3, [pc, #396]	; (80032b4 <_GLOBAL__sub_I_nh_+0x190>)
 8003128:	4a63      	ldr	r2, [pc, #396]	; (80032b8 <_GLOBAL__sub_I_nh_+0x194>)
 800312a:	601a      	str	r2, [r3, #0]
public:
  typedef UART_HandleTypeDef serial_class;


  STMF4Hardware(){ // hard coding
    baud_ = 961200;
 800312c:	4a63      	ldr	r2, [pc, #396]	; (80032bc <_GLOBAL__sub_I_nh_+0x198>)
      char* * strings;

    RequestParamResponse():
      ints_length(0), ints(NULL),
      floats_length(0), floats(NULL),
      strings_length(0), strings(NULL)
 800312e:	4964      	ldr	r1, [pc, #400]	; (80032c0 <_GLOBAL__sub_I_nh_+0x19c>)
 8003130:	60da      	str	r2, [r3, #12]
 8003132:	2200      	movs	r2, #0
 8003134:	f8c3 12e4 	str.w	r1, [r3, #740]	; 0x2e4
 8003138:	f883 22d0 	strb.w	r2, [r3, #720]	; 0x2d0
 800313c:	f883 22e8 	strb.w	r2, [r3, #744]	; 0x2e8
 8003140:	f8c3 22f0 	str.w	r2, [r3, #752]	; 0x2f0
 8003144:	f883 22f4 	strb.w	r2, [r3, #756]	; 0x2f4
 8003148:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
 800314c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
 8003150:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
 8003154:	f503 7006 	add.w	r0, r3, #536	; 0x218
 8003158:	f503 711a 	add.w	r1, r3, #616	; 0x268

      for(unsigned int i=0; i< MAX_PUBLISHERS; i++)
        publishers[i] = 0;
 800315c:	f840 2f04 	str.w	r2, [r0, #4]!
     * Setup Functions
     */
  public:
    NodeHandle_() : configured_(false) {

      for(unsigned int i=0; i< MAX_PUBLISHERS; i++)
 8003160:	4281      	cmp	r1, r0
 8003162:	d1fb      	bne.n	800315c <_GLOBAL__sub_I_nh_+0x38>
 8003164:	4a57      	ldr	r2, [pc, #348]	; (80032c4 <_GLOBAL__sub_I_nh_+0x1a0>)
        publishers[i] = 0;

      for(unsigned int i=0; i< MAX_SUBSCRIBERS; i++)
        subscribers[i] = 0;
 8003166:	2000      	movs	r0, #0
 8003168:	f841 0f04 	str.w	r0, [r1, #4]!
    NodeHandle_() : configured_(false) {

      for(unsigned int i=0; i< MAX_PUBLISHERS; i++)
        publishers[i] = 0;

      for(unsigned int i=0; i< MAX_SUBSCRIBERS; i++)
 800316c:	428a      	cmp	r2, r1
 800316e:	d1fb      	bne.n	8003168 <_GLOBAL__sub_I_nh_+0x44>
 8003170:	2200      	movs	r2, #0
        subscribers[i] = 0;

      for(unsigned int i=0; i< INPUT_SIZE; i++)
        message_in[i] = 0;
 8003172:	4610      	mov	r0, r2
 8003174:	1899      	adds	r1, r3, r2
        publishers[i] = 0;

      for(unsigned int i=0; i< MAX_SUBSCRIBERS; i++)
        subscribers[i] = 0;

      for(unsigned int i=0; i< INPUT_SIZE; i++)
 8003176:	3201      	adds	r2, #1
 8003178:	2aff      	cmp	r2, #255	; 0xff
        message_in[i] = 0;
 800317a:	7708      	strb	r0, [r1, #28]
        publishers[i] = 0;

      for(unsigned int i=0; i< MAX_SUBSCRIBERS; i++)
        subscribers[i] = 0;

      for(unsigned int i=0; i< INPUT_SIZE; i++)
 800317c:	d1fa      	bne.n	8003174 <_GLOBAL__sub_I_nh_+0x50>
 800317e:	2100      	movs	r1, #0
        message_in[i] = 0;

      for(unsigned int i=0; i< OUTPUT_SIZE; i++)
        message_out[i] = 0;
 8003180:	460d      	mov	r5, r1
 8003182:	1858      	adds	r0, r3, r1
        subscribers[i] = 0;

      for(unsigned int i=0; i< INPUT_SIZE; i++)
        message_in[i] = 0;

      for(unsigned int i=0; i< OUTPUT_SIZE; i++)
 8003184:	3101      	adds	r1, #1
 8003186:	29ff      	cmp	r1, #255	; 0xff
        message_out[i] = 0;
 8003188:	4c4a      	ldr	r4, [pc, #296]	; (80032b4 <_GLOBAL__sub_I_nh_+0x190>)
 800318a:	f880 511b 	strb.w	r5, [r0, #283]	; 0x11b
 800318e:	f04f 0200 	mov.w	r2, #0
        subscribers[i] = 0;

      for(unsigned int i=0; i< INPUT_SIZE; i++)
        message_in[i] = 0;

      for(unsigned int i=0; i< OUTPUT_SIZE; i++)
 8003192:	d1f6      	bne.n	8003182 <_GLOBAL__sub_I_nh_+0x5e>
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 8003194:	f8c4 230c 	str.w	r2, [r4, #780]	; 0x30c
 8003198:	f8c4 2310 	str.w	r2, [r4, #784]	; 0x310
 800319c:	f8c4 2314 	str.w	r2, [r4, #788]	; 0x314
 80031a0:	f8c4 2318 	str.w	r2, [r4, #792]	; 0x318
 80031a4:	f8c4 231c 	str.w	r2, [r4, #796]	; 0x31c
 80031a8:	f8c4 2320 	str.w	r2, [r4, #800]	; 0x320
 80031ac:	f204 4204 	addw	r2, r4, #1028	; 0x404
 80031b0:	2300      	movs	r3, #0
 80031b2:	f8c4 332c 	str.w	r3, [r4, #812]	; 0x32c
 80031b6:	f8c4 3328 	str.w	r3, [r4, #808]	; 0x328
 80031ba:	f8c4 3324 	str.w	r3, [r4, #804]	; 0x324
 80031be:	f8c4 3338 	str.w	r3, [r4, #824]	; 0x338
 80031c2:	f8c4 3334 	str.w	r3, [r4, #820]	; 0x334
 80031c6:	f8c4 3330 	str.w	r3, [r4, #816]	; 0x330
 80031ca:	f8c4 3354 	str.w	r3, [r4, #852]	; 0x354
 80031ce:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
 80031d2:	f8c4 334c 	str.w	r3, [r4, #844]	; 0x34c
 80031d6:	f8c4 3360 	str.w	r3, [r4, #864]	; 0x360
 80031da:	f8c4 335c 	str.w	r3, [r4, #860]	; 0x35c
 80031de:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
 80031e2:	f8c4 336c 	str.w	r3, [r4, #876]	; 0x36c
 80031e6:	f8c4 3368 	str.w	r3, [r4, #872]	; 0x368
 80031ea:	f8c4 3364 	str.w	r3, [r4, #868]	; 0x364
 80031ee:	f8c4 3378 	str.w	r3, [r4, #888]	; 0x378
 80031f2:	f8c4 3374 	str.w	r3, [r4, #884]	; 0x374
 80031f6:	f8c4 3370 	str.w	r3, [r4, #880]	; 0x370
 80031fa:	f8c4 3384 	str.w	r3, [r4, #900]	; 0x384
 80031fe:	f8c4 3380 	str.w	r3, [r4, #896]	; 0x380
 8003202:	f8c4 337c 	str.w	r3, [r4, #892]	; 0x37c
 8003206:	f8c4 3390 	str.w	r3, [r4, #912]	; 0x390
 800320a:	f8c4 338c 	str.w	r3, [r4, #908]	; 0x38c
 800320e:	f8c4 3388 	str.w	r3, [r4, #904]	; 0x388
 8003212:	f8c4 339c 	str.w	r3, [r4, #924]	; 0x39c
 8003216:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 800321a:	f8c4 3394 	str.w	r3, [r4, #916]	; 0x394
 800321e:	6013      	str	r3, [r2, #0]
 8003220:	f504 6280 	add.w	r2, r4, #1024	; 0x400
 8003224:	f504 6081 	add.w	r0, r4, #1032	; 0x408
 8003228:	6013      	str	r3, [r2, #0]
 800322a:	f204 4214 	addw	r2, r4, #1044	; 0x414
//ros node  ugvnode
static RosNode *testnode;

/* sensors */
#if IMU_FLAG
IMU imu_;
 800322e:	4926      	ldr	r1, [pc, #152]	; (80032c8 <_GLOBAL__sub_I_nh_+0x1a4>)
 8003230:	6013      	str	r3, [r2, #0]
 8003232:	f504 6282 	add.w	r2, r4, #1040	; 0x410
 8003236:	f840 39fc 	str.w	r3, [r0], #-252
 800323a:	6013      	str	r3, [r2, #0]
 800323c:	f204 420c 	addw	r2, r4, #1036	; 0x40c
 8003240:	f8c4 33a8 	str.w	r3, [r4, #936]	; 0x3a8
 8003244:	6013      	str	r3, [r2, #0]
 8003246:	4a21      	ldr	r2, [pc, #132]	; (80032cc <_GLOBAL__sub_I_nh_+0x1a8>)
 8003248:	f8c4 33a4 	str.w	r3, [r4, #932]	; 0x3a4
 800324c:	f8c4 33a0 	str.w	r3, [r4, #928]	; 0x3a0
 8003250:	f8c4 33b4 	str.w	r3, [r4, #948]	; 0x3b4
 8003254:	f8c4 33b0 	str.w	r3, [r4, #944]	; 0x3b0
 8003258:	f8c4 33ac 	str.w	r3, [r4, #940]	; 0x3ac
 800325c:	f8c4 33c0 	str.w	r3, [r4, #960]	; 0x3c0
 8003260:	f8c4 33bc 	str.w	r3, [r4, #956]	; 0x3bc
 8003264:	f8c4 33b8 	str.w	r3, [r4, #952]	; 0x3b8
 8003268:	f8c4 33cc 	str.w	r3, [r4, #972]	; 0x3cc
 800326c:	f8c4 33c8 	str.w	r3, [r4, #968]	; 0x3c8
 8003270:	f8c4 33c4 	str.w	r3, [r4, #964]	; 0x3c4
 8003274:	f8c4 33e4 	str.w	r3, [r4, #996]	; 0x3e4
 8003278:	f8c4 33e0 	str.w	r3, [r4, #992]	; 0x3e0
 800327c:	f8c4 33dc 	str.w	r3, [r4, #988]	; 0x3dc
 8003280:	f8c4 33f0 	str.w	r3, [r4, #1008]	; 0x3f0
 8003284:	f8c4 33ec 	str.w	r3, [r4, #1004]	; 0x3ec
 8003288:	f8c4 33e8 	str.w	r3, [r4, #1000]	; 0x3e8
 800328c:	f8c4 33fc 	str.w	r3, [r4, #1020]	; 0x3fc
 8003290:	f8c4 33f8 	str.w	r3, [r4, #1016]	; 0x3f8
 8003294:	f8c4 33f4 	str.w	r3, [r4, #1012]	; 0x3f4
 8003298:	f003 fd41 	bl	8006d1e <__aeabi_atexit>
#if GPS_FLAG
GPS gps_;
#endif
//
#if ATTITUDE_ESTIMATE_FLAG || HEIGHT_ESTIMATE_FLAG || POS_ESTIMATE_FLAG
StateEstimate estimator_;
 800329c:	f504 6084 	add.w	r0, r4, #1056	; 0x420
 80032a0:	f7ff f888 	bl	80023b4 <_ZN13StateEstimateC1Ev>
 80032a4:	f504 6084 	add.w	r0, r4, #1056	; 0x420
 80032a8:	4a08      	ldr	r2, [pc, #32]	; (80032cc <_GLOBAL__sub_I_nh_+0x1a8>)
 80032aa:	4909      	ldr	r1, [pc, #36]	; (80032d0 <_GLOBAL__sub_I_nh_+0x1ac>)
 80032ac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80032b0:	f003 bd35 	b.w	8006d1e <__aeabi_atexit>
 80032b4:	20000530 	.word	0x20000530
 80032b8:	08008d9c 	.word	0x08008d9c
 80032bc:	000eaab0 	.word	0x000eaab0
 80032c0:	08008d3c 	.word	0x08008d3c
 80032c4:	200007e8 	.word	0x200007e8
 80032c8:	08002385 	.word	0x08002385
 80032cc:	20000000 	.word	0x20000000
 80032d0:	08001b59 	.word	0x08001b59

080032d4 <MX_SPI1_Init>:

SPI_HandleTypeDef hspi1;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 80032d4:	b508      	push	{r3, lr}

  hspi1.Instance = SPI1;
 80032d6:	480f      	ldr	r0, [pc, #60]	; (8003314 <MX_SPI1_Init+0x40>)
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80032d8:	4b0f      	ldr	r3, [pc, #60]	; (8003318 <MX_SPI1_Init+0x44>)
 80032da:	f44f 7e82 	mov.w	lr, #260	; 0x104
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80032de:	f44f 7200 	mov.w	r2, #512	; 0x200
/* SPI1 init function */
void MX_SPI1_Init(void)
{

  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80032e2:	e880 4008 	stmia.w	r0, {r3, lr}
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80032e6:	2300      	movs	r3, #0
 80032e8:	6083      	str	r3, [r0, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80032ea:	60c3      	str	r3, [r0, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 80032ec:	6103      	str	r3, [r0, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 80032ee:	6143      	str	r3, [r0, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80032f0:	6182      	str	r2, [r0, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80032f2:	6203      	str	r3, [r0, #32]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;
 80032f4:	2230      	movs	r2, #48	; 0x30
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 80032f6:	6243      	str	r3, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80032f8:	6283      	str	r3, [r0, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 15;
 80032fa:	230f      	movs	r3, #15
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;
 80032fc:	61c2      	str	r2, [r0, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 15;
 80032fe:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8003300:	f001 ff3a 	bl	8005178 <HAL_SPI_Init>
 8003304:	b128      	cbz	r0, 8003312 <MX_SPI1_Init+0x3e>
  {
    _Error_Handler(__FILE__, __LINE__);
 8003306:	2145      	movs	r1, #69	; 0x45
 8003308:	4804      	ldr	r0, [pc, #16]	; (800331c <MX_SPI1_Init+0x48>)
  }

}
 800330a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 15;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
 800330e:	f7ff b8d9 	b.w	80024c4 <_Error_Handler>
 8003312:	bd08      	pop	{r3, pc}
 8003314:	20003b84 	.word	0x20003b84
 8003318:	40013000 	.word	0x40013000
 800331c:	080090d6 	.word	0x080090d6

08003320 <HAL_SPI_MspInit>:
  }

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8003320:	b510      	push	{r4, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(spiHandle->Instance==SPI1)
 8003322:	6802      	ldr	r2, [r0, #0]
 8003324:	4b13      	ldr	r3, [pc, #76]	; (8003374 <HAL_SPI_MspInit+0x54>)
 8003326:	429a      	cmp	r2, r3
  }

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8003328:	b086      	sub	sp, #24

  GPIO_InitTypeDef GPIO_InitStruct;
  if(spiHandle->Instance==SPI1)
 800332a:	d121      	bne.n	8003370 <HAL_SPI_MspInit+0x50>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 800332c:	2400      	movs	r4, #0
 800332e:	f503 3384 	add.w	r3, r3, #67584	; 0x10800
 8003332:	9400      	str	r4, [sp, #0]
 8003334:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003336:	4810      	ldr	r0, [pc, #64]	; (8003378 <HAL_SPI_MspInit+0x58>)
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8003338:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800333c:	645a      	str	r2, [r3, #68]	; 0x44
 800333e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    PB4     ------> SPI1_MISO
    PB5     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003340:	9403      	str	r4, [sp, #12]
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8003342:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8003346:	9300      	str	r3, [sp, #0]
 8003348:	9b00      	ldr	r3, [sp, #0]
    /**SPI1 GPIO Configuration    
    PB3     ------> SPI1_SCK
    PB4     ------> SPI1_MISO
    PB5     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5;
 800334a:	2338      	movs	r3, #56	; 0x38
 800334c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800334e:	2302      	movs	r3, #2
 8003350:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8003352:	2303      	movs	r3, #3
 8003354:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8003356:	a901      	add	r1, sp, #4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8003358:	2305      	movs	r3, #5
 800335a:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800335c:	f001 fb86 	bl	8004a6c <HAL_GPIO_Init>

    /* SPI1 interrupt Init */
    HAL_NVIC_SetPriority(SPI1_IRQn, 0, 0);
 8003360:	2023      	movs	r0, #35	; 0x23
 8003362:	4622      	mov	r2, r4
 8003364:	4621      	mov	r1, r4
 8003366:	f000 ffc1 	bl	80042ec <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI1_IRQn);
 800336a:	2023      	movs	r0, #35	; 0x23
 800336c:	f000 fff2 	bl	8004354 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }
}
 8003370:	b006      	add	sp, #24
 8003372:	bd10      	pop	{r4, pc}
 8003374:	40013000 	.word	0x40013000
 8003378:	40020400 	.word	0x40020400

0800337c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800337c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2);
 800337e:	2005      	movs	r0, #5
 8003380:	f000 ffa2 	bl	80042c8 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8003384:	2200      	movs	r2, #0
 8003386:	4611      	mov	r1, r2
 8003388:	f06f 000b 	mvn.w	r0, #11
 800338c:	f000 ffae 	bl	80042ec <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8003390:	2200      	movs	r2, #0
 8003392:	4611      	mov	r1, r2
 8003394:	f06f 000a 	mvn.w	r0, #10
 8003398:	f000 ffa8 	bl	80042ec <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 800339c:	2200      	movs	r2, #0
 800339e:	4611      	mov	r1, r2
 80033a0:	f06f 0009 	mvn.w	r0, #9
 80033a4:	f000 ffa2 	bl	80042ec <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80033a8:	2200      	movs	r2, #0
 80033aa:	4611      	mov	r1, r2
 80033ac:	f06f 0004 	mvn.w	r0, #4
 80033b0:	f000 ff9c 	bl	80042ec <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80033b4:	2200      	movs	r2, #0
 80033b6:	4611      	mov	r1, r2
 80033b8:	f06f 0003 	mvn.w	r0, #3
 80033bc:	f000 ff96 	bl	80042ec <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 80033c0:	2200      	movs	r2, #0
 80033c2:	4611      	mov	r1, r2
 80033c4:	f06f 0001 	mvn.w	r0, #1
 80033c8:	f000 ff90 	bl	80042ec <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 1);
 80033cc:	2201      	movs	r2, #1
 80033ce:	2100      	movs	r1, #0
 80033d0:	f04f 30ff 	mov.w	r0, #4294967295

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80033d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 1);
 80033d8:	f000 bf88 	b.w	80042ec <HAL_NVIC_SetPriority>

080033dc <NMI_Handler>:
 80033dc:	4770      	bx	lr

080033de <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 80033de:	e7fe      	b.n	80033de <HardFault_Handler>

080033e0 <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 80033e0:	e7fe      	b.n	80033e0 <MemManage_Handler>

080033e2 <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 80033e2:	e7fe      	b.n	80033e2 <BusFault_Handler>

080033e4 <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 80033e4:	e7fe      	b.n	80033e4 <UsageFault_Handler>

080033e6 <SVC_Handler>:
 80033e6:	4770      	bx	lr

080033e8 <DebugMon_Handler>:
 80033e8:	4770      	bx	lr

080033ea <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 80033ea:	4770      	bx	lr

080033ec <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80033ec:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80033ee:	f000 fe13 	bl	8004018 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80033f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 80033f6:	f000 bfdb 	b.w	80043b0 <HAL_SYSTICK_IRQHandler>
	...

080033fc <SPI1_IRQHandler>:
void SPI1_IRQHandler(void)
{
  /* USER CODE BEGIN SPI1_IRQn 0 */

  /* USER CODE END SPI1_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi1);
 80033fc:	4801      	ldr	r0, [pc, #4]	; (8003404 <SPI1_IRQHandler+0x8>)
 80033fe:	f002 b953 	b.w	80056a8 <HAL_SPI_IRQHandler>
 8003402:	bf00      	nop
 8003404:	20003b84 	.word	0x20003b84

08003408 <USART1_IRQHandler>:
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8003408:	4801      	ldr	r0, [pc, #4]	; (8003410 <USART1_IRQHandler+0x8>)
 800340a:	f002 bc49 	b.w	8005ca0 <HAL_UART_IRQHandler>
 800340e:	bf00      	nop
 8003410:	20003c9c 	.word	0x20003c9c

08003414 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream2_IRQn 0 */

  /* USER CODE END DMA2_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_rx);
 8003414:	4801      	ldr	r0, [pc, #4]	; (800341c <DMA2_Stream2_IRQHandler+0x8>)
 8003416:	f001 b8ad 	b.w	8004574 <HAL_DMA_IRQHandler>
 800341a:	bf00      	nop
 800341c:	20003c3c 	.word	0x20003c3c

08003420 <DMA2_Stream7_IRQHandler>:
void DMA2_Stream7_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream7_IRQn 0 */

  /* USER CODE END DMA2_Stream7_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_tx);
 8003420:	4801      	ldr	r0, [pc, #4]	; (8003428 <DMA2_Stream7_IRQHandler+0x8>)
 8003422:	f001 b8a7 	b.w	8004574 <HAL_DMA_IRQHandler>
 8003426:	bf00      	nop
 8003428:	20003bdc 	.word	0x20003bdc

0800342c <MX_USART1_UART_Init>:
DMA_HandleTypeDef hdma_usart1_tx;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 800342c:	b508      	push	{r3, lr}

  huart1.Instance = USART1;
 800342e:	480c      	ldr	r0, [pc, #48]	; (8003460 <MX_USART1_UART_Init+0x34>)
  huart1.Init.BaudRate = 921600;
 8003430:	4b0c      	ldr	r3, [pc, #48]	; (8003464 <MX_USART1_UART_Init+0x38>)
 8003432:	f44f 2e61 	mov.w	lr, #921600	; 0xe1000
 8003436:	e880 4008 	stmia.w	r0, {r3, lr}
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
 800343a:	220c      	movs	r2, #12
void MX_USART1_UART_Init(void)
{

  huart1.Instance = USART1;
  huart1.Init.BaudRate = 921600;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 800343c:	2300      	movs	r3, #0
 800343e:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8003440:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8003442:	6103      	str	r3, [r0, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8003444:	6142      	str	r2, [r0, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8003446:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8003448:	61c3      	str	r3, [r0, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 800344a:	f002 fad3 	bl	80059f4 <HAL_UART_Init>
 800344e:	b128      	cbz	r0, 800345c <MX_USART1_UART_Init+0x30>
  {
    _Error_Handler(__FILE__, __LINE__);
 8003450:	2145      	movs	r1, #69	; 0x45
 8003452:	4805      	ldr	r0, [pc, #20]	; (8003468 <MX_USART1_UART_Init+0x3c>)
  }

}
 8003454:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
 8003458:	f7ff b834 	b.w	80024c4 <_Error_Handler>
 800345c:	bd08      	pop	{r3, pc}
 800345e:	bf00      	nop
 8003460:	20003c9c 	.word	0x20003c9c
 8003464:	40011000 	.word	0x40011000
 8003468:	080090e9 	.word	0x080090e9

0800346c <HAL_UART_MspInit>:
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 800346c:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(uartHandle->Instance==USART1)
 800346e:	6802      	ldr	r2, [r0, #0]
 8003470:	4b36      	ldr	r3, [pc, #216]	; (800354c <HAL_UART_MspInit+0xe0>)
 8003472:	429a      	cmp	r2, r3
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8003474:	b087      	sub	sp, #28
 8003476:	4606      	mov	r6, r0

  GPIO_InitTypeDef GPIO_InitStruct;
  if(uartHandle->Instance==USART1)
 8003478:	d166      	bne.n	8003548 <HAL_UART_MspInit+0xdc>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800347a:	2500      	movs	r5, #0
 800347c:	f503 3394 	add.w	r3, r3, #75776	; 0x12800
 8003480:	9500      	str	r5, [sp, #0]
 8003482:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8003484:	4832      	ldr	r0, [pc, #200]	; (8003550 <HAL_UART_MspInit+0xe4>)

    /* USART1 DMA Init */
    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
 8003486:	4c33      	ldr	r4, [pc, #204]	; (8003554 <HAL_UART_MspInit+0xe8>)
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8003488:	f042 0210 	orr.w	r2, r2, #16
 800348c:	645a      	str	r2, [r3, #68]	; 0x44
 800348e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003490:	f003 0310 	and.w	r3, r3, #16
 8003494:	9300      	str	r3, [sp, #0]
 8003496:	9b00      	ldr	r3, [sp, #0]
  
    /**USART1 GPIO Configuration    
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8003498:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800349c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800349e:	2302      	movs	r3, #2
 80034a0:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80034a2:	2303      	movs	r3, #3
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80034a4:	2701      	movs	r7, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80034a6:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80034a8:	a901      	add	r1, sp, #4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 80034aa:	2307      	movs	r3, #7
 80034ac:	9305      	str	r3, [sp, #20]
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80034ae:	9703      	str	r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80034b0:	f001 fadc 	bl	8004a6c <HAL_GPIO_Init>

    /* USART1 DMA Init */
    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 80034b4:	4b28      	ldr	r3, [pc, #160]	; (8003558 <HAL_UART_MspInit+0xec>)
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80034b6:	60a5      	str	r5, [r4, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART1 DMA Init */
    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 80034b8:	f04f 6e00 	mov.w	lr, #134217728	; 0x8000000
 80034bc:	e884 4008 	stmia.w	r4, {r3, lr}
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
 80034c0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80034c4:	6123      	str	r3, [r4, #16]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
 80034c6:	f44f 7380 	mov.w	r3, #256	; 0x100
 80034ca:	61e3      	str	r3, [r4, #28]
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 80034cc:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80034d0:	6223      	str	r3, [r4, #32]
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80034d2:	2304      	movs	r3, #4
 80034d4:	6263      	str	r3, [r4, #36]	; 0x24
    hdma_usart1_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
    hdma_usart1_rx.Init.MemBurst = DMA_MBURST_INC8;
    hdma_usart1_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 80034d6:	4620      	mov	r0, r4
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
    hdma_usart1_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
    hdma_usart1_rx.Init.MemBurst = DMA_MBURST_INC8;
 80034d8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    /* USART1 DMA Init */
    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 80034dc:	60e5      	str	r5, [r4, #12]
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80034de:	6165      	str	r5, [r4, #20]
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80034e0:	61a5      	str	r5, [r4, #24]
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
    hdma_usart1_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_HALFFULL;
 80034e2:	62a7      	str	r7, [r4, #40]	; 0x28
    hdma_usart1_rx.Init.MemBurst = DMA_MBURST_INC8;
 80034e4:	62e3      	str	r3, [r4, #44]	; 0x2c
    hdma_usart1_rx.Init.PeriphBurst = DMA_PBURST_SINGLE;
 80034e6:	6325      	str	r5, [r4, #48]	; 0x30
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 80034e8:	f000 ff7c 	bl	80043e4 <HAL_DMA_Init>
 80034ec:	b118      	cbz	r0, 80034f6 <HAL_UART_MspInit+0x8a>
    {
      _Error_Handler(__FILE__, __LINE__);
 80034ee:	2172      	movs	r1, #114	; 0x72
 80034f0:	481a      	ldr	r0, [pc, #104]	; (800355c <HAL_UART_MspInit+0xf0>)
 80034f2:	f7fe ffe7 	bl	80024c4 <_Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);
 80034f6:	6374      	str	r4, [r6, #52]	; 0x34
 80034f8:	63a6      	str	r6, [r4, #56]	; 0x38

    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
 80034fa:	4c19      	ldr	r4, [pc, #100]	; (8003560 <HAL_UART_MspInit+0xf4>)
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80034fc:	4b19      	ldr	r3, [pc, #100]	; (8003564 <HAL_UART_MspInit+0xf8>)
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 80034fe:	f44f 6280 	mov.w	r2, #1024	; 0x400
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);

    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8003502:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
 8003506:	2740      	movs	r7, #64	; 0x40
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8003508:	6122      	str	r2, [r4, #16]
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_tx.Init.Mode = DMA_CIRCULAR;
 800350a:	f44f 7280 	mov.w	r2, #256	; 0x100
    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);

    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800350e:	e884 00a8 	stmia.w	r4, {r3, r5, r7}
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_tx.Init.Mode = DMA_CIRCULAR;
 8003512:	61e2      	str	r2, [r4, #28]

    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8003514:	2300      	movs	r3, #0
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_tx.Init.Mode = DMA_CIRCULAR;
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8003516:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 800351a:	4620      	mov	r0, r4

    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800351c:	60e3      	str	r3, [r4, #12]
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800351e:	6163      	str	r3, [r4, #20]
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8003520:	61a3      	str	r3, [r4, #24]
    hdma_usart1_tx.Init.Mode = DMA_CIRCULAR;
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8003522:	6222      	str	r2, [r4, #32]
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8003524:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 8003526:	f000 ff5d 	bl	80043e4 <HAL_DMA_Init>
 800352a:	b118      	cbz	r0, 8003534 <HAL_UART_MspInit+0xc8>
    {
      _Error_Handler(__FILE__, __LINE__);
 800352c:	2184      	movs	r1, #132	; 0x84
 800352e:	480b      	ldr	r0, [pc, #44]	; (800355c <HAL_UART_MspInit+0xf0>)
 8003530:	f7fe ffc8 	bl	80024c4 <_Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 8003534:	2200      	movs	r2, #0
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);
 8003536:	6334      	str	r4, [r6, #48]	; 0x30

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 8003538:	2025      	movs	r0, #37	; 0x25
 800353a:	4611      	mov	r1, r2
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);
 800353c:	63a6      	str	r6, [r4, #56]	; 0x38

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 800353e:	f000 fed5 	bl	80042ec <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8003542:	2025      	movs	r0, #37	; 0x25
 8003544:	f000 ff06 	bl	8004354 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 8003548:	b007      	add	sp, #28
 800354a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800354c:	40011000 	.word	0x40011000
 8003550:	40020000 	.word	0x40020000
 8003554:	20003c3c 	.word	0x20003c3c
 8003558:	40026440 	.word	0x40026440
 800355c:	080090e9 	.word	0x080090e9
 8003560:	20003bdc 	.word	0x20003bdc
 8003564:	400264b8 	.word	0x400264b8

08003568 <_ZNK8std_msgs5UInt89serializeEPh>:
    }

    virtual int serialize(unsigned char *outbuffer) const
    {
      int offset = 0;
      *(outbuffer + offset + 0) = (this->data >> (8 * 0)) & 0xFF;
 8003568:	7903      	ldrb	r3, [r0, #4]
 800356a:	700b      	strb	r3, [r1, #0]
      offset += sizeof(this->data);
      return offset;
    }
 800356c:	2001      	movs	r0, #1
 800356e:	4770      	bx	lr

08003570 <_ZN8std_msgs5UInt811deserializeEPh>:

    virtual int deserialize(unsigned char *inbuffer)
    {
      int offset = 0;
      this->data =  ((uint8_t) (*(inbuffer + offset)));
 8003570:	780b      	ldrb	r3, [r1, #0]
 8003572:	7103      	strb	r3, [r0, #4]
      offset += sizeof(this->data);
     return offset;
    }
 8003574:	2001      	movs	r0, #1
 8003576:	4770      	bx	lr

08003578 <_ZN8std_msgs5UInt87getTypeEv>:

    const char * getType(){ return "std_msgs/UInt8"; };
 8003578:	4800      	ldr	r0, [pc, #0]	; (800357c <_ZN8std_msgs5UInt87getTypeEv+0x4>)
 800357a:	4770      	bx	lr
 800357c:	08009184 	.word	0x08009184

08003580 <_ZN8std_msgs5UInt86getMD5Ev>:
    const char * getMD5(){ return "7c8164229e7d2c17eb95e9231617fdee"; };
 8003580:	4800      	ldr	r0, [pc, #0]	; (8003584 <_ZN8std_msgs5UInt86getMD5Ev+0x4>)
 8003582:	4770      	bx	lr
 8003584:	08009193 	.word	0x08009193

08003588 <_ZN3ros11Subscriber2IN8std_msgs5UInt8E3IMUE15getEndpointTypeEv>:
        this->fun_obj_(obj_, msg);
      }

      virtual const char * getMsgType(){ return this->msg.getType(); }
      virtual const char * getMsgMD5(){ return this->msg.getMD5(); }
      virtual int getEndpointType(){ return endpoint_; }
 8003588:	6a00      	ldr	r0, [r0, #32]
 800358a:	4770      	bx	lr

0800358c <_ZN3ros11Subscriber2IN8std_msgs5UInt8E3IMUE10getMsgTypeEv>:
      virtual void callback(unsigned char* data){
        msg.deserialize(data);
        this->fun_obj_(obj_, msg);
      }

      virtual const char * getMsgType(){ return this->msg.getType(); }
 800358c:	4800      	ldr	r0, [pc, #0]	; (8003590 <_ZN3ros11Subscriber2IN8std_msgs5UInt8E3IMUE10getMsgTypeEv+0x4>)
 800358e:	4770      	bx	lr
 8003590:	08009184 	.word	0x08009184

08003594 <_ZN3ros11Subscriber2IN8std_msgs5UInt8E3IMUE9getMsgMD5Ev>:
      virtual const char * getMsgMD5(){ return this->msg.getMD5(); }
 8003594:	4800      	ldr	r0, [pc, #0]	; (8003598 <_ZN3ros11Subscriber2IN8std_msgs5UInt8E3IMUE9getMsgMD5Ev+0x4>)
 8003596:	4770      	bx	lr
 8003598:	08009193 	.word	0x08009193

0800359c <_ZN3ros11Subscriber2IN8std_msgs5UInt8E3IMUE8callbackEPh>:
      {
        //std::binder1st t  = std::bind1st(std::mem_fun1_t())
        topic_ = topic_name;
      };

      virtual void callback(unsigned char* data){
 800359c:	b410      	push	{r4}

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
 800359e:	69c2      	ldr	r2, [r0, #28]
    }

    virtual int deserialize(unsigned char *inbuffer)
    {
      int offset = 0;
      this->data =  ((uint8_t) (*(inbuffer + offset)));
 80035a0:	780b      	ldrb	r3, [r1, #0]
 80035a2:	7403      	strb	r3, [r0, #16]
        msg.deserialize(data);
        this->fun_obj_(obj_, msg);
 80035a4:	6944      	ldr	r4, [r0, #20]
 80035a6:	6983      	ldr	r3, [r0, #24]
 80035a8:	f100 010c 	add.w	r1, r0, #12
 80035ac:	1050      	asrs	r0, r2, #1
 80035ae:	f012 0f01 	tst.w	r2, #1
 80035b2:	bf18      	it	ne
 80035b4:	5822      	ldrne	r2, [r4, r0]
 80035b6:	4420      	add	r0, r4
 80035b8:	bf18      	it	ne
 80035ba:	58d3      	ldrne	r3, [r2, r3]
      }
 80035bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80035c0:	4718      	bx	r3
	...

080035c4 <_ZN3IMU17imuConfigCallbackERKN8std_msgs5UInt8E>:
	}
}

void IMU::imuConfigCallback(const std_msgs::UInt8& config_msg)
{
	switch(config_msg.data)
 80035c4:	790b      	ldrb	r3, [r1, #4]
 80035c6:	2b01      	cmp	r3, #1
 80035c8:	d011      	beq.n	80035ee <_ZN3IMU17imuConfigCallbackERKN8std_msgs5UInt8E+0x2a>
 80035ca:	d302      	bcc.n	80035d2 <_ZN3IMU17imuConfigCallbackERKN8std_msgs5UInt8E+0xe>
 80035cc:	2b02      	cmp	r3, #2
 80035ce:	d015      	beq.n	80035fc <_ZN3IMU17imuConfigCallbackERKN8std_msgs5UInt8E+0x38>
 80035d0:	4770      	bx	lr
    }

    // zero the vector
    void zero()
    {
        x = y = z = 0;
 80035d2:	2300      	movs	r3, #0
 80035d4:	f8c0 30d8 	str.w	r3, [r0, #216]	; 0xd8
 80035d8:	f8c0 30d4 	str.w	r3, [r0, #212]	; 0xd4
 80035dc:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
 80035e0:	f8c0 30f0 	str.w	r3, [r0, #240]	; 0xf0
 80035e4:	f8c0 30ec 	str.w	r3, [r0, #236]	; 0xec
 80035e8:	f8c0 30e8 	str.w	r3, [r0, #232]	; 0xe8
 80035ec:	4770      	bx	lr
		acc_offset_.zero();
		mag_offset_.zero();
		//writeCalibData(); //no need?
		break;
	case MPU_ACC_GYRO_CALIB_CMD:
		calibrate_gyro_ = CALIBRATING_STEP;
 80035ee:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80035f2:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
		calibrate_acc_ = CALIBRATING_STEP;
 80035f6:	f8c0 30c4 	str.w	r3, [r0, #196]	; 0xc4
		break;
 80035fa:	4770      	bx	lr
	case MPU_MAG_CALIB_CMD:
		calibrate_mag_ = CALIBRATING_MAG_STEP;
 80035fc:	4b01      	ldr	r3, [pc, #4]	; (8003604 <_ZN3IMU17imuConfigCallbackERKN8std_msgs5UInt8E+0x40>)
 80035fe:	f8c0 30cc 	str.w	r3, [r0, #204]	; 0xcc
 8003602:	4770      	bx	lr
 8003604:	0001d4c0 	.word	0x0001d4c0

08003608 <_ZN3IMU13getCalibratedEv>:
	else LED0_H;
}

bool IMU::getCalibrated()
{
	if(!calibrate_acc_ && !calibrate_gyro_ && !calibrate_mag_) return true;
 8003608:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
 800360c:	b943      	cbnz	r3, 8003620 <_ZN3IMU13getCalibratedEv+0x18>
 800360e:	f8d0 20c8 	ldr.w	r2, [r0, #200]	; 0xc8
 8003612:	b93a      	cbnz	r2, 8003624 <_ZN3IMU13getCalibratedEv+0x1c>
 8003614:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 8003618:	fab0 f080 	clz	r0, r0
 800361c:	0940      	lsrs	r0, r0, #5
 800361e:	4770      	bx	lr
	else return false;
 8003620:	2000      	movs	r0, #0
 8003622:	4770      	bx	lr
 8003624:	4618      	mov	r0, r3
}
 8003626:	4770      	bx	lr

08003628 <_ZN3IMU13readCalibDataEv>:

void IMU::readCalibData()
{
 8003628:	b510      	push	{r4, lr}
 800362a:	4604      	mov	r4, r0
	HAL_StatusTypeDef status = HAL_ERROR;

	status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800362c:	f24c 3050 	movw	r0, #50000	; 0xc350
 8003630:	f001 f8f6 	bl	8004820 <FLASH_WaitForLastOperation>

	if(status == HAL_OK)
 8003634:	b9e0      	cbnz	r0, 8003670 <_ZN3IMU13readCalibDataEv+0x48>
	{
		for(int i = 0; i < 3; i++)
		{
			acc_offset_[i] = (*(__IO float*)(CALIB_DATA_ADDRESS + CALIB_ACC_ADDRESS + 4 * i));
 8003636:	4b0f      	ldr	r3, [pc, #60]	; (8003674 <_ZN3IMU13readCalibDataEv+0x4c>)
			mag_offset_[i] = (*(__IO float*)(CALIB_DATA_ADDRESS + CALIB_MAG_ADDRESS + 4 * i));
		}
		/* If the program operation is completed, disable the PG Bit */
		FLASH->CR &= (~FLASH_CR_PG);
 8003638:	4a0f      	ldr	r2, [pc, #60]	; (8003678 <_ZN3IMU13readCalibDataEv+0x50>)

	if(status == HAL_OK)
	{
		for(int i = 0; i < 3; i++)
		{
			acc_offset_[i] = (*(__IO float*)(CALIB_DATA_ADDRESS + CALIB_ACC_ADDRESS + 4 * i));
 800363a:	681b      	ldr	r3, [r3, #0]
 800363c:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
			mag_offset_[i] = (*(__IO float*)(CALIB_DATA_ADDRESS + CALIB_MAG_ADDRESS + 4 * i));
 8003640:	4b0e      	ldr	r3, [pc, #56]	; (800367c <_ZN3IMU13readCalibDataEv+0x54>)
 8003642:	681b      	ldr	r3, [r3, #0]
 8003644:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8

	if(status == HAL_OK)
	{
		for(int i = 0; i < 3; i++)
		{
			acc_offset_[i] = (*(__IO float*)(CALIB_DATA_ADDRESS + CALIB_ACC_ADDRESS + 4 * i));
 8003648:	4b0d      	ldr	r3, [pc, #52]	; (8003680 <_ZN3IMU13readCalibDataEv+0x58>)
 800364a:	681b      	ldr	r3, [r3, #0]
 800364c:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
			mag_offset_[i] = (*(__IO float*)(CALIB_DATA_ADDRESS + CALIB_MAG_ADDRESS + 4 * i));
 8003650:	4b0c      	ldr	r3, [pc, #48]	; (8003684 <_ZN3IMU13readCalibDataEv+0x5c>)
 8003652:	681b      	ldr	r3, [r3, #0]
 8003654:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec

	if(status == HAL_OK)
	{
		for(int i = 0; i < 3; i++)
		{
			acc_offset_[i] = (*(__IO float*)(CALIB_DATA_ADDRESS + CALIB_ACC_ADDRESS + 4 * i));
 8003658:	4b0b      	ldr	r3, [pc, #44]	; (8003688 <_ZN3IMU13readCalibDataEv+0x60>)
 800365a:	681b      	ldr	r3, [r3, #0]
 800365c:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
			mag_offset_[i] = (*(__IO float*)(CALIB_DATA_ADDRESS + CALIB_MAG_ADDRESS + 4 * i));
 8003660:	4b0a      	ldr	r3, [pc, #40]	; (800368c <_ZN3IMU13readCalibDataEv+0x64>)
 8003662:	681b      	ldr	r3, [r3, #0]
 8003664:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
		}
		/* If the program operation is completed, disable the PG Bit */
		FLASH->CR &= (~FLASH_CR_PG);
 8003668:	6913      	ldr	r3, [r2, #16]
 800366a:	f023 0301 	bic.w	r3, r3, #1
 800366e:	6113      	str	r3, [r2, #16]
 8003670:	bd10      	pop	{r4, pc}
 8003672:	bf00      	nop
 8003674:	08001000 	.word	0x08001000
 8003678:	40023c00 	.word	0x40023c00
 800367c:	0800100c 	.word	0x0800100c
 8003680:	08001004 	.word	0x08001004
 8003684:	08001010 	.word	0x08001010
 8003688:	08001008 	.word	0x08001008
 800368c:	08001014 	.word	0x08001014

08003690 <_ZN3IMU14writeCalibDataEv>:
	}
}

void IMU::writeCalibData()
{
 8003690:	b570      	push	{r4, r5, r6, lr}
 8003692:	b086      	sub	sp, #24
 8003694:	4604      	mov	r4, r0
	HAL_StatusTypeDef r;

	r = HAL_FLASH_Unlock();
 8003696:	f001 f8a7 	bl	80047e8 <HAL_FLASH_Unlock>
	if( r != HAL_OK ) return;
 800369a:	bb18      	cbnz	r0, 80036e4 <_ZN3IMU14writeCalibDataEv+0x54>

	FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t SectorError = 0;
	EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
	EraseInitStruct.Sector = CALIB_DATA_SECTOR ;
 800369c:	2304      	movs	r3, #4
 800369e:	9303      	str	r3, [sp, #12]
	EraseInitStruct.NbSectors = 1;
 80036a0:	2301      	movs	r3, #1

	r = HAL_FLASH_Unlock();
	if( r != HAL_OK ) return;

	FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t SectorError = 0;
 80036a2:	9000      	str	r0, [sp, #0]
	EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
 80036a4:	9001      	str	r0, [sp, #4]
	EraseInitStruct.Sector = CALIB_DATA_SECTOR ;
	EraseInitStruct.NbSectors = 1;
 80036a6:	9304      	str	r3, [sp, #16]
	EraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3;

	r = HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError);
 80036a8:	4669      	mov	r1, sp
	FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t SectorError = 0;
	EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
	EraseInitStruct.Sector = CALIB_DATA_SECTOR ;
	EraseInitStruct.NbSectors = 1;
	EraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3;
 80036aa:	2302      	movs	r3, #2

	r = HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError);
 80036ac:	a801      	add	r0, sp, #4
	FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t SectorError = 0;
	EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
	EraseInitStruct.Sector = CALIB_DATA_SECTOR ;
	EraseInitStruct.NbSectors = 1;
	EraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3;
 80036ae:	9305      	str	r3, [sp, #20]

	r = HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError);
 80036b0:	f001 f98c 	bl	80049cc <HAL_FLASHEx_Erase>
	if ( r != HAL_OK )
 80036b4:	b9b0      	cbnz	r0, 80036e4 <_ZN3IMU14writeCalibDataEv+0x54>
 80036b6:	4d0c      	ldr	r5, [pc, #48]	; (80036e8 <_ZN3IMU14writeCalibDataEv+0x58>)
		return;

	for(int i = 0; i < 3; i++)
 80036b8:	4e0c      	ldr	r6, [pc, #48]	; (80036ec <_ZN3IMU14writeCalibDataEv+0x5c>)
 80036ba:	34d0      	adds	r4, #208	; 0xd0
	{
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, CALIB_DATA_ADDRESS + CALIB_ACC_ADDRESS + 4 * i, (*(__IO uint64_t*)(&acc_offset_[i])));
 80036bc:	e9d4 2300 	ldrd	r2, r3, [r4]
 80036c0:	4629      	mov	r1, r5
 80036c2:	2002      	movs	r0, #2
 80036c4:	f001 f8d6 	bl	8004874 <HAL_FLASH_Program>
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, CALIB_DATA_ADDRESS + CALIB_MAG_ADDRESS + 4 * i, (*(__IO uint64_t*)(&mag_offset_[i])));
 80036c8:	e9d4 2306 	ldrd	r2, r3, [r4, #24]
 80036cc:	f105 010c 	add.w	r1, r5, #12
 80036d0:	2002      	movs	r0, #2
 80036d2:	3504      	adds	r5, #4
 80036d4:	f001 f8ce 	bl	8004874 <HAL_FLASH_Program>

	r = HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError);
	if ( r != HAL_OK )
		return;

	for(int i = 0; i < 3; i++)
 80036d8:	42b5      	cmp	r5, r6
 80036da:	f104 0404 	add.w	r4, r4, #4
 80036de:	d1ed      	bne.n	80036bc <_ZN3IMU14writeCalibDataEv+0x2c>
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, CALIB_DATA_ADDRESS + CALIB_ACC_ADDRESS + 4 * i, (*(__IO uint64_t*)(&acc_offset_[i])));
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, CALIB_DATA_ADDRESS + CALIB_MAG_ADDRESS + 4 * i, (*(__IO uint64_t*)(&mag_offset_[i])));

	}

	r = HAL_FLASH_Lock();
 80036e0:	f001 f894 	bl	800480c <HAL_FLASH_Lock>
}
 80036e4:	b006      	add	sp, #24
 80036e6:	bd70      	pop	{r4, r5, r6, pc}
 80036e8:	08001000 	.word	0x08001000
 80036ec:	0800100c 	.word	0x0800100c

080036f0 <_ZN3IMU8mpuWriteEhh>:



void IMU::mpuWrite(uint8_t address, uint8_t value)
{
 80036f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	IMU_SPI_CS_L;
 80036f2:	4c11      	ldr	r4, [pc, #68]	; (8003738 <_ZN3IMU8mpuWriteEhh+0x48>)
}



void IMU::mpuWrite(uint8_t address, uint8_t value)
{
 80036f4:	f88d 1007 	strb.w	r1, [sp, #7]
 80036f8:	4605      	mov	r5, r0
 80036fa:	f88d 2006 	strb.w	r2, [sp, #6]
	IMU_SPI_CS_L;
 80036fe:	4620      	mov	r0, r4
 8003700:	2200      	movs	r2, #0
 8003702:	2140      	movs	r1, #64	; 0x40
 8003704:	f001 fa72 	bl	8004bec <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(hspi_, &address, 1, 1000);
 8003708:	f10d 0107 	add.w	r1, sp, #7
 800370c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003710:	2201      	movs	r2, #1
 8003712:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8003714:	f001 fd6d 	bl	80051f2 <HAL_SPI_Transmit>
	HAL_SPI_Transmit(hspi_, &value, 1, 1000);
 8003718:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800371c:	f10d 0106 	add.w	r1, sp, #6
 8003720:	2201      	movs	r2, #1
 8003722:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8003724:	f001 fd65 	bl	80051f2 <HAL_SPI_Transmit>
	IMU_SPI_CS_H;
 8003728:	2201      	movs	r2, #1
 800372a:	2140      	movs	r1, #64	; 0x40
 800372c:	4620      	mov	r0, r4
 800372e:	f001 fa5d 	bl	8004bec <HAL_GPIO_WritePin>
}
 8003732:	b003      	add	sp, #12
 8003734:	bd30      	pop	{r4, r5, pc}
 8003736:	bf00      	nop
 8003738:	40020400 	.word	0x40020400

0800373c <_ZN3IMU8gyroInitEv>:
	IMU_SPI_CS_H;
	return temp;
}

void IMU::gyroInit(void)
{
 800373c:	b510      	push	{r4, lr}
 800373e:	4604      	mov	r4, r0
	HAL_Delay(100);
 8003740:	2064      	movs	r0, #100	; 0x64
 8003742:	f000 fc77 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x6B, 0x80);             //PWR_MGMT_1    -- DEVICE_RESET 1
 8003746:	2280      	movs	r2, #128	; 0x80
 8003748:	216b      	movs	r1, #107	; 0x6b
 800374a:	4620      	mov	r0, r4
 800374c:	f7ff ffd0 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(10);
 8003750:	200a      	movs	r0, #10
 8003752:	f000 fc6f 	bl	8004034 <HAL_Delay>
	//mpuWrite( 0x6B, 0x01);             //PWR_MGMT_1    -- SLEEP 0; CYCLE 0; TEMP_DIS 0; CLKSEL 3 (PLL with Z Gyro reference)
	HAL_Delay(1); //very important!, some duration for process the setting
 8003756:	2001      	movs	r0, #1
 8003758:	f000 fc6c 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x6A, 0x10);             //disable i2c communication
 800375c:	2210      	movs	r2, #16
 800375e:	216a      	movs	r1, #106	; 0x6a
 8003760:	4620      	mov	r0, r4
 8003762:	f7ff ffc5 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1); //very importnat! between gyro and acc
 8003766:	2001      	movs	r0, #1
 8003768:	f000 fc64 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x1A, GYRO_DLPF_CFG); //CONFIG        -- EXT_SYNC_SET 0 (disable input pin for data sync) ; default DLPF_CFG = 0 => ACC bandwidth = 260Hz  GYRO bandwidth = 256Hz)
 800376c:	2201      	movs	r2, #1
 800376e:	211a      	movs	r1, #26
 8003770:	4620      	mov	r0, r4
 8003772:	f7ff ffbd 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1); //very importnat! between gyro and acc
 8003776:	2001      	movs	r0, #1
 8003778:	f000 fc5c 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x1B, 0x18);             //GYRO_CONFIG   -- FS_SEL = 3: Full scale set to 2000 deg/sec
 800377c:	2218      	movs	r2, #24
 800377e:	211b      	movs	r1, #27
 8003780:	4620      	mov	r0, r4
 8003782:	f7ff ffb5 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(10); //very importnat! between gyro and acc
 8003786:	200a      	movs	r0, #10
 8003788:	f000 fc54 	bl	8004034 <HAL_Delay>

	//calib in the first time
	calibrate_gyro_ = CALIBRATING_STEP;
 800378c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003790:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
 8003794:	2300      	movs	r3, #0
 8003796:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
 800379a:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
 800379e:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
 80037a2:	bd10      	pop	{r4, pc}

080037a4 <_ZN3IMU7accInitEv>:
	//calibrate_gyro_ = 0;

	raw_gyro_p_.zero();
}

void IMU::accInit (void) {
 80037a4:	b510      	push	{r4, lr}
	mpuWrite( 0x1C, 0x10); //ACCEL_CONFIG  -- AFS_SEL=2 (Full Scale = +/-8G)  ; ACCELL_HPF=0   //note something is wrong in the spec.
 80037a6:	2210      	movs	r2, #16
 80037a8:	211c      	movs	r1, #28
	//calibrate_gyro_ = 0;

	raw_gyro_p_.zero();
}

void IMU::accInit (void) {
 80037aa:	4604      	mov	r4, r0
	mpuWrite( 0x1C, 0x10); //ACCEL_CONFIG  -- AFS_SEL=2 (Full Scale = +/-8G)  ; ACCELL_HPF=0   //note something is wrong in the spec.
 80037ac:	f7ff ffa0 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 80037b0:	2001      	movs	r0, #1
 80037b2:	f000 fc3f 	bl	8004034 <HAL_Delay>
	//old: acceleration bandwidth is 460Hz
	mpuWrite( 0x1D, ACC_DLPF_CFG);
 80037b6:	2203      	movs	r2, #3
 80037b8:	211d      	movs	r1, #29
 80037ba:	4620      	mov	r0, r4
 80037bc:	f7ff ff98 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(10);
 80037c0:	200a      	movs	r0, #10
 80037c2:	f000 fc37 	bl	8004034 <HAL_Delay>
	calibrate_acc_ = 0;
 80037c6:	2300      	movs	r3, #0
 80037c8:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
 80037cc:	2300      	movs	r3, #0
 80037ce:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
 80037d2:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
 80037d6:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
 80037da:	bd10      	pop	{r4, pc}

080037dc <_ZN3IMU7magInitEv>:
	raw_acc_p_.zero();
}


void IMU::magInit(void)
{
 80037dc:	b510      	push	{r4, lr}
 80037de:	4604      	mov	r4, r0
	HAL_Delay(10);
 80037e0:	200a      	movs	r0, #10
 80037e2:	f000 fc27 	bl	8004034 <HAL_Delay>
	//at this stage, the MAG is configured via the original MAG init function in I2C bypass mode
	//now we configure MPU as a I2C Master device to handle the MAG via the I2C AUX port (done here for HMC5883)
	mpuWrite( 0x6A, 0x20); //USER_CTRL -- DMP_EN=0 ; FIFO_EN=0 ; I2C_MST_EN=1 (I2C master mode) ; I2C_IF_DIS=0 ; FIFO_RESET=0 ; I2C_MST_RESET=0 ; SIG_COND_RESET=0
 80037e6:	2220      	movs	r2, #32
 80037e8:	216a      	movs	r1, #106	; 0x6a
 80037ea:	4620      	mov	r0, r4
 80037ec:	f7ff ff80 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(10);
 80037f0:	200a      	movs	r0, #10
 80037f2:	f000 fc1f 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x37, 0x00); //INT_PIN_CFG -- INT_LEVEL=0 ; INT_OPEN=0 ; LATCH_INT_EN=0 ; INT_RD_CLEAR=0 ; FSYNC_INT_LEVEL=0 ; FSYNC_INT_EN=0 ; I2C_BYPASS_EN=0 ; CLKOUT_EN=0
 80037f6:	2200      	movs	r2, #0
 80037f8:	2137      	movs	r1, #55	; 0x37
 80037fa:	4620      	mov	r0, r4
 80037fc:	f7ff ff78 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003800:	2001      	movs	r0, #1
 8003802:	f000 fc17 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x24, 0x0D); //I2C_MST_CTRL -- MULT_MST_EN=0 ; WAIT_FOR_ES=0 ; SLV_3_FIFO_EN=0 ; I2C_MST_P_NSR=0 ; I2C_MST_CLK=13 (I2C slave speed bus = 400kHz)
 8003806:	220d      	movs	r2, #13
 8003808:	2124      	movs	r1, #36	; 0x24
 800380a:	4620      	mov	r0, r4
 800380c:	f7ff ff70 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003810:	2001      	movs	r0, #1
 8003812:	f000 fc0f 	bl	8004034 <HAL_Delay>

	//write mode
	mpuWrite( 0x25, MAG_ADDRESS);
 8003816:	220c      	movs	r2, #12
 8003818:	2125      	movs	r1, #37	; 0x25
 800381a:	4620      	mov	r0, r4
 800381c:	f7ff ff68 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003820:	2001      	movs	r0, #1
 8003822:	f000 fc07 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x26, 0x0B);
 8003826:	220b      	movs	r2, #11
 8003828:	2126      	movs	r1, #38	; 0x26
 800382a:	4620      	mov	r0, r4
 800382c:	f7ff ff60 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003830:	2001      	movs	r0, #1
 8003832:	f000 fbff 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x63, 0x01);
 8003836:	2201      	movs	r2, #1
 8003838:	2163      	movs	r1, #99	; 0x63
 800383a:	4620      	mov	r0, r4
 800383c:	f7ff ff58 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003840:	2001      	movs	r0, #1
 8003842:	f000 fbf7 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x27, 0x81);
 8003846:	2281      	movs	r2, #129	; 0x81
 8003848:	2127      	movs	r1, #39	; 0x27
 800384a:	4620      	mov	r0, r4
 800384c:	f7ff ff50 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003850:	2001      	movs	r0, #1
 8003852:	f000 fbef 	bl	8004034 <HAL_Delay>

	mpuWrite( 0x26, 0x0A);
 8003856:	220a      	movs	r2, #10
 8003858:	2126      	movs	r1, #38	; 0x26
 800385a:	4620      	mov	r0, r4
 800385c:	f7ff ff48 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003860:	2001      	movs	r0, #1
 8003862:	f000 fbe7 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x63, 0x16);
 8003866:	2216      	movs	r2, #22
 8003868:	2163      	movs	r1, #99	; 0x63
 800386a:	4620      	mov	r0, r4
 800386c:	f7ff ff40 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003870:	2001      	movs	r0, #1
 8003872:	f000 fbdf 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x27, 0x81);
 8003876:	2281      	movs	r2, #129	; 0x81
 8003878:	2127      	movs	r1, #39	; 0x27
 800387a:	4620      	mov	r0, r4
 800387c:	f7ff ff38 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003880:	2001      	movs	r0, #1
 8003882:	f000 fbd7 	bl	8004034 <HAL_Delay>

	//read mode
	mpuWrite( 0x25, 0x80|MAG_ADDRESS);//I2C_SLV0_ADDR -- I2C_SLV4_RW=1 (read operation) ; I2C_SLV4_ADDR=MAG_ADDRESS
 8003886:	228c      	movs	r2, #140	; 0x8c
 8003888:	2125      	movs	r1, #37	; 0x25
 800388a:	4620      	mov	r0, r4
 800388c:	f7ff ff30 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 8003890:	2001      	movs	r0, #1
 8003892:	f000 fbcf 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x26, MAG_DATA_REGISTER);//I2C_SLV0_REG -- 6 data bytes of MAG are stored in 6 registers. First register address is MAG_DATA_REGISTER
 8003896:	2203      	movs	r2, #3
 8003898:	2126      	movs	r1, #38	; 0x26
 800389a:	4620      	mov	r0, r4
 800389c:	f7ff ff28 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 80038a0:	2001      	movs	r0, #1
 80038a2:	f000 fbc7 	bl	8004034 <HAL_Delay>
	mpuWrite( 0x27, 0x87);
 80038a6:	2287      	movs	r2, #135	; 0x87
 80038a8:	2127      	movs	r1, #39	; 0x27
 80038aa:	4620      	mov	r0, r4
 80038ac:	f7ff ff20 	bl	80036f0 <_ZN3IMU8mpuWriteEhh>
	HAL_Delay(1);
 80038b0:	2001      	movs	r0, #1
 80038b2:	f000 fbbf 	bl	8004034 <HAL_Delay>

	calibrate_mag_ = 0;
 80038b6:	2300      	movs	r3, #0
 80038b8:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
 80038bc:	bd10      	pop	{r4, pc}
	...

080038c0 <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE>:
{
	init(hspi, nh);
}

void IMU::init(SPI_HandleTypeDef* hspi, ros::NodeHandle* nh)
{
 80038c0:	b570      	push	{r4, r5, r6, lr}
 80038c2:	2300      	movs	r3, #0
	reset_calib_flag_  = 0;
 80038c4:	2500      	movs	r5, #0
{
	init(hspi, nh);
}

void IMU::init(SPI_HandleTypeDef* hspi, ros::NodeHandle* nh)
{
 80038c6:	4604      	mov	r4, r0
 80038c8:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
 80038cc:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
 80038d0:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
 80038d4:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
 80038d8:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
 80038dc:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
 80038e0:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
 80038e4:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
 80038e8:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
	reset_calib_flag_  = 0;

	acc_.zero();
	gyro_.zero();
	mag_.zero();
	nh_ = nh;
 80038ec:	6342      	str	r2, [r0, #52]	; 0x34
	init(hspi, nh);
}

void IMU::init(SPI_HandleTypeDef* hspi, ros::NodeHandle* nh)
{
	reset_calib_flag_  = 0;
 80038ee:	f880 503e 	strb.w	r5, [r0, #62]	; 0x3e
	acc_.zero();
	gyro_.zero();
	mag_.zero();
	nh_ = nh;

	imu_config_sub_ = new ros::Subscriber2<std_msgs::UInt8, IMU> ("/imu_config_cmd", &IMU::imuConfigCallback, this );
 80038f2:	2024      	movs	r0, #36	; 0x24
{
	init(hspi, nh);
}

void IMU::init(SPI_HandleTypeDef* hspi, ros::NodeHandle* nh)
{
 80038f4:	460e      	mov	r6, r1
	acc_.zero();
	gyro_.zero();
	mag_.zero();
	nh_ = nh;

	imu_config_sub_ = new ros::Subscriber2<std_msgs::UInt8, IMU> ("/imu_config_cmd", &IMU::imuConfigCallback, this );
 80038f6:	f003 f969 	bl	8006bcc <_Znwj>
    public:
      typedef void(T::*CallbackT)(const MsgT&);
      MsgT msg;

      Subscriber2(const char * topic_name, CallbackT cb, T *obj,  int endpoint=rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
        obj_(obj), fun_obj_(cb), endpoint_(endpoint)
 80038fa:	4b1f      	ldr	r3, [pc, #124]	; (8003978 <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0xb8>)
 80038fc:	6003      	str	r3, [r0, #0]
  {
    public:
      uint8_t data;

    UInt8():
      data(0)
 80038fe:	4b1f      	ldr	r3, [pc, #124]	; (800397c <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0xbc>)
 8003900:	60c3      	str	r3, [r0, #12]
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }
 8003902:	4b1f      	ldr	r3, [pc, #124]	; (8003980 <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0xc0>)
 8003904:	6183      	str	r3, [r0, #24]
	nh_->subscribe<std_msgs::UInt8, IMU>(*imu_config_sub_);
 8003906:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003908:	7405      	strb	r5, [r0, #16]
 800390a:	2301      	movs	r3, #1
 800390c:	6203      	str	r3, [r0, #32]
      {
        //std::binder1st t  = std::bind1st(std::mem_fun1_t())
        topic_ = topic_name;
 800390e:	4b1d      	ldr	r3, [pc, #116]	; (8003984 <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0xc4>)
 8003910:	6083      	str	r3, [r0, #8]
    public:
      typedef void(T::*CallbackT)(const MsgT&);
      MsgT msg;

      Subscriber2(const char * topic_name, CallbackT cb, T *obj,  int endpoint=rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
        obj_(obj), fun_obj_(cb), endpoint_(endpoint)
 8003912:	6144      	str	r4, [r0, #20]
 8003914:	61c5      	str	r5, [r0, #28]
	acc_.zero();
	gyro_.zero();
	mag_.zero();
	nh_ = nh;

	imu_config_sub_ = new ros::Subscriber2<std_msgs::UInt8, IMU> ("/imu_config_cmd", &IMU::imuConfigCallback, this );
 8003916:	63a0      	str	r0, [r4, #56]	; 0x38
 8003918:	f502 711a 	add.w	r1, r2, #616	; 0x268
      return false;
    }
    /* Register a new subscriber, which is a member of class*/
    template<typename MsgT, class T>
    bool subscribe(Subscriber2< MsgT, T> & s){
      for(int i = 0; i < MAX_SUBSCRIBERS; i++){
 800391c:	462b      	mov	r3, r5
        if(subscribers[i] == 0){ // empty slot
 800391e:	f851 5f04 	ldr.w	r5, [r1, #4]!
 8003922:	b935      	cbnz	r5, 8003932 <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x72>
          subscribers[i] = (Subscriber_*) &s;
 8003924:	eb02 0283 	add.w	r2, r2, r3, lsl #2
          s.id_ = i+100;
 8003928:	3364      	adds	r3, #100	; 0x64
    /* Register a new subscriber, which is a member of class*/
    template<typename MsgT, class T>
    bool subscribe(Subscriber2< MsgT, T> & s){
      for(int i = 0; i < MAX_SUBSCRIBERS; i++){
        if(subscribers[i] == 0){ // empty slot
          subscribers[i] = (Subscriber_*) &s;
 800392a:	f8c2 026c 	str.w	r0, [r2, #620]	; 0x26c
          s.id_ = i+100;
 800392e:	6043      	str	r3, [r0, #4]
 8003930:	e002      	b.n	8003938 <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x78>
      return false;
    }
    /* Register a new subscriber, which is a member of class*/
    template<typename MsgT, class T>
    bool subscribe(Subscriber2< MsgT, T> & s){
      for(int i = 0; i < MAX_SUBSCRIBERS; i++){
 8003932:	3301      	adds	r3, #1
 8003934:	2b14      	cmp	r3, #20
 8003936:	d1f2      	bne.n	800391e <_ZN3IMU4initEP19__SPI_HandleTypeDefPN3ros11NodeHandle_I13STMF4HardwareLi20ELi20ELi255ELi255EEE+0x5e>
	nh_->subscribe<std_msgs::UInt8, IMU>(*imu_config_sub_);

	ahb_suspend_flag_ = false;
 8003938:	2300      	movs	r3, #0
	mag_filtering_flag_ = true;
 800393a:	2201      	movs	r2, #1
	nh_ = nh;

	imu_config_sub_ = new ros::Subscriber2<std_msgs::UInt8, IMU> ("/imu_config_cmd", &IMU::imuConfigCallback, this );
	nh_->subscribe<std_msgs::UInt8, IMU>(*imu_config_sub_);

	ahb_suspend_flag_ = false;
 800393c:	f884 3111 	strb.w	r3, [r4, #273]	; 0x111
	mag_filtering_flag_ = true;
 8003940:	f884 210c 	strb.w	r2, [r4, #268]	; 0x10c
	mag_outlier_counter_ = 0;
 8003944:	f8a4 310e 	strh.w	r3, [r4, #270]	; 0x10e

	hspi_ = hspi;
	readCalibData();
 8003948:	4620      	mov	r0, r4

	ahb_suspend_flag_ = false;
	mag_filtering_flag_ = true;
	mag_outlier_counter_ = 0;

	hspi_ = hspi;
 800394a:	6326      	str	r6, [r4, #48]	; 0x30
	readCalibData();
 800394c:	f7ff fe6c 	bl	8003628 <_ZN3IMU13readCalibDataEv>
	gyroInit();
 8003950:	4620      	mov	r0, r4
 8003952:	f7ff fef3 	bl	800373c <_ZN3IMU8gyroInitEv>
	accInit();
 8003956:	4620      	mov	r0, r4
 8003958:	f7ff ff24 	bl	80037a4 <_ZN3IMU7accInitEv>
	magInit();
 800395c:	4620      	mov	r0, r4
 800395e:	f7ff ff3d 	bl	80037dc <_ZN3IMU7magInitEv>

	/* change to 13.5Mhz for polling sensor data from acc, gyro and mag */
	hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
 8003962:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003964:	681b      	ldr	r3, [r3, #0]
 8003966:	681a      	ldr	r2, [r3, #0]
 8003968:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 800396c:	601a      	str	r2, [r3, #0]
	hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz
 800396e:	681a      	ldr	r2, [r3, #0]
 8003970:	f042 0210 	orr.w	r2, r2, #16
 8003974:	601a      	str	r2, [r3, #0]
 8003976:	bd70      	pop	{r4, r5, r6, pc}
 8003978:	08009174 	.word	0x08009174
 800397c:	0800915c 	.word	0x0800915c
 8003980:	080035c5 	.word	0x080035c5
 8003984:	080091b4 	.word	0x080091b4

08003988 <_ZN3IMU4readEv>:

	calibrate_mag_ = 0;
}

void IMU::read()
{
 8003988:	b570      	push	{r4, r5, r6, lr}
 800398a:	b088      	sub	sp, #32
	uint8_t adc_gyro[6];
	uint8_t adc_acc[6];
	uint8_t adc_mag[7];

	uint8_t t_data[1];
	t_data[0] = 0x43 | 0x80;
 800398c:	ad08      	add	r5, sp, #32
 800398e:	23c3      	movs	r3, #195	; 0xc3

	calibrate_mag_ = 0;
}

void IMU::read()
{
 8003990:	4604      	mov	r4, r0
	uint8_t adc_gyro[6];
	uint8_t adc_acc[6];
	uint8_t adc_mag[7];

	uint8_t t_data[1];
	t_data[0] = 0x43 | 0x80;
 8003992:	f805 3d1c 	strb.w	r3, [r5, #-28]!

	IMU_SPI_CS_L;
 8003996:	2200      	movs	r2, #0
 8003998:	2140      	movs	r1, #64	; 0x40
 800399a:	4891      	ldr	r0, [pc, #580]	; (8003be0 <_ZN3IMU4readEv+0x258>)
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
	raw_acc_adc_[2] = (int16_t)(adc_acc[4] << 8 | adc_acc[5]) / 4096.0f * GRAVITY_MSS;


	if(i == MAG_PRESCALER)
 800399c:	4e91      	ldr	r6, [pc, #580]	; (8003be4 <_ZN3IMU4readEv+0x25c>)
	uint8_t adc_mag[7];

	uint8_t t_data[1];
	t_data[0] = 0x43 | 0x80;

	IMU_SPI_CS_L;
 800399e:	f001 f925 	bl	8004bec <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
 80039a2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80039a6:	2201      	movs	r2, #1
 80039a8:	4629      	mov	r1, r5
 80039aa:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80039ac:	f001 fc21 	bl	80051f2 <HAL_SPI_Transmit>
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
 80039b0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80039b4:	2206      	movs	r2, #6
 80039b6:	a902      	add	r1, sp, #8
 80039b8:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80039ba:	f001 fdd2 	bl	8005562 <HAL_SPI_Receive>
	IMU_SPI_CS_H;
 80039be:	2201      	movs	r2, #1
 80039c0:	2140      	movs	r1, #64	; 0x40
 80039c2:	4887      	ldr	r0, [pc, #540]	; (8003be0 <_ZN3IMU4readEv+0x258>)
 80039c4:	f001 f912 	bl	8004bec <HAL_GPIO_WritePin>

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 80039c8:	f89d 2008 	ldrb.w	r2, [sp, #8]
 80039cc:	f89d 3009 	ldrb.w	r3, [sp, #9]
 80039d0:	ed9f 5a85 	vldr	s10, [pc, #532]	; 8003be8 <_ZN3IMU4readEv+0x260>
 80039d4:	eddf 5a85 	vldr	s11, [pc, #532]	; 8003bec <_ZN3IMU4readEv+0x264>
 80039d8:	ed9f 6a85 	vldr	s12, [pc, #532]	; 8003bf0 <_ZN3IMU4readEv+0x268>
 80039dc:	eddf 6a85 	vldr	s13, [pc, #532]	; 8003bf4 <_ZN3IMU4readEv+0x26c>
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;

	t_data[0] = 0x3B | 0x80;
	IMU_SPI_CS_L;
 80039e0:	487f      	ldr	r0, [pc, #508]	; (8003be0 <_ZN3IMU4readEv+0x258>)
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 80039e2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80039e6:	b21b      	sxth	r3, r3
 80039e8:	ee07 3a10 	vmov	s14, r3
 80039ec:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 80039f0:	f89d 200a 	ldrb.w	r2, [sp, #10]
 80039f4:	f89d 300b 	ldrb.w	r3, [sp, #11]
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 80039f8:	ee27 7a05 	vmul.f32	s14, s14, s10
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 80039fc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a00:	eec7 7a25 	vdiv.f32	s15, s14, s11
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a04:	b21b      	sxth	r3, r3
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a06:	f89d 200c 	ldrb.w	r2, [sp, #12]

	t_data[0] = 0x3B | 0x80;
	IMU_SPI_CS_L;
 8003a0a:	2140      	movs	r1, #64	; 0x40
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a0c:	ee67 7a86 	vmul.f32	s15, s15, s12
 8003a10:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8003a14:	ed84 7a10 	vstr	s14, [r4, #64]	; 0x40
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a18:	ee07 3a10 	vmov	s14, r3
 8003a1c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a20:	f89d 300d 	ldrb.w	r3, [sp, #13]
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a24:	ee27 7a05 	vmul.f32	s14, s14, s10
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a28:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a2c:	eec7 7a25 	vdiv.f32	s15, s14, s11
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a30:	b21b      	sxth	r3, r3

	t_data[0] = 0x3B | 0x80;
	IMU_SPI_CS_L;
 8003a32:	2200      	movs	r2, #0
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a34:	ee67 7a86 	vmul.f32	s15, s15, s12
 8003a38:	ee87 7aa6 	vdiv.f32	s14, s15, s13
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a3c:	ee07 3a90 	vmov	s15, r3
 8003a40:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	HAL_SPI_Receive(hspi_, adc_gyro, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a44:	ed84 7a11 	vstr	s14, [r4, #68]	; 0x44
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a48:	ee67 7a85 	vmul.f32	s15, s15, s10

	t_data[0] = 0x3B | 0x80;
 8003a4c:	23bb      	movs	r3, #187	; 0xbb
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a4e:	ee87 7aa5 	vdiv.f32	s14, s15, s11

	t_data[0] = 0x3B | 0x80;
 8003a52:	f88d 3004 	strb.w	r3, [sp, #4]
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_gyro_adc_[0] = (int16_t)(adc_gyro[0] << 8 | adc_gyro[1]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[1] = (int16_t)(adc_gyro[2] << 8 | adc_gyro[3]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
	raw_gyro_adc_[2] = (int16_t)(adc_gyro[4] << 8 | adc_gyro[5]) * 2000.0f / 32767.0f * M_PI / 180.0f  ;
 8003a56:	ee67 7a06 	vmul.f32	s15, s14, s12
 8003a5a:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8003a5e:	ed84 7a12 	vstr	s14, [r4, #72]	; 0x48

	t_data[0] = 0x3B | 0x80;
	IMU_SPI_CS_L;
 8003a62:	f001 f8c3 	bl	8004bec <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
 8003a66:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003a6a:	2201      	movs	r2, #1
 8003a6c:	4629      	mov	r1, r5
 8003a6e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8003a70:	f001 fbbf 	bl	80051f2 <HAL_SPI_Transmit>
	HAL_SPI_Receive(hspi_, adc_acc, 6, 1000);
 8003a74:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003a78:	2206      	movs	r2, #6
 8003a7a:	a904      	add	r1, sp, #16
 8003a7c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8003a7e:	f001 fd70 	bl	8005562 <HAL_SPI_Receive>
	IMU_SPI_CS_H;
 8003a82:	2201      	movs	r2, #1
 8003a84:	2140      	movs	r1, #64	; 0x40
 8003a86:	4856      	ldr	r0, [pc, #344]	; (8003be0 <_ZN3IMU4readEv+0x258>)
 8003a88:	f001 f8b0 	bl	8004bec <HAL_GPIO_WritePin>

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
 8003a8c:	f89d 2010 	ldrb.w	r2, [sp, #16]
 8003a90:	f89d 3011 	ldrb.w	r3, [sp, #17]
 8003a94:	ed9f 6a58 	vldr	s12, [pc, #352]	; 8003bf8 <_ZN3IMU4readEv+0x270>
 8003a98:	eddf 6a58 	vldr	s13, [pc, #352]	; 8003bfc <_ZN3IMU4readEv+0x274>
 8003a9c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003aa0:	b21b      	sxth	r3, r3
 8003aa2:	ee07 3a10 	vmov	s14, r3
 8003aa6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
 8003aaa:	f89d 2012 	ldrb.w	r2, [sp, #18]
 8003aae:	f89d 3013 	ldrb.w	r3, [sp, #19]
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
	HAL_SPI_Receive(hspi_, adc_acc, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
 8003ab2:	ee27 7a06 	vmul.f32	s14, s14, s12
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
 8003ab6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
	HAL_SPI_Receive(hspi_, adc_acc, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
 8003aba:	ee27 7a26 	vmul.f32	s14, s14, s13
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
 8003abe:	b21b      	sxth	r3, r3
	HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
	HAL_SPI_Receive(hspi_, adc_acc, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
 8003ac0:	ed84 7a13 	vstr	s14, [r4, #76]	; 0x4c
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
 8003ac4:	ee07 3a10 	vmov	s14, r3
	raw_acc_adc_[2] = (int16_t)(adc_acc[4] << 8 | adc_acc[5]) / 4096.0f * GRAVITY_MSS;
 8003ac8:	f89d 2014 	ldrb.w	r2, [sp, #20]
 8003acc:	f89d 3015 	ldrb.w	r3, [sp, #21]
	HAL_SPI_Receive(hspi_, adc_acc, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
 8003ad0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
	raw_acc_adc_[2] = (int16_t)(adc_acc[4] << 8 | adc_acc[5]) / 4096.0f * GRAVITY_MSS;
 8003ad4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	HAL_SPI_Receive(hspi_, adc_acc, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
 8003ad8:	ee27 7a06 	vmul.f32	s14, s14, s12
	raw_acc_adc_[2] = (int16_t)(adc_acc[4] << 8 | adc_acc[5]) / 4096.0f * GRAVITY_MSS;
 8003adc:	b21b      	sxth	r3, r3
 8003ade:	ee07 3a90 	vmov	s15, r3
	HAL_SPI_Receive(hspi_, adc_acc, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
 8003ae2:	ee27 7a26 	vmul.f32	s14, s14, s13
	raw_acc_adc_[2] = (int16_t)(adc_acc[4] << 8 | adc_acc[5]) / 4096.0f * GRAVITY_MSS;


	if(i == MAG_PRESCALER)
 8003ae6:	6833      	ldr	r3, [r6, #0]
	HAL_SPI_Receive(hspi_, adc_acc, 6, 1000);
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
 8003ae8:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
	raw_acc_adc_[2] = (int16_t)(adc_acc[4] << 8 | adc_acc[5]) / 4096.0f * GRAVITY_MSS;
 8003aec:	eeb8 7ae7 	vcvt.f32.s32	s14, s15


	if(i == MAG_PRESCALER)
 8003af0:	2b04      	cmp	r3, #4
	IMU_SPI_CS_H;

	/* we need add some delay between each sensor reading */
	raw_acc_adc_[0] = (int16_t)(adc_acc[0] << 8 | adc_acc[1]) / 4096.0f * GRAVITY_MSS;
	raw_acc_adc_[1] = (int16_t)(adc_acc[2] << 8 | adc_acc[3]) / 4096.0f * GRAVITY_MSS;
	raw_acc_adc_[2] = (int16_t)(adc_acc[4] << 8 | adc_acc[5]) / 4096.0f * GRAVITY_MSS;
 8003af2:	ee67 7a06 	vmul.f32	s15, s14, s12
 8003af6:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8003afa:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54


	if(i == MAG_PRESCALER)
 8003afe:	d165      	bne.n	8003bcc <_ZN3IMU4readEv+0x244>
	{
		//mag is in low speed
		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
 8003b00:	6b23      	ldr	r3, [r4, #48]	; 0x30
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_64); //128 = 0.8Mhz
		t_data[0] = 0x49 | 0x80;
		IMU_SPI_CS_L;
 8003b02:	4837      	ldr	r0, [pc, #220]	; (8003be0 <_ZN3IMU4readEv+0x258>)


	if(i == MAG_PRESCALER)
	{
		//mag is in low speed
		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
 8003b04:	681b      	ldr	r3, [r3, #0]
 8003b06:	681a      	ldr	r2, [r3, #0]
 8003b08:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 8003b0c:	601a      	str	r2, [r3, #0]
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_64); //128 = 0.8Mhz
 8003b0e:	681a      	ldr	r2, [r3, #0]
 8003b10:	f042 0228 	orr.w	r2, r2, #40	; 0x28
 8003b14:	601a      	str	r2, [r3, #0]
		t_data[0] = 0x49 | 0x80;
		IMU_SPI_CS_L;
 8003b16:	2140      	movs	r1, #64	; 0x40
	if(i == MAG_PRESCALER)
	{
		//mag is in low speed
		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_64); //128 = 0.8Mhz
		t_data[0] = 0x49 | 0x80;
 8003b18:	23c9      	movs	r3, #201	; 0xc9
		IMU_SPI_CS_L;
 8003b1a:	2200      	movs	r2, #0
	if(i == MAG_PRESCALER)
	{
		//mag is in low speed
		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_64); //128 = 0.8Mhz
		t_data[0] = 0x49 | 0x80;
 8003b1c:	f88d 3004 	strb.w	r3, [sp, #4]
		IMU_SPI_CS_L;
 8003b20:	f001 f864 	bl	8004bec <HAL_GPIO_WritePin>
		HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
 8003b24:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003b28:	2201      	movs	r2, #1
 8003b2a:	4629      	mov	r1, r5
 8003b2c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8003b2e:	f001 fb60 	bl	80051f2 <HAL_SPI_Transmit>
		HAL_SPI_Receive(hspi_, adc_mag, 7, 1000);
 8003b32:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003b36:	2207      	movs	r2, #7
 8003b38:	a906      	add	r1, sp, #24
 8003b3a:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8003b3c:	f001 fd11 	bl	8005562 <HAL_SPI_Receive>
		IMU_SPI_CS_H;
 8003b40:	2201      	movs	r2, #1
 8003b42:	2140      	movs	r1, #64	; 0x40
 8003b44:	4826      	ldr	r0, [pc, #152]	; (8003be0 <_ZN3IMU4readEv+0x258>)
 8003b46:	f001 f851 	bl	8004bec <HAL_GPIO_WritePin>

		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
 8003b4a:	6b23      	ldr	r3, [r4, #48]	; 0x30
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
 8003b4c:	ed9f 6a2c 	vldr	s12, [pc, #176]	; 8003c00 <_ZN3IMU4readEv+0x278>
		IMU_SPI_CS_L;
		HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
		HAL_SPI_Receive(hspi_, adc_mag, 7, 1000);
		IMU_SPI_CS_H;

		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
 8003b50:	681b      	ldr	r3, [r3, #0]
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
 8003b52:	eddf 6a2c 	vldr	s13, [pc, #176]	; 8003c04 <_ZN3IMU4readEv+0x27c>
		IMU_SPI_CS_L;
		HAL_SPI_Transmit(hspi_, t_data, 1, 1000);
		HAL_SPI_Receive(hspi_, adc_mag, 7, 1000);
		IMU_SPI_CS_H;

		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
 8003b56:	681a      	ldr	r2, [r3, #0]
 8003b58:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 8003b5c:	601a      	str	r2, [r3, #0]
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz
 8003b5e:	681a      	ldr	r2, [r3, #0]
 8003b60:	f042 0210 	orr.w	r2, r2, #16
 8003b64:	601a      	str	r2, [r3, #0]

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
 8003b66:	f89d 2019 	ldrb.w	r2, [sp, #25]
 8003b6a:	f89d 3018 	ldrb.w	r3, [sp, #24]
 8003b6e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003b72:	b21b      	sxth	r3, r3
 8003b74:	ee07 3a10 	vmov	s14, r3
 8003b78:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
		raw_mag_adc_[1] = (int16_t)(adc_mag[3] << 8 | adc_mag[2]) * 4912.0f / 32760.0f;
 8003b7c:	f89d 201b 	ldrb.w	r2, [sp, #27]
 8003b80:	f89d 301a 	ldrb.w	r3, [sp, #26]

		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
 8003b84:	ee27 7a06 	vmul.f32	s14, s14, s12
		raw_mag_adc_[1] = (int16_t)(adc_mag[3] << 8 | adc_mag[2]) * 4912.0f / 32760.0f;
 8003b88:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
 8003b8c:	eec7 7a26 	vdiv.f32	s15, s14, s13
		raw_mag_adc_[1] = (int16_t)(adc_mag[3] << 8 | adc_mag[2]) * 4912.0f / 32760.0f;
 8003b90:	b21b      	sxth	r3, r3
		raw_mag_adc_[2] = (int16_t)(adc_mag[5] << 8 | adc_mag[4]) * 4912.0f / 32760.0f;
 8003b92:	f89d 201d 	ldrb.w	r2, [sp, #29]
		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
		raw_mag_adc_[1] = (int16_t)(adc_mag[3] << 8 | adc_mag[2]) * 4912.0f / 32760.0f;
 8003b96:	ee07 3a10 	vmov	s14, r3
 8003b9a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14

		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
 8003b9e:	edc4 7a16 	vstr	s15, [r4, #88]	; 0x58
		raw_mag_adc_[1] = (int16_t)(adc_mag[3] << 8 | adc_mag[2]) * 4912.0f / 32760.0f;
 8003ba2:	ee27 7a06 	vmul.f32	s14, s14, s12
		raw_mag_adc_[2] = (int16_t)(adc_mag[5] << 8 | adc_mag[4]) * 4912.0f / 32760.0f;
 8003ba6:	f89d 301c 	ldrb.w	r3, [sp, #28]
		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
		raw_mag_adc_[1] = (int16_t)(adc_mag[3] << 8 | adc_mag[2]) * 4912.0f / 32760.0f;
 8003baa:	eec7 7a26 	vdiv.f32	s15, s14, s13
		raw_mag_adc_[2] = (int16_t)(adc_mag[5] << 8 | adc_mag[4]) * 4912.0f / 32760.0f;
 8003bae:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003bb2:	b21b      	sxth	r3, r3
		hspi_->Instance->CR1 &= (uint32_t)(~SPI_BAUDRATEPRESCALER_256); //reset
		hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

		//uT(10e-6 T)
		raw_mag_adc_[0] = (int16_t)(adc_mag[1] << 8 | adc_mag[0]) * 4912.0f / 32760.0f;
		raw_mag_adc_[1] = (int16_t)(adc_mag[3] << 8 | adc_mag[2]) * 4912.0f / 32760.0f;
 8003bb4:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
		raw_mag_adc_[2] = (int16_t)(adc_mag[5] << 8 | adc_mag[4]) * 4912.0f / 32760.0f;
 8003bb8:	ee07 3a90 	vmov	s15, r3
 8003bbc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8003bc0:	ee67 7a86 	vmul.f32	s15, s15, s12
 8003bc4:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8003bc8:	ed84 7a18 	vstr	s14, [r4, #96]	; 0x60
	}
	if(i == MAG_PRESCALER) i =0;
 8003bcc:	6833      	ldr	r3, [r6, #0]
 8003bce:	4a05      	ldr	r2, [pc, #20]	; (8003be4 <_ZN3IMU4readEv+0x25c>)
 8003bd0:	2b04      	cmp	r3, #4
 8003bd2:	bf0c      	ite	eq
 8003bd4:	2300      	moveq	r3, #0
	else i++;
 8003bd6:	3301      	addne	r3, #1
 8003bd8:	6013      	str	r3, [r2, #0]

}
 8003bda:	b008      	add	sp, #32
 8003bdc:	bd70      	pop	{r4, r5, r6, pc}
 8003bde:	bf00      	nop
 8003be0:	40020400 	.word	0x40020400
 8003be4:	20000a1c 	.word	0x20000a1c
 8003be8:	44fa0000 	.word	0x44fa0000
 8003bec:	46fffe00 	.word	0x46fffe00
 8003bf0:	40490fdb 	.word	0x40490fdb
 8003bf4:	43340000 	.word	0x43340000
 8003bf8:	39800000 	.word	0x39800000
 8003bfc:	411ce80a 	.word	0x411ce80a
 8003c00:	45998000 	.word	0x45998000
 8003c04:	46fff000 	.word	0x46fff000

08003c08 <_ZN3IMU7processEv>:

void IMU::process (void) 
{
 8003c08:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

	/* gyro part */
	if (calibrate_gyro_ > 0)
 8003c0a:	f8d0 30c8 	ldr.w	r3, [r0, #200]	; 0xc8
 8003c0e:	2b00      	cmp	r3, #0
	else i++;

}

void IMU::process (void) 
{
 8003c10:	4604      	mov	r4, r0
 8003c12:	f100 05dc 	add.w	r5, r0, #220	; 0xdc
 8003c16:	f100 0040 	add.w	r0, r0, #64	; 0x40

	/* gyro part */
	if (calibrate_gyro_ > 0)
 8003c1a:	dd1c      	ble.n	8003c56 <_ZN3IMU7processEv+0x4e>
	{
		if (calibrate_gyro_ == CALIBRATING_STEP)
 8003c1c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8003c20:	bf01      	itttt	eq
 8003c22:	2300      	moveq	r3, #0
 8003c24:	f8c4 30e4 	streq.w	r3, [r4, #228]	; 0xe4
 8003c28:	f8c4 30e0 	streq.w	r3, [r4, #224]	; 0xe0
 8003c2c:	f8c4 30dc 	streq.w	r3, [r4, #220]	; 0xdc
			gyro_offset_.zero();

		gyro_offset_ += raw_gyro_adc_;
 8003c30:	4601      	mov	r1, r0
 8003c32:	4628      	mov	r0, r5
 8003c34:	f002 f9c0 	bl	8005fb8 <_ZN7Vector3IfEpLERKS0_>
		if (calibrate_gyro_ == 1)
 8003c38:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8003c3c:	2b01      	cmp	r3, #1
 8003c3e:	d104      	bne.n	8003c4a <_ZN3IMU7processEv+0x42>
		{
			gyro_offset_ /= (float)CALIBRATING_STEP;
 8003c40:	ed9f 0ab2 	vldr	s0, [pc, #712]	; 8003f0c <_ZN3IMU7processEv+0x304>
 8003c44:	4628      	mov	r0, r5
 8003c46:	f002 f95d 	bl	8005f04 <_ZN7Vector3IfEdVEf>
		}
		calibrate_gyro_--;
 8003c4a:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8003c4e:	3b01      	subs	r3, #1
 8003c50:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
 8003c54:	e029      	b.n	8003caa <_ZN3IMU7processEv+0xa2>
	}
	else
	{
		raw_gyro_= raw_gyro_adc_ - gyro_offset_;
 8003c56:	4629      	mov	r1, r5
 8003c58:	f002 fa9e 	bl	8006198 <_ZNK7Vector3IfEmiERKS0_>
		raw_gyro_p_  -= (raw_gyro_p_/GYRO_LPF_FACTOR);
 8003c5c:	f104 05ac 	add.w	r5, r4, #172	; 0xac
		}
		calibrate_gyro_--;
	}
	else
	{
		raw_gyro_= raw_gyro_adc_ - gyro_offset_;
 8003c60:	edc4 0a1d 	vstr	s1, [r4, #116]	; 0x74
 8003c64:	ed84 1a1e 	vstr	s2, [r4, #120]	; 0x78
 8003c68:	ed84 0a1c 	vstr	s0, [r4, #112]	; 0x70
		raw_gyro_p_  -= (raw_gyro_p_/GYRO_LPF_FACTOR);
 8003c6c:	4628      	mov	r0, r5
 8003c6e:	eeb2 0a08 	vmov.f32	s0, #40	; 0x41400000  12.0
 8003c72:	f002 f9cf 	bl	8006014 <_ZNK7Vector3IfEdvEf>
 8003c76:	a901      	add	r1, sp, #4
 8003c78:	4628      	mov	r0, r5
 8003c7a:	ed8d 0a01 	vstr	s0, [sp, #4]
 8003c7e:	edcd 0a02 	vstr	s1, [sp, #8]
 8003c82:	ed8d 1a03 	vstr	s2, [sp, #12]
 8003c86:	f002 f969 	bl	8005f5c <_ZN7Vector3IfEmIERKS0_>
		raw_gyro_p_   += raw_gyro_;
 8003c8a:	f104 0170 	add.w	r1, r4, #112	; 0x70
 8003c8e:	4628      	mov	r0, r5
 8003c90:	f002 f992 	bl	8005fb8 <_ZN7Vector3IfEpLERKS0_>
		gyro_  = (raw_gyro_p_/GYRO_LPF_FACTOR);
 8003c94:	eeb2 0a08 	vmov.f32	s0, #40	; 0x41400000  12.0
 8003c98:	4628      	mov	r0, r5
 8003c9a:	f002 f9bb 	bl	8006014 <_ZNK7Vector3IfEdvEf>
 8003c9e:	ed84 0a25 	vstr	s0, [r4, #148]	; 0x94
 8003ca2:	edc4 0a26 	vstr	s1, [r4, #152]	; 0x98
 8003ca6:	ed84 1a27 	vstr	s2, [r4, #156]	; 0x9c
	}

	/* acc part */
	if (calibrate_acc_ > 0) {
 8003caa:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 8003cae:	2b00      	cmp	r3, #0
 8003cb0:	f104 024c 	add.w	r2, r4, #76	; 0x4c
 8003cb4:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8003cb8:	dd31      	ble.n	8003d1e <_ZN3IMU7processEv+0x116>
		if (calibrate_acc_ == CALIBRATING_STEP) acc_offset_.zero();
 8003cba:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8003cbe:	bf01      	itttt	eq
 8003cc0:	2300      	moveq	r3, #0
 8003cc2:	f8c4 30d8 	streq.w	r3, [r4, #216]	; 0xd8
 8003cc6:	f8c4 30d4 	streq.w	r3, [r4, #212]	; 0xd4
 8003cca:	f8c4 30d0 	streq.w	r3, [r4, #208]	; 0xd0
		acc_offset_ += raw_acc_adc_;
 8003cce:	4611      	mov	r1, r2
 8003cd0:	f002 f972 	bl	8005fb8 <_ZN7Vector3IfEpLERKS0_>

		if (calibrate_acc_ == 1) {
 8003cd4:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 8003cd8:	2b01      	cmp	r3, #1
 8003cda:	d11a      	bne.n	8003d12 <_ZN3IMU7processEv+0x10a>
			acc_offset_[0] /= (float)CALIBRATING_STEP;
 8003cdc:	ed9f 7a8b 	vldr	s14, [pc, #556]	; 8003f0c <_ZN3IMU7processEv+0x304>
 8003ce0:	edd4 6a34 	vldr	s13, [r4, #208]	; 0xd0
 8003ce4:	eec6 7a87 	vdiv.f32	s15, s13, s14
			acc_offset_[1] /= (float)CALIBRATING_STEP;
			acc_offset_[2] =  acc_offset_[2]/(float)CALIBRATING_STEP - GRAVITY_MSS;

			writeCalibData();
 8003ce8:	4620      	mov	r0, r4
		if (calibrate_acc_ == CALIBRATING_STEP) acc_offset_.zero();
		acc_offset_ += raw_acc_adc_;

		if (calibrate_acc_ == 1) {
			acc_offset_[0] /= (float)CALIBRATING_STEP;
			acc_offset_[1] /= (float)CALIBRATING_STEP;
 8003cea:	edd4 6a35 	vldr	s13, [r4, #212]	; 0xd4
	if (calibrate_acc_ > 0) {
		if (calibrate_acc_ == CALIBRATING_STEP) acc_offset_.zero();
		acc_offset_ += raw_acc_adc_;

		if (calibrate_acc_ == 1) {
			acc_offset_[0] /= (float)CALIBRATING_STEP;
 8003cee:	edc4 7a34 	vstr	s15, [r4, #208]	; 0xd0
			acc_offset_[1] /= (float)CALIBRATING_STEP;
 8003cf2:	eec6 7a87 	vdiv.f32	s15, s13, s14
			acc_offset_[2] =  acc_offset_[2]/(float)CALIBRATING_STEP - GRAVITY_MSS;
 8003cf6:	edd4 6a36 	vldr	s13, [r4, #216]	; 0xd8
		if (calibrate_acc_ == CALIBRATING_STEP) acc_offset_.zero();
		acc_offset_ += raw_acc_adc_;

		if (calibrate_acc_ == 1) {
			acc_offset_[0] /= (float)CALIBRATING_STEP;
			acc_offset_[1] /= (float)CALIBRATING_STEP;
 8003cfa:	edc4 7a35 	vstr	s15, [r4, #212]	; 0xd4
			acc_offset_[2] =  acc_offset_[2]/(float)CALIBRATING_STEP - GRAVITY_MSS;
 8003cfe:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8003d02:	ed9f 7a83 	vldr	s14, [pc, #524]	; 8003f10 <_ZN3IMU7processEv+0x308>
 8003d06:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8003d0a:	edc4 7a36 	vstr	s15, [r4, #216]	; 0xd8

			writeCalibData();
 8003d0e:	f7ff fcbf 	bl	8003690 <_ZN3IMU14writeCalibDataEv>
		}
		calibrate_acc_--;
 8003d12:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 8003d16:	3b01      	subs	r3, #1
 8003d18:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
 8003d1c:	e02a      	b.n	8003d74 <_ZN3IMU7processEv+0x16c>
	}
	else
	{
		raw_acc_ = raw_acc_adc_ - acc_offset_;
 8003d1e:	4601      	mov	r1, r0
 8003d20:	4610      	mov	r0, r2
 8003d22:	f002 fa39 	bl	8006198 <_ZNK7Vector3IfEmiERKS0_>
		raw_acc_p_    -= (raw_acc_p_/ACC_LPF_FACTOR);
 8003d26:	f104 05b8 	add.w	r5, r4, #184	; 0xb8
		}
		calibrate_acc_--;
	}
	else
	{
		raw_acc_ = raw_acc_adc_ - acc_offset_;
 8003d2a:	edc4 0a1a 	vstr	s1, [r4, #104]	; 0x68
 8003d2e:	ed84 1a1b 	vstr	s2, [r4, #108]	; 0x6c
 8003d32:	ed84 0a19 	vstr	s0, [r4, #100]	; 0x64
		raw_acc_p_    -= (raw_acc_p_/ACC_LPF_FACTOR);
 8003d36:	4628      	mov	r0, r5
 8003d38:	ed9f 0a76 	vldr	s0, [pc, #472]	; 8003f14 <_ZN3IMU7processEv+0x30c>
 8003d3c:	f002 f96a 	bl	8006014 <_ZNK7Vector3IfEdvEf>
 8003d40:	a901      	add	r1, sp, #4
 8003d42:	4628      	mov	r0, r5
 8003d44:	ed8d 0a01 	vstr	s0, [sp, #4]
 8003d48:	edcd 0a02 	vstr	s1, [sp, #8]
 8003d4c:	ed8d 1a03 	vstr	s2, [sp, #12]
 8003d50:	f002 f904 	bl	8005f5c <_ZN7Vector3IfEmIERKS0_>
		raw_acc_p_    += raw_acc_;
 8003d54:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8003d58:	4628      	mov	r0, r5
 8003d5a:	f002 f92d 	bl	8005fb8 <_ZN7Vector3IfEpLERKS0_>
		acc_  = (raw_acc_p_/ACC_LPF_FACTOR);
 8003d5e:	ed9f 0a6d 	vldr	s0, [pc, #436]	; 8003f14 <_ZN3IMU7processEv+0x30c>
 8003d62:	4628      	mov	r0, r5
 8003d64:	f002 f956 	bl	8006014 <_ZNK7Vector3IfEdvEf>
 8003d68:	ed84 0a22 	vstr	s0, [r4, #136]	; 0x88
 8003d6c:	edc4 0a23 	vstr	s1, [r4, #140]	; 0x8c
 8003d70:	ed84 1a24 	vstr	s2, [r4, #144]	; 0x90
	}

	/* mag part */
	if (calibrate_mag_ > 0)
 8003d74:	f8d4 60cc 	ldr.w	r6, [r4, #204]	; 0xcc
 8003d78:	2e00      	cmp	r6, #0
 8003d7a:	dd52      	ble.n	8003e22 <_ZN3IMU7processEv+0x21a>
	{
		if(calibrate_mag_  == CALIBRATING_MAG_STEP)
 8003d7c:	4b66      	ldr	r3, [pc, #408]	; (8003f18 <_ZN3IMU7processEv+0x310>)
 8003d7e:	429e      	cmp	r6, r3
 8003d80:	f104 0358 	add.w	r3, r4, #88	; 0x58
 8003d84:	d112      	bne.n	8003dac <_ZN3IMU7processEv+0x1a4>
 8003d86:	2200      	movs	r2, #0
 8003d88:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
 8003d8c:	f8c4 20ec 	str.w	r2, [r4, #236]	; 0xec
 8003d90:	f8c4 20e8 	str.w	r2, [r4, #232]	; 0xe8
		{
			mag_offset_.zero();
			mag_min_ = raw_mag_adc_;
 8003d94:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8003d98:	f504 7580 	add.w	r5, r4, #256	; 0x100
 8003d9c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
			mag_max_ = raw_mag_adc_;
 8003da0:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8003da4:	f104 05f4 	add.w	r5, r4, #244	; 0xf4
 8003da8:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 8003dac:	f104 0264 	add.w	r2, r4, #100	; 0x64
		}
		// 30s: you have 30s to turn the multi in all directions
		for (int i = 0; i < 3; i++)
		{
			if (raw_mag_adc_[i] < mag_min_[i]) mag_min_[i] = raw_mag_adc_[i];
 8003db0:	edd3 7a00 	vldr	s15, [r3]
 8003db4:	ed93 7a2a 	vldr	s14, [r3, #168]	; 0xa8
 8003db8:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003dbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003dc0:	bf48      	it	mi
 8003dc2:	edc3 7a2a 	vstrmi	s15, [r3, #168]	; 0xa8
 8003dc6:	3304      	adds	r3, #4
			if (raw_mag_adc_[i] > mag_max_[i]) mag_max_[i] = raw_mag_adc_[i];
 8003dc8:	ed93 7a26 	vldr	s14, [r3, #152]	; 0x98
 8003dcc:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003dd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003dd4:	bfc8      	it	gt
 8003dd6:	edc3 7a26 	vstrgt	s15, [r3, #152]	; 0x98
			mag_offset_.zero();
			mag_min_ = raw_mag_adc_;
			mag_max_ = raw_mag_adc_;
		}
		// 30s: you have 30s to turn the multi in all directions
		for (int i = 0; i < 3; i++)
 8003dda:	429a      	cmp	r2, r3
 8003ddc:	d1e8      	bne.n	8003db0 <_ZN3IMU7processEv+0x1a8>
			if (raw_mag_adc_[i] < mag_min_[i]) mag_min_[i] = raw_mag_adc_[i];
			if (raw_mag_adc_[i] > mag_max_[i]) mag_max_[i] = raw_mag_adc_[i];
		}
		// http://www.aichi-mi.com/old_pages/5_2_transistor_gijutu/transistor_gijutu.htm

		if(calibrate_mag_ == 1)
 8003dde:	2e01      	cmp	r6, #1
 8003de0:	f504 7080 	add.w	r0, r4, #256	; 0x100
 8003de4:	f104 01f4 	add.w	r1, r4, #244	; 0xf4
 8003de8:	d115      	bne.n	8003e16 <_ZN3IMU7processEv+0x20e>
		{
			mag_offset_ = (mag_min_ + mag_max_) /2 ;
 8003dea:	f002 f993 	bl	8006114 <_ZNK7Vector3IfEplERKS0_>
 8003dee:	a801      	add	r0, sp, #4
 8003df0:	ed8d 0a01 	vstr	s0, [sp, #4]
 8003df4:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8003df8:	edcd 0a02 	vstr	s1, [sp, #8]
 8003dfc:	ed8d 1a03 	vstr	s2, [sp, #12]
 8003e00:	f002 f908 	bl	8006014 <_ZNK7Vector3IfEdvEf>

			writeCalibData();
 8003e04:	4620      	mov	r0, r4
		}
		// http://www.aichi-mi.com/old_pages/5_2_transistor_gijutu/transistor_gijutu.htm

		if(calibrate_mag_ == 1)
		{
			mag_offset_ = (mag_min_ + mag_max_) /2 ;
 8003e06:	ed84 0a3a 	vstr	s0, [r4, #232]	; 0xe8
 8003e0a:	edc4 0a3b 	vstr	s1, [r4, #236]	; 0xec
 8003e0e:	ed84 1a3c 	vstr	s2, [r4, #240]	; 0xf0

			writeCalibData();
 8003e12:	f7ff fc3d 	bl	8003690 <_ZN3IMU14writeCalibDataEv>
		}
		calibrate_mag_ --;
 8003e16:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 8003e1a:	3b01      	subs	r3, #1
 8003e1c:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
 8003e20:	e072      	b.n	8003f08 <_ZN3IMU7processEv+0x300>
	}
	else
	{
		/* transform coordinate */
		raw_mag_[0] = raw_mag_adc_[1] - mag_offset_[1];
 8003e22:	edd4 6a17 	vldr	s13, [r4, #92]	; 0x5c
 8003e26:	edd4 7a3b 	vldr	s15, [r4, #236]	; 0xec
		raw_mag_[1] = raw_mag_adc_[0]  - mag_offset_[0];
 8003e2a:	ed94 6a16 	vldr	s12, [r4, #88]	; 0x58
		raw_mag_[2] = -(raw_mag_adc_[2] - mag_offset_[2]);
 8003e2e:	ed94 7a18 	vldr	s14, [r4, #96]	; 0x60

		/* filtering => because the magnetemeter generates too much outlier, not know the reason */
		if(mag_filtering_flag_)
 8003e32:	f894 310c 	ldrb.w	r3, [r4, #268]	; 0x10c
		calibrate_mag_ --;
	}
	else
	{
		/* transform coordinate */
		raw_mag_[0] = raw_mag_adc_[1] - mag_offset_[1];
 8003e36:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8003e3a:	edc4 7a1f 	vstr	s15, [r4, #124]	; 0x7c
		raw_mag_[1] = raw_mag_adc_[0]  - mag_offset_[0];
 8003e3e:	edd4 7a3a 	vldr	s15, [r4, #232]	; 0xe8
 8003e42:	ee76 7a67 	vsub.f32	s15, s12, s15
 8003e46:	edc4 7a20 	vstr	s15, [r4, #128]	; 0x80
		raw_mag_[2] = -(raw_mag_adc_[2] - mag_offset_[2]);
 8003e4a:	edd4 7a3c 	vldr	s15, [r4, #240]	; 0xf0
 8003e4e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8003e52:	eef1 7a67 	vneg.f32	s15, s15
 8003e56:	edc4 7a21 	vstr	s15, [r4, #132]	; 0x84

		/* filtering => because the magnetemeter generates too much outlier, not know the reason */
		if(mag_filtering_flag_)
 8003e5a:	b3a3      	cbz	r3, 8003ec6 <_ZN3IMU7processEv+0x2be>
 8003e5c:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 8003e60:	f104 0188 	add.w	r1, r4, #136	; 0x88
 8003e64:	2500      	movs	r5, #0
 8003e66:	4613      	mov	r3, r2
		{
			bool mag_outlier_flag = false;
			for(int i = 0; i < 3; i++)
			{
				if(fabs(raw_mag_[i] - mag_[i]) > MAG_GENERAL_THRESH) mag_outlier_flag = true;
 8003e68:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
 8003e6c:	ecf2 7a01 	vldmia	r2!, {s15}
 8003e70:	edd2 6a08 	vldr	s13, [r2, #32]
 8003e74:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8003e78:	eef0 7ae7 	vabs.f32	s15, s15
 8003e7c:	eef4 7a47 	vcmp.f32	s15, s14
 8003e80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003e84:	bfc8      	it	gt
 8003e86:	2501      	movgt	r5, #1

		/* filtering => because the magnetemeter generates too much outlier, not know the reason */
		if(mag_filtering_flag_)
		{
			bool mag_outlier_flag = false;
			for(int i = 0; i < 3; i++)
 8003e88:	428a      	cmp	r2, r1
 8003e8a:	d1ef      	bne.n	8003e6c <_ZN3IMU7processEv+0x264>
			{
				if(fabs(raw_mag_[i] - mag_[i]) > MAG_GENERAL_THRESH) mag_outlier_flag = true;
			}

			if(!mag_outlier_flag)
 8003e8c:	b945      	cbnz	r5, 8003ea0 <_ZN3IMU7processEv+0x298>
			{
				mag_ = raw_mag_;
 8003e8e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8003e92:	f104 06a0 	add.w	r6, r4, #160	; 0xa0
 8003e96:	e886 0007 	stmia.w	r6, {r0, r1, r2}
				mag_outlier_counter_ = 0;
 8003e9a:	f8a4 510e 	strh.w	r5, [r4, #270]	; 0x10e
 8003e9e:	e033      	b.n	8003f08 <_ZN3IMU7processEv+0x300>
			}
			else
			{
				if(++mag_outlier_counter_ > MAG_OUTLIER_MAX_COUNT)
 8003ea0:	f8b4 210e 	ldrh.w	r2, [r4, #270]	; 0x10e
 8003ea4:	3201      	adds	r2, #1
 8003ea6:	b292      	uxth	r2, r2
 8003ea8:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
				{
					mag_outlier_counter_ = 0;
 8003eac:	bf81      	itttt	hi
 8003eae:	2200      	movhi	r2, #0
 8003eb0:	f8a4 210e 	strhhi.w	r2, [r4, #270]	; 0x10e
					mag_ = raw_mag_;
 8003eb4:	e893 0007 	ldmiahi.w	r3, {r0, r1, r2}
 8003eb8:	34a0      	addhi	r4, #160	; 0xa0
				mag_ = raw_mag_;
				mag_outlier_counter_ = 0;
			}
			else
			{
				if(++mag_outlier_counter_ > MAG_OUTLIER_MAX_COUNT)
 8003eba:	bf94      	ite	ls
 8003ebc:	f8a4 210e 	strhls.w	r2, [r4, #270]	; 0x10e
				{
					mag_outlier_counter_ = 0;
					mag_ = raw_mag_;
 8003ec0:	e884 0007 	stmiahi.w	r4, {r0, r1, r2}
 8003ec4:	e020      	b.n	8003f08 <_ZN3IMU7processEv+0x300>

    // check if any elements are infinity
    bool is_inf(void) const;

    // check if all elements are zero
    bool is_zero(void) const { return (fabsf(x) < FLT_EPSILON) && (fabsf(y) < FLT_EPSILON) && (fabsf(z) < FLT_EPSILON); }
 8003ec6:	eddf 7a15 	vldr	s15, [pc, #84]	; 8003f1c <_ZN3IMU7processEv+0x314>
 8003eca:	eeb0 6ac6 	vabs.f32	s12, s12
 8003ece:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8003ed2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003ed6:	d50d      	bpl.n	8003ef4 <_ZN3IMU7processEv+0x2ec>
 8003ed8:	eef0 6ae6 	vabs.f32	s13, s13
 8003edc:	eef4 6ae7 	vcmpe.f32	s13, s15
 8003ee0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003ee4:	d506      	bpl.n	8003ef4 <_ZN3IMU7processEv+0x2ec>
 8003ee6:	eeb0 7ac7 	vabs.f32	s14, s14
 8003eea:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8003eee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003ef2:	d409      	bmi.n	8003f08 <_ZN3IMU7processEv+0x300>
		}
		else
		{
			if(!raw_mag_adc_.is_zero())
			{//should notice that the raw_mag_adc may be 0 in the early stage
				mag_ = raw_mag_;
 8003ef4:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 8003ef8:	ca07      	ldmia	r2, {r0, r1, r2}
 8003efa:	f104 03a0 	add.w	r3, r4, #160	; 0xa0
 8003efe:	e883 0007 	stmia.w	r3, {r0, r1, r2}
			mag_filtering_flag_  = true;
 8003f02:	2301      	movs	r3, #1
 8003f04:	f884 310c 	strb.w	r3, [r4, #268]	; 0x10c
			}
		}
	}
}
 8003f08:	b004      	add	sp, #16
 8003f0a:	bd70      	pop	{r4, r5, r6, pc}
 8003f0c:	447a0000 	.word	0x447a0000
 8003f10:	411ce80a 	.word	0x411ce80a
 8003f14:	42280000 	.word	0x42280000
 8003f18:	0001d4c0 	.word	0x0001d4c0
 8003f1c:	34000000 	.word	0x34000000

08003f20 <_ZN3IMU6updateEt>:
	hspi_->Instance->CR1 |= (uint32_t)(SPI_BAUDRATEPRESCALER_8); //8 = 13.5Mhz

}

uint16_t IMU::update(uint16_t queue_size)
{
 8003f20:	b510      	push	{r4, lr}
 8003f22:	4604      	mov	r4, r0
	if(nh_->connected() && (!nh_->getHardware()->getUartDriver()->getTx()->idleFlag()))
 8003f24:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8003f26:	6803      	ldr	r3, [r0, #0]
 8003f28:	689b      	ldr	r3, [r3, #8]
 8003f2a:	4798      	blx	r3
 8003f2c:	b128      	cbz	r0, 8003f3a <_ZN3IMU6updateEt+0x1a>
      }
  }

  uint8_t subscriptInProgress(){return subscript_in_progress_;}
  uint8_t subscriptToAdd(){return subscript_to_add_;}
  bool idleFlag(){return idle_flag_;}
 8003f2e:	4b08      	ldr	r3, [pc, #32]	; (8003f50 <_ZN3IMU6updateEt+0x30>)
 8003f30:	781b      	ldrb	r3, [r3, #0]
 8003f32:	b913      	cbnz	r3, 8003f3a <_ZN3IMU6updateEt+0x1a>
		ahb_suspend_flag_ = true; //should suspend USART1 of DMA(ros) for a while
 8003f34:	2301      	movs	r3, #1
 8003f36:	f884 3111 	strb.w	r3, [r4, #273]	; 0x111
//		uint32_t *tmp32 = (uint32_t*)&temp_p;
//		huart->hdmatx->Instance->M0AR = *(uint32_t*)tmp32;
//		huart->hdmatx->Instance->NDTR = temp_length2;
//	}

	read(); //read from SPI
 8003f3a:	4620      	mov	r0, r4
 8003f3c:	f7ff fd24 	bl	8003988 <_ZN3IMU4readEv>
//		//__HAL_DMA_CLEAR_FLAG(huart_->hdmatx, __HAL_DMA_GET_TC_FLAG_INDEX(huart_->hdmatx)); => should not be after the hal_dma_enable!!(lot of 1 exceed the message frame)
//
//		ahb_suspend_flag_ = false; //finish suspension
//	}

	process();
 8003f40:	4620      	mov	r0, r4
 8003f42:	f7ff fe61 	bl	8003c08 <_ZN3IMU7processEv>

	update_ = true;
 8003f46:	2001      	movs	r0, #1
 8003f48:	f884 0110 	strb.w	r0, [r4, #272]	; 0x110
//		ave_gyroacc = Average_vec(&gyroacc_quene);
//	}
//	return data_queue.size();
	return true;

}
 8003f4c:	bd10      	pop	{r4, pc}
 8003f4e:	bf00      	nop
 8003f50:	20000a68 	.word	0x20000a68

08003f54 <_ZN3ros16normalizeSecNSecERmS0_>:

#include "ros/time.h"

namespace ros
{
  void normalizeSecNSec(uint32_t& sec, uint32_t& nsec){
 8003f54:	b530      	push	{r4, r5, lr}
    uint32_t nsec_part= nsec % 1000000000UL;
    uint32_t sec_part = nsec / 1000000000UL;
    sec += sec_part;
 8003f56:	6802      	ldr	r2, [r0, #0]
#include "ros/time.h"

namespace ros
{
  void normalizeSecNSec(uint32_t& sec, uint32_t& nsec){
    uint32_t nsec_part= nsec % 1000000000UL;
 8003f58:	680d      	ldr	r5, [r1, #0]
    uint32_t sec_part = nsec / 1000000000UL;
    sec += sec_part;
 8003f5a:	4c04      	ldr	r4, [pc, #16]	; (8003f6c <_ZN3ros16normalizeSecNSecERmS0_+0x18>)
 8003f5c:	fbb5 f3f4 	udiv	r3, r5, r4
 8003f60:	441a      	add	r2, r3
    nsec = nsec_part;
 8003f62:	fb04 5313 	mls	r3, r4, r3, r5
namespace ros
{
  void normalizeSecNSec(uint32_t& sec, uint32_t& nsec){
    uint32_t nsec_part= nsec % 1000000000UL;
    uint32_t sec_part = nsec / 1000000000UL;
    sec += sec_part;
 8003f66:	6002      	str	r2, [r0, #0]
    nsec = nsec_part;
 8003f68:	600b      	str	r3, [r1, #0]
 8003f6a:	bd30      	pop	{r4, r5, pc}
 8003f6c:	3b9aca00 	.word	0x3b9aca00

08003f70 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8003f70:	490f      	ldr	r1, [pc, #60]	; (8003fb0 <SystemInit+0x40>)
 8003f72:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8003f76:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003f7a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003f7e:	4b0d      	ldr	r3, [pc, #52]	; (8003fb4 <SystemInit+0x44>)
 8003f80:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003f82:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003f84:	f042 0201 	orr.w	r2, r2, #1
 8003f88:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003f8a:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003f8c:	681a      	ldr	r2, [r3, #0]
 8003f8e:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8003f92:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003f96:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8003f98:	4a07      	ldr	r2, [pc, #28]	; (8003fb8 <SystemInit+0x48>)
 8003f9a:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003f9c:	681a      	ldr	r2, [r3, #0]
 8003f9e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003fa2:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8003fa4:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8003fa6:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003faa:	608b      	str	r3, [r1, #8]
 8003fac:	4770      	bx	lr
 8003fae:	bf00      	nop
 8003fb0:	e000ed00 	.word	0xe000ed00
 8003fb4:	40023800 	.word	0x40023800
 8003fb8:	24003010 	.word	0x24003010

08003fbc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8003fbc:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8003fbe:	4b08      	ldr	r3, [pc, #32]	; (8003fe0 <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8003fc0:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8003fc2:	6818      	ldr	r0, [r3, #0]
 8003fc4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003fc8:	fbb0 f0f3 	udiv	r0, r0, r3
 8003fcc:	f000 f9ce 	bl	800436c <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8003fd0:	2200      	movs	r2, #0
 8003fd2:	4621      	mov	r1, r4
 8003fd4:	f04f 30ff 	mov.w	r0, #4294967295
 8003fd8:	f000 f988 	bl	80042ec <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8003fdc:	2000      	movs	r0, #0
 8003fde:	bd10      	pop	{r4, pc}
 8003fe0:	20000004 	.word	0x20000004

08003fe4 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8003fe4:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8003fe6:	4b0b      	ldr	r3, [pc, #44]	; (8004014 <HAL_Init+0x30>)
 8003fe8:	681a      	ldr	r2, [r3, #0]
 8003fea:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8003fee:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8003ff0:	681a      	ldr	r2, [r3, #0]
 8003ff2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8003ff6:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8003ff8:	681a      	ldr	r2, [r3, #0]
 8003ffa:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003ffe:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8004000:	2003      	movs	r0, #3
 8004002:	f000 f961 	bl	80042c8 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8004006:	2000      	movs	r0, #0
 8004008:	f7ff ffd8 	bl	8003fbc <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 800400c:	f7ff f9b6 	bl	800337c <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8004010:	2000      	movs	r0, #0
 8004012:	bd08      	pop	{r3, pc}
 8004014:	40023c00 	.word	0x40023c00

08004018 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8004018:	4a02      	ldr	r2, [pc, #8]	; (8004024 <HAL_IncTick+0xc>)
 800401a:	6813      	ldr	r3, [r2, #0]
 800401c:	3301      	adds	r3, #1
 800401e:	6013      	str	r3, [r2, #0]
 8004020:	4770      	bx	lr
 8004022:	bf00      	nop
 8004024:	20003cdc 	.word	0x20003cdc

08004028 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8004028:	4b01      	ldr	r3, [pc, #4]	; (8004030 <HAL_GetTick+0x8>)
 800402a:	6818      	ldr	r0, [r3, #0]
}
 800402c:	4770      	bx	lr
 800402e:	bf00      	nop
 8004030:	20003cdc 	.word	0x20003cdc

08004034 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8004034:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8004036:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8004038:	f7ff fff6 	bl	8004028 <HAL_GetTick>
  uint32_t wait = Delay;
 800403c:	9c01      	ldr	r4, [sp, #4]
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800403e:	1c63      	adds	r3, r4, #1
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
  uint32_t tickstart = HAL_GetTick();
 8004040:	4605      	mov	r5, r0
  uint32_t wait = Delay;
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
     wait++;
 8004042:	bf18      	it	ne
 8004044:	3401      	addne	r4, #1
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 8004046:	f7ff ffef 	bl	8004028 <HAL_GetTick>
 800404a:	1b40      	subs	r0, r0, r5
 800404c:	4284      	cmp	r4, r0
 800404e:	d8fa      	bhi.n	8004046 <HAL_Delay+0x12>
  {
  }
}
 8004050:	b003      	add	sp, #12
 8004052:	bd30      	pop	{r4, r5, pc}

08004054 <HAL_ADC_Init>:
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8004054:	b510      	push	{r4, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  
  /* Check ADC handle */
  if(hadc == NULL)
 8004056:	4604      	mov	r4, r0
 8004058:	2800      	cmp	r0, #0
 800405a:	f000 8098 	beq.w	800418e <HAL_ADC_Init+0x13a>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }
  
  if(hadc->State == HAL_ADC_STATE_RESET)
 800405e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004060:	b923      	cbnz	r3, 800406c <HAL_ADC_Init+0x18>
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
 8004062:	6443      	str	r3, [r0, #68]	; 0x44
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 8004064:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8004068:	f7fd fa38 	bl	80014dc <HAL_ADC_MspInit>
  }
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 800406c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800406e:	06db      	lsls	r3, r3, #27
 8004070:	f100 8088 	bmi.w	8004184 <HAL_ADC_Init+0x130>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8004074:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004076:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 800407a:	f023 0302 	bic.w	r3, r3, #2
 800407e:	f043 0302 	orr.w	r3, r3, #2
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);
 8004082:	6423      	str	r3, [r4, #64]	; 0x40
  /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
  /* control register)                                                    */
  tmpADC_Common = ADC_COMMON_REGISTER(hadc);
  
  /* Set the ADC clock prescaler */
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
 8004084:	4b43      	ldr	r3, [pc, #268]	; (8004194 <HAL_ADC_Init+0x140>)
 8004086:	685a      	ldr	r2, [r3, #4]
 8004088:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800408c:	605a      	str	r2, [r3, #4]
  tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
 800408e:	6859      	ldr	r1, [r3, #4]
 8004090:	6862      	ldr	r2, [r4, #4]
 8004092:	430a      	orrs	r2, r1
 8004094:	605a      	str	r2, [r3, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8004096:	6823      	ldr	r3, [r4, #0]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8004098:	6921      	ldr	r1, [r4, #16]
  /* Set the ADC clock prescaler */
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
  tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 800409a:	685a      	ldr	r2, [r3, #4]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800409c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Set the ADC clock prescaler */
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
  tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 800409e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80040a2:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 80040a4:	685a      	ldr	r2, [r3, #4]
 80040a6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80040aa:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 80040ac:	685a      	ldr	r2, [r3, #4]
 80040ae:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 80040b2:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 80040b4:	6859      	ldr	r1, [r3, #4]
 80040b6:	68a2      	ldr	r2, [r4, #8]
 80040b8:	430a      	orrs	r2, r1
 80040ba:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 80040bc:	689a      	ldr	r2, [r3, #8]
 80040be:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80040c2:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 80040c4:	6899      	ldr	r1, [r3, #8]
 80040c6:	68e2      	ldr	r2, [r4, #12]
 80040c8:	430a      	orrs	r2, r1
 80040ca:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80040cc:	4a32      	ldr	r2, [pc, #200]	; (8004198 <HAL_ADC_Init+0x144>)
 80040ce:	4290      	cmp	r0, r2
 80040d0:	d00e      	beq.n	80040f0 <HAL_ADC_Init+0x9c>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80040d2:	6899      	ldr	r1, [r3, #8]
 80040d4:	f021 6170 	bic.w	r1, r1, #251658240	; 0xf000000
 80040d8:	6099      	str	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 80040da:	689a      	ldr	r2, [r3, #8]
 80040dc:	4302      	orrs	r2, r0
 80040de:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80040e0:	689a      	ldr	r2, [r3, #8]
 80040e2:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80040e6:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 80040e8:	6899      	ldr	r1, [r3, #8]
 80040ea:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80040ec:	430a      	orrs	r2, r1
 80040ee:	e006      	b.n	80040fe <HAL_ADC_Init+0xaa>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80040f0:	689a      	ldr	r2, [r3, #8]
 80040f2:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80040f6:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80040f8:	689a      	ldr	r2, [r3, #8]
 80040fa:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80040fe:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8004100:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 8004102:	69a1      	ldr	r1, [r4, #24]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8004104:	f022 0202 	bic.w	r2, r2, #2
 8004108:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 800410a:	689a      	ldr	r2, [r3, #8]
 800410c:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
 8004110:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 8004112:	6a22      	ldr	r2, [r4, #32]
 8004114:	b16a      	cbz	r2, 8004132 <HAL_ADC_Init+0xde>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8004116:	685a      	ldr	r2, [r3, #4]
 8004118:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800411c:	605a      	str	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 800411e:	685a      	ldr	r2, [r3, #4]
 8004120:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8004124:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8004126:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004128:	6859      	ldr	r1, [r3, #4]
 800412a:	3a01      	subs	r2, #1
 800412c:	ea41 3242 	orr.w	r2, r1, r2, lsl #13
 8004130:	e002      	b.n	8004138 <HAL_ADC_Init+0xe4>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8004132:	685a      	ldr	r2, [r3, #4]
 8004134:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8004138:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 800413a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800413c:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 8004140:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8004142:	69e2      	ldr	r2, [r4, #28]
 8004144:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8004146:	3a01      	subs	r2, #1
 8004148:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
 800414c:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 800414e:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 8004150:	6b21      	ldr	r1, [r4, #48]	; 0x30
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 8004152:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8004156:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 8004158:	689a      	ldr	r2, [r3, #8]
 800415a:	ea42 2241 	orr.w	r2, r2, r1, lsl #9
 800415e:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8004160:	689a      	ldr	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8004162:	6961      	ldr	r1, [r4, #20]
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8004164:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8004168:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 800416a:	689a      	ldr	r2, [r3, #8]
    
    /* Set ADC parameters */
    ADC_Init(hadc);
    
    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 800416c:	2000      	movs	r0, #0
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 800416e:	ea42 2281 	orr.w	r2, r2, r1, lsl #10
 8004172:	609a      	str	r2, [r3, #8]
    
    /* Set ADC parameters */
    ADC_Init(hadc);
    
    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8004174:	6460      	str	r0, [r4, #68]	; 0x44
    
    /* Set the ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8004176:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004178:	f023 0303 	bic.w	r3, r3, #3
 800417c:	f043 0301 	orr.w	r3, r3, #1
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
 8004180:	6423      	str	r3, [r4, #64]	; 0x40
 8004182:	e000      	b.n	8004186 <HAL_ADC_Init+0x132>
  }
  else
  {
    tmp_hal_status = HAL_ERROR;
 8004184:	2001      	movs	r0, #1
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hadc);
 8004186:	2300      	movs	r3, #0
 8004188:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

  /* Return function status */
  return tmp_hal_status;
 800418c:	bd10      	pop	{r4, pc}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  
  /* Check ADC handle */
  if(hadc == NULL)
  {
    return HAL_ERROR;
 800418e:	2001      	movs	r0, #1
  /* Release Lock */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
 8004190:	bd10      	pop	{r4, pc}
 8004192:	bf00      	nop
 8004194:	40012300 	.word	0x40012300
 8004198:	0f000001 	.word	0x0f000001

0800419c <HAL_ADC_ConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfig ADC configuration structure. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 800419c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t counter = 0U;
 800419e:	2300      	movs	r3, #0
 80041a0:	9301      	str	r3, [sp, #4]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80041a2:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80041a6:	2b01      	cmp	r3, #1
 80041a8:	d06c      	beq.n	8004284 <HAL_ADC_ConfigChannel+0xe8>
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 80041aa:	680d      	ldr	r5, [r1, #0]
 80041ac:	6804      	ldr	r4, [r0, #0]
 80041ae:	688f      	ldr	r7, [r1, #8]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80041b0:	2301      	movs	r3, #1
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 80041b2:	2d09      	cmp	r5, #9
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80041b4:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
 80041b8:	b2ae      	uxth	r6, r5
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 80041ba:	d910      	bls.n	80041de <HAL_ADC_ConfigChannel+0x42>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 80041bc:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 80041c0:	f8d4 e00c 	ldr.w	lr, [r4, #12]
 80041c4:	f1a2 031e 	sub.w	r3, r2, #30
 80041c8:	2207      	movs	r2, #7
 80041ca:	409a      	lsls	r2, r3
 80041cc:	ea2e 0202 	bic.w	r2, lr, r2
 80041d0:	60e2      	str	r2, [r4, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 80041d2:	68e2      	ldr	r2, [r4, #12]
 80041d4:	fa07 f303 	lsl.w	r3, r7, r3
 80041d8:	4313      	orrs	r3, r2
 80041da:	60e3      	str	r3, [r4, #12]
 80041dc:	e00e      	b.n	80041fc <HAL_ADC_ConfigChannel+0x60>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 80041de:	6922      	ldr	r2, [r4, #16]
 80041e0:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 80041e4:	f04f 0e07 	mov.w	lr, #7
 80041e8:	fa0e fe03 	lsl.w	lr, lr, r3
 80041ec:	ea22 020e 	bic.w	r2, r2, lr
 80041f0:	6122      	str	r2, [r4, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 80041f2:	6922      	ldr	r2, [r4, #16]
 80041f4:	fa07 f303 	lsl.w	r3, r7, r3
 80041f8:	4313      	orrs	r3, r2
 80041fa:	6123      	str	r3, [r4, #16]
  }
  
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7U)
 80041fc:	684b      	ldr	r3, [r1, #4]
 80041fe:	2b06      	cmp	r3, #6
 8004200:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8004204:	d80d      	bhi.n	8004222 <HAL_ADC_ConfigChannel+0x86>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8004206:	4413      	add	r3, r2
 8004208:	6b67      	ldr	r7, [r4, #52]	; 0x34
 800420a:	1f59      	subs	r1, r3, #5
 800420c:	231f      	movs	r3, #31
 800420e:	408b      	lsls	r3, r1
 8004210:	ea27 0303 	bic.w	r3, r7, r3
 8004214:	6363      	str	r3, [r4, #52]	; 0x34
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8004216:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004218:	fa06 f101 	lsl.w	r1, r6, r1
 800421c:	4311      	orrs	r1, r2
 800421e:	6361      	str	r1, [r4, #52]	; 0x34
 8004220:	e01d      	b.n	800425e <HAL_ADC_ConfigChannel+0xc2>
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13U)
 8004222:	2b0c      	cmp	r3, #12
 8004224:	d80e      	bhi.n	8004244 <HAL_ADC_ConfigChannel+0xa8>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 8004226:	4413      	add	r3, r2
 8004228:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800422a:	f1a3 0223 	sub.w	r2, r3, #35	; 0x23
 800422e:	231f      	movs	r3, #31
 8004230:	4093      	lsls	r3, r2
 8004232:	ea21 0303 	bic.w	r3, r1, r3
 8004236:	6323      	str	r3, [r4, #48]	; 0x30
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8004238:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800423a:	fa06 f202 	lsl.w	r2, r6, r2
 800423e:	431a      	orrs	r2, r3
 8004240:	6322      	str	r2, [r4, #48]	; 0x30
 8004242:	e00c      	b.n	800425e <HAL_ADC_ConfigChannel+0xc2>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8004244:	4413      	add	r3, r2
 8004246:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8004248:	3b41      	subs	r3, #65	; 0x41
 800424a:	221f      	movs	r2, #31
 800424c:	409a      	lsls	r2, r3
 800424e:	ea27 0202 	bic.w	r2, r7, r2
 8004252:	62e2      	str	r2, [r4, #44]	; 0x2c
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8004254:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8004256:	fa06 f203 	lsl.w	r2, r6, r3
 800425a:	430a      	orrs	r2, r1
 800425c:	62e2      	str	r2, [r4, #44]	; 0x2c
    /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
    /* control register)                                                    */
    tmpADC_Common = ADC_COMMON_REGISTER(hadc);

  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 800425e:	4b16      	ldr	r3, [pc, #88]	; (80042b8 <HAL_ADC_ConfigChannel+0x11c>)
 8004260:	429c      	cmp	r4, r3
 8004262:	d10a      	bne.n	800427a <HAL_ADC_ConfigChannel+0xde>
 8004264:	2d12      	cmp	r5, #18
 8004266:	d104      	bne.n	8004272 <HAL_ADC_ConfigChannel+0xd6>
  {
    /* Enable the VBAT channel*/
    tmpADC_Common->CCR |= ADC_CCR_VBATE;
 8004268:	4a14      	ldr	r2, [pc, #80]	; (80042bc <HAL_ADC_ConfigChannel+0x120>)
 800426a:	6853      	ldr	r3, [r2, #4]
 800426c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8004270:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 8004272:	f1a5 0310 	sub.w	r3, r5, #16
 8004276:	2b01      	cmp	r3, #1
 8004278:	d906      	bls.n	8004288 <HAL_ADC_ConfigChannel+0xec>
      }
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800427a:	2300      	movs	r3, #0
 800427c:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 8004280:	4618      	mov	r0, r3
 8004282:	e016      	b.n	80042b2 <HAL_ADC_ConfigChannel+0x116>
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8004284:	2002      	movs	r0, #2
 8004286:	e014      	b.n	80042b2 <HAL_ADC_ConfigChannel+0x116>
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
  {
    /* Enable the TSVREFE channel*/
    tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
 8004288:	4a0c      	ldr	r2, [pc, #48]	; (80042bc <HAL_ADC_ConfigChannel+0x120>)
 800428a:	6853      	ldr	r3, [r2, #4]
    
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 800428c:	2d10      	cmp	r5, #16
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
  {
    /* Enable the TSVREFE channel*/
    tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
 800428e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8004292:	6053      	str	r3, [r2, #4]
    
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8004294:	d1f1      	bne.n	800427a <HAL_ADC_ConfigChannel+0xde>
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 8004296:	4b0a      	ldr	r3, [pc, #40]	; (80042c0 <HAL_ADC_ConfigChannel+0x124>)
 8004298:	4a0a      	ldr	r2, [pc, #40]	; (80042c4 <HAL_ADC_ConfigChannel+0x128>)
 800429a:	681b      	ldr	r3, [r3, #0]
 800429c:	fbb3 f2f2 	udiv	r2, r3, r2
 80042a0:	230a      	movs	r3, #10
 80042a2:	4353      	muls	r3, r2
 80042a4:	9301      	str	r3, [sp, #4]
      while(counter != 0U)
 80042a6:	9b01      	ldr	r3, [sp, #4]
 80042a8:	2b00      	cmp	r3, #0
 80042aa:	d0e6      	beq.n	800427a <HAL_ADC_ConfigChannel+0xde>
      {
        counter--;
 80042ac:	9b01      	ldr	r3, [sp, #4]
 80042ae:	3b01      	subs	r3, #1
 80042b0:	e7f8      	b.n	80042a4 <HAL_ADC_ConfigChannel+0x108>
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
  /* Return function status */
  return HAL_OK;
}
 80042b2:	b003      	add	sp, #12
 80042b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80042b6:	bf00      	nop
 80042b8:	40012000 	.word	0x40012000
 80042bc:	40012300 	.word	0x40012300
 80042c0:	20000004 	.word	0x20000004
 80042c4:	000f4240 	.word	0x000f4240

080042c8 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80042c8:	4a07      	ldr	r2, [pc, #28]	; (80042e8 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80042ca:	68d3      	ldr	r3, [r2, #12]
 80042cc:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80042d0:	041b      	lsls	r3, r3, #16
 80042d2:	0c1b      	lsrs	r3, r3, #16
 80042d4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 80042d8:	0200      	lsls	r0, r0, #8
 80042da:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80042de:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 80042e2:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 80042e4:	60d3      	str	r3, [r2, #12]
 80042e6:	4770      	bx	lr
 80042e8:	e000ed00 	.word	0xe000ed00

080042ec <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80042ec:	4b17      	ldr	r3, [pc, #92]	; (800434c <HAL_NVIC_SetPriority+0x60>)
 80042ee:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80042f0:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80042f4:	b530      	push	{r4, r5, lr}
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80042f6:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80042fa:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80042fc:	2c04      	cmp	r4, #4
 80042fe:	bf28      	it	cs
 8004300:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8004302:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
 8004304:	f04f 0501 	mov.w	r5, #1
 8004308:	fa05 f404 	lsl.w	r4, r5, r4
 800430c:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8004310:	bf8c      	ite	hi
 8004312:	3b03      	subhi	r3, #3
 8004314:	2300      	movls	r3, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
 8004316:	400c      	ands	r4, r1
 8004318:	409c      	lsls	r4, r3
 800431a:	fa05 f303 	lsl.w	r3, r5, r3
 800431e:	3b01      	subs	r3, #1
 8004320:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8004322:	2800      	cmp	r0, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
 8004324:	ea42 0204 	orr.w	r2, r2, r4
 8004328:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800432c:	bfaf      	iteee	ge
 800432e:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004332:	f000 000f 	andlt.w	r0, r0, #15
 8004336:	4b06      	ldrlt	r3, [pc, #24]	; (8004350 <HAL_NVIC_SetPriority+0x64>)
 8004338:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800433a:	bfa5      	ittet	ge
 800433c:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8004340:	b2d2      	uxtbge	r2, r2
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004342:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004344:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8004348:	bd30      	pop	{r4, r5, pc}
 800434a:	bf00      	nop
 800434c:	e000ed00 	.word	0xe000ed00
 8004350:	e000ed14 	.word	0xe000ed14

08004354 <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8004354:	0942      	lsrs	r2, r0, #5
 8004356:	2301      	movs	r3, #1
 8004358:	f000 001f 	and.w	r0, r0, #31
 800435c:	fa03 f000 	lsl.w	r0, r3, r0
 8004360:	4b01      	ldr	r3, [pc, #4]	; (8004368 <HAL_NVIC_EnableIRQ+0x14>)
 8004362:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8004366:	4770      	bx	lr
 8004368:	e000e100 	.word	0xe000e100

0800436c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800436c:	3801      	subs	r0, #1
 800436e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8004372:	d20a      	bcs.n	800438a <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8004374:	4b06      	ldr	r3, [pc, #24]	; (8004390 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004376:	4a07      	ldr	r2, [pc, #28]	; (8004394 <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8004378:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800437a:	21f0      	movs	r1, #240	; 0xf0
 800437c:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8004380:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
 8004382:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8004384:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
 8004386:	601a      	str	r2, [r3, #0]
 8004388:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 800438a:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 800438c:	4770      	bx	lr
 800438e:	bf00      	nop
 8004390:	e000e010 	.word	0xe000e010
 8004394:	e000ed00 	.word	0xe000ed00

08004398 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8004398:	4b04      	ldr	r3, [pc, #16]	; (80043ac <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 800439a:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 800439c:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 800439e:	bf0c      	ite	eq
 80043a0:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 80043a4:	f022 0204 	bicne.w	r2, r2, #4
 80043a8:	601a      	str	r2, [r3, #0]
 80043aa:	4770      	bx	lr
 80043ac:	e000e010 	.word	0xe000e010

080043b0 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 80043b0:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 80043b2:	f7fe fe89 	bl	80030c8 <HAL_SYSTICK_Callback>
 80043b6:	bd08      	pop	{r3, pc}

080043b8 <_ZL23DMA_CalcBaseAndBitshiftP19__DMA_HandleTypeDef>:
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80043b8:	6803      	ldr	r3, [r0, #0]
 80043ba:	b2da      	uxtb	r2, r3
 80043bc:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
  
  if (stream_number > 3U)
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80043c0:	f023 0303 	bic.w	r3, r3, #3
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80043c4:	2118      	movs	r1, #24
 80043c6:	3a10      	subs	r2, #16
 80043c8:	fbb2 f2f1 	udiv	r2, r2, r1
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80043cc:	4904      	ldr	r1, [pc, #16]	; (80043e0 <_ZL23DMA_CalcBaseAndBitshiftP19__DMA_HandleTypeDef+0x28>)
  
  if (stream_number > 3U)
 80043ce:	2a03      	cmp	r2, #3
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80043d0:	bf88      	it	hi
 80043d2:	3304      	addhi	r3, #4
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80043d4:	5c89      	ldrb	r1, [r1, r2]
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 80043d6:	6583      	str	r3, [r0, #88]	; 0x58
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80043d8:	65c1      	str	r1, [r0, #92]	; 0x5c
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  }
  
  return hdma->StreamBaseAddress;
}
 80043da:	6d80      	ldr	r0, [r0, #88]	; 0x58
 80043dc:	4770      	bx	lr
 80043de:	bf00      	nop
 80043e0:	080091dc 	.word	0x080091dc

080043e4 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 80043e4:	b570      	push	{r4, r5, r6, lr}
 80043e6:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 80043e8:	f7ff fe1e 	bl	8004028 <HAL_GetTick>
 80043ec:	4605      	mov	r5, r0
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80043ee:	2c00      	cmp	r4, #0
 80043f0:	d064      	beq.n	80044bc <HAL_DMA_Init+0xd8>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 80043f2:	2300      	movs	r3, #0
 80043f4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 80043f8:	6822      	ldr	r2, [r4, #0]
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80043fa:	2302      	movs	r3, #2
 80043fc:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8004400:	6813      	ldr	r3, [r2, #0]
 8004402:	f023 0301 	bic.w	r3, r3, #1
 8004406:	6013      	str	r3, [r2, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8004408:	6820      	ldr	r0, [r4, #0]
 800440a:	6803      	ldr	r3, [r0, #0]
 800440c:	07d9      	lsls	r1, r3, #31
 800440e:	d508      	bpl.n	8004422 <HAL_DMA_Init+0x3e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8004410:	f7ff fe0a 	bl	8004028 <HAL_GetTick>
 8004414:	1b40      	subs	r0, r0, r5
 8004416:	2805      	cmp	r0, #5
 8004418:	d9f6      	bls.n	8004408 <HAL_DMA_Init+0x24>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800441a:	2320      	movs	r3, #32
 800441c:	6563      	str	r3, [r4, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 800441e:	2003      	movs	r0, #3
 8004420:	e051      	b.n	80044c6 <HAL_DMA_Init+0xe2>
      return HAL_TIMEOUT;
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 8004422:	6803      	ldr	r3, [r0, #0]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
 8004424:	4a29      	ldr	r2, [pc, #164]	; (80044cc <HAL_DMA_Init+0xe8>)

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;
 8004426:	6861      	ldr	r1, [r4, #4]
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8004428:	69a5      	ldr	r5, [r4, #24]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
 800442a:	401a      	ands	r2, r3

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;
 800442c:	68a3      	ldr	r3, [r4, #8]
 800442e:	4319      	orrs	r1, r3
 8004430:	68e3      	ldr	r3, [r4, #12]
 8004432:	4319      	orrs	r1, r3
 8004434:	6923      	ldr	r3, [r4, #16]
 8004436:	4319      	orrs	r1, r3
 8004438:	6963      	ldr	r3, [r4, #20]
 800443a:	430b      	orrs	r3, r1
 800443c:	69e1      	ldr	r1, [r4, #28]
 800443e:	432b      	orrs	r3, r5
 8004440:	430b      	orrs	r3, r1
 8004442:	6a21      	ldr	r1, [r4, #32]
 8004444:	430b      	orrs	r3, r1
 8004446:	4313      	orrs	r3, r2

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8004448:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800444a:	2a04      	cmp	r2, #4
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800444c:	bf01      	itttt	eq
 800444e:	6b21      	ldreq	r1, [r4, #48]	; 0x30
 8004450:	6ae6      	ldreq	r6, [r4, #44]	; 0x2c
 8004452:	4331      	orreq	r1, r6
 8004454:	430b      	orreq	r3, r1
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8004456:	6003      	str	r3, [r0, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8004458:	6943      	ldr	r3, [r0, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800445a:	2a04      	cmp	r2, #4

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800445c:	f023 0307 	bic.w	r3, r3, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8004460:	ea43 0302 	orr.w	r3, r3, r2

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8004464:	d11c      	bne.n	80044a0 <HAL_DMA_Init+0xbc>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 8004466:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8004468:	6ae1      	ldr	r1, [r4, #44]	; 0x2c

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 800446a:	4313      	orrs	r3, r2
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 800446c:	b1c1      	cbz	r1, 80044a0 <HAL_DMA_Init+0xbc>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800446e:	b925      	cbnz	r5, 800447a <HAL_DMA_Init+0x96>
  {
    switch (tmp)
 8004470:	2a01      	cmp	r2, #1
 8004472:	d00b      	beq.n	800448c <HAL_DMA_Init+0xa8>
 8004474:	d312      	bcc.n	800449c <HAL_DMA_Init+0xb8>
 8004476:	2a02      	cmp	r2, #2
 8004478:	e00f      	b.n	800449a <HAL_DMA_Init+0xb6>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800447a:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
 800447e:	d109      	bne.n	8004494 <HAL_DMA_Init+0xb0>
  {
    switch (tmp)
 8004480:	2a03      	cmp	r2, #3
 8004482:	d80d      	bhi.n	80044a0 <HAL_DMA_Init+0xbc>
 8004484:	e8df f002 	tbb	[pc, r2]
 8004488:	021c0a1c 	.word	0x021c0a1c
      {
        status = HAL_ERROR;
      }
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800448c:	f1b1 7fc0 	cmp.w	r1, #25165824	; 0x1800000
 8004490:	d106      	bne.n	80044a0 <HAL_DMA_Init+0xbc>
 8004492:	e015      	b.n	80044c0 <HAL_DMA_Init+0xdc>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8004494:	2a02      	cmp	r2, #2
 8004496:	d913      	bls.n	80044c0 <HAL_DMA_Init+0xdc>
 8004498:	2a03      	cmp	r2, #3
 800449a:	d101      	bne.n	80044a0 <HAL_DMA_Init+0xbc>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800449c:	01ca      	lsls	r2, r1, #7
 800449e:	d40f      	bmi.n	80044c0 <HAL_DMA_Init+0xdc>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 80044a0:	6143      	str	r3, [r0, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 80044a2:	4620      	mov	r0, r4
 80044a4:	f7ff ff88 	bl	80043b8 <_ZL23DMA_CalcBaseAndBitshiftP19__DMA_HandleTypeDef>
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80044a8:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80044aa:	233f      	movs	r3, #63	; 0x3f
 80044ac:	4093      	lsls	r3, r2
 80044ae:	6083      	str	r3, [r0, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80044b0:	2000      	movs	r0, #0
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80044b2:	2301      	movs	r3, #1
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80044b4:	6560      	str	r0, [r4, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80044b6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  return HAL_OK;
 80044ba:	bd70      	pop	{r4, r5, r6, pc}
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
  {
    return HAL_ERROR;
 80044bc:	2001      	movs	r0, #1
 80044be:	bd70      	pop	{r4, r5, r6, pc}
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80044c0:	2340      	movs	r3, #64	; 0x40
 80044c2:	6563      	str	r3, [r4, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 80044c4:	2001      	movs	r0, #1
 80044c6:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;

  return HAL_OK;
}
 80044ca:	bd70      	pop	{r4, r5, r6, pc}
 80044cc:	f010803f 	.word	0xf010803f

080044d0 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80044d0:	b570      	push	{r4, r5, r6, lr}
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 80044d2:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 80044d6:	2c01      	cmp	r4, #1
 80044d8:	d038      	beq.n	800454c <HAL_DMA_Start_IT+0x7c>
 80044da:	2401      	movs	r4, #1
 80044dc:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 80044e0:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80044e4:	6d86      	ldr	r6, [r0, #88]	; 0x58
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
  
  if(HAL_DMA_STATE_READY == hdma->State)
 80044e6:	2c01      	cmp	r4, #1
 80044e8:	f04f 0500 	mov.w	r5, #0
 80044ec:	f04f 0402 	mov.w	r4, #2
 80044f0:	d128      	bne.n	8004544 <HAL_DMA_Start_IT+0x74>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 80044f2:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80044f6:	6804      	ldr	r4, [r0, #0]
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80044f8:	6545      	str	r5, [r0, #84]	; 0x54
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80044fa:	6825      	ldr	r5, [r4, #0]
 80044fc:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
 8004500:	6025      	str	r5, [r4, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 8004502:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8004504:	6883      	ldr	r3, [r0, #8]
 8004506:	2b40      	cmp	r3, #64	; 0x40
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 8004508:	bf0e      	itee	eq
 800450a:	60a2      	streq	r2, [r4, #8]
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Stream source address */
    hdma->Instance->PAR = SrcAddress;
 800450c:	60a1      	strne	r1, [r4, #8]

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
 800450e:	60e2      	strne	r2, [r4, #12]
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8004510:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 8004512:	bf08      	it	eq
 8004514:	60e1      	streq	r1, [r4, #12]
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8004516:	233f      	movs	r3, #63	; 0x3f
 8004518:	4093      	lsls	r3, r2
 800451a:	60b3      	str	r3, [r6, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 800451c:	6823      	ldr	r3, [r4, #0]
 800451e:	f043 0316 	orr.w	r3, r3, #22
 8004522:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8004524:	6963      	ldr	r3, [r4, #20]
 8004526:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800452a:	6163      	str	r3, [r4, #20]
    
    if(hdma->XferHalfCpltCallback != NULL)
 800452c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800452e:	b11b      	cbz	r3, 8004538 <HAL_DMA_Start_IT+0x68>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
 8004530:	6823      	ldr	r3, [r4, #0]
 8004532:	f043 0308 	orr.w	r3, r3, #8
 8004536:	6023      	str	r3, [r4, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 8004538:	6823      	ldr	r3, [r4, #0]
 800453a:	f043 0301 	orr.w	r3, r3, #1
 800453e:	6023      	str	r3, [r4, #0]
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  HAL_StatusTypeDef status = HAL_OK;
 8004540:	2000      	movs	r0, #0
 8004542:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_DMA_ENABLE(hdma);
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 8004544:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 8004548:	4620      	mov	r0, r4
 800454a:	bd70      	pop	{r4, r5, r6, pc}
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 800454c:	2002      	movs	r0, #2
    /* Return error status */
    status = HAL_BUSY;
  }
  
  return status;
}
 800454e:	bd70      	pop	{r4, r5, r6, pc}

08004550 <HAL_DMA_Abort_IT>:
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8004550:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8004554:	2b02      	cmp	r3, #2
 8004556:	d003      	beq.n	8004560 <HAL_DMA_Abort_IT+0x10>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8004558:	2380      	movs	r3, #128	; 0x80
 800455a:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 800455c:	2001      	movs	r0, #1
 800455e:	4770      	bx	lr
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8004560:	6802      	ldr	r2, [r0, #0]
    return HAL_ERROR;
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8004562:	2305      	movs	r3, #5
 8004564:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8004568:	6813      	ldr	r3, [r2, #0]
 800456a:	f023 0301 	bic.w	r3, r3, #1
 800456e:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8004570:	2000      	movs	r0, #0
}
 8004572:	4770      	bx	lr

08004574 <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8004574:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
 8004576:	2300      	movs	r3, #0
 8004578:	9301      	str	r3, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800457a:	6d85      	ldr	r5, [r0, #88]	; 0x58
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
  uint32_t timeout = SystemCoreClock / 9600U;
 800457c:	4b59      	ldr	r3, [pc, #356]	; (80046e4 <HAL_DMA_IRQHandler+0x170>)
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;

  tmpisr = regs->ISR;

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800457e:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
  uint32_t timeout = SystemCoreClock / 9600U;
 8004580:	681f      	ldr	r7, [r3, #0]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;

  tmpisr = regs->ISR;
 8004582:	682e      	ldr	r6, [r5, #0]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8004584:	2308      	movs	r3, #8
 8004586:	4093      	lsls	r3, r2
 8004588:	421e      	tst	r6, r3
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800458a:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;

  tmpisr = regs->ISR;

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800458c:	d00c      	beq.n	80045a8 <HAL_DMA_IRQHandler+0x34>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 800458e:	6801      	ldr	r1, [r0, #0]
 8004590:	6808      	ldr	r0, [r1, #0]
 8004592:	0740      	lsls	r0, r0, #29
 8004594:	d508      	bpl.n	80045a8 <HAL_DMA_IRQHandler+0x34>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8004596:	6808      	ldr	r0, [r1, #0]
 8004598:	f020 0004 	bic.w	r0, r0, #4
 800459c:	6008      	str	r0, [r1, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 800459e:	60ab      	str	r3, [r5, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 80045a0:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80045a2:	f043 0301 	orr.w	r3, r3, #1
 80045a6:	6563      	str	r3, [r4, #84]	; 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 80045a8:	2301      	movs	r3, #1
 80045aa:	4093      	lsls	r3, r2
 80045ac:	421e      	tst	r6, r3
 80045ae:	d008      	beq.n	80045c2 <HAL_DMA_IRQHandler+0x4e>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 80045b0:	6821      	ldr	r1, [r4, #0]
 80045b2:	6949      	ldr	r1, [r1, #20]
 80045b4:	0609      	lsls	r1, r1, #24
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 80045b6:	bf41      	itttt	mi
 80045b8:	60ab      	strmi	r3, [r5, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 80045ba:	6d63      	ldrmi	r3, [r4, #84]	; 0x54
 80045bc:	f043 0302 	orrmi.w	r3, r3, #2
 80045c0:	6563      	strmi	r3, [r4, #84]	; 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 80045c2:	2304      	movs	r3, #4
 80045c4:	4093      	lsls	r3, r2
 80045c6:	421e      	tst	r6, r3
 80045c8:	d008      	beq.n	80045dc <HAL_DMA_IRQHandler+0x68>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 80045ca:	6821      	ldr	r1, [r4, #0]
 80045cc:	6809      	ldr	r1, [r1, #0]
 80045ce:	0788      	lsls	r0, r1, #30
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 80045d0:	bf41      	itttt	mi
 80045d2:	60ab      	strmi	r3, [r5, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80045d4:	6d63      	ldrmi	r3, [r4, #84]	; 0x54
 80045d6:	f043 0304 	orrmi.w	r3, r3, #4
 80045da:	6563      	strmi	r3, [r4, #84]	; 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 80045dc:	2310      	movs	r3, #16
 80045de:	fa03 f202 	lsl.w	r2, r3, r2
 80045e2:	4216      	tst	r6, r2
 80045e4:	d017      	beq.n	8004616 <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80045e6:	6823      	ldr	r3, [r4, #0]
 80045e8:	6819      	ldr	r1, [r3, #0]
 80045ea:	0709      	lsls	r1, r1, #28
 80045ec:	d513      	bpl.n	8004616 <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80045ee:	60aa      	str	r2, [r5, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80045f0:	681a      	ldr	r2, [r3, #0]
 80045f2:	0350      	lsls	r0, r2, #13
 80045f4:	d504      	bpl.n	8004600 <HAL_DMA_IRQHandler+0x8c>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80045f6:	681b      	ldr	r3, [r3, #0]
 80045f8:	0319      	lsls	r1, r3, #12
 80045fa:	d508      	bpl.n	800460e <HAL_DMA_IRQHandler+0x9a>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 80045fc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80045fe:	e007      	b.n	8004610 <HAL_DMA_IRQHandler+0x9c>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8004600:	681a      	ldr	r2, [r3, #0]
 8004602:	05d2      	lsls	r2, r2, #23
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8004604:	bf5e      	ittt	pl
 8004606:	681a      	ldrpl	r2, [r3, #0]
 8004608:	f022 0208 	bicpl.w	r2, r2, #8
 800460c:	601a      	strpl	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 800460e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004610:	b10b      	cbz	r3, 8004616 <HAL_DMA_IRQHandler+0xa2>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 8004612:	4620      	mov	r0, r4
 8004614:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8004616:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8004618:	2220      	movs	r2, #32
 800461a:	408a      	lsls	r2, r1
 800461c:	4216      	tst	r6, r2
 800461e:	d03b      	beq.n	8004698 <HAL_DMA_IRQHandler+0x124>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8004620:	6823      	ldr	r3, [r4, #0]
 8004622:	6818      	ldr	r0, [r3, #0]
 8004624:	06c6      	lsls	r6, r0, #27
 8004626:	d537      	bpl.n	8004698 <HAL_DMA_IRQHandler+0x124>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8004628:	60aa      	str	r2, [r5, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 800462a:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
 800462e:	2a05      	cmp	r2, #5
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8004630:	681a      	ldr	r2, [r3, #0]
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8004632:	d119      	bne.n	8004668 <HAL_DMA_IRQHandler+0xf4>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8004634:	f022 0216 	bic.w	r2, r2, #22
 8004638:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 800463a:	695a      	ldr	r2, [r3, #20]
 800463c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8004640:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8004642:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8004644:	b90a      	cbnz	r2, 800464a <HAL_DMA_IRQHandler+0xd6>
 8004646:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8004648:	b11a      	cbz	r2, 8004652 <HAL_DMA_IRQHandler+0xde>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 800464a:	681a      	ldr	r2, [r3, #0]
 800464c:	f022 0208 	bic.w	r2, r2, #8
 8004650:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8004652:	233f      	movs	r3, #63	; 0x3f
 8004654:	408b      	lsls	r3, r1
 8004656:	60ab      	str	r3, [r5, #8]

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8004658:	2300      	movs	r3, #0
 800465a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 800465e:	2301      	movs	r3, #1
 8004660:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

        if(hdma->XferAbortCallback != NULL)
 8004664:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8004666:	e037      	b.n	80046d8 <HAL_DMA_IRQHandler+0x164>
          hdma->XferAbortCallback(hdma);
        }
        return;
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8004668:	0350      	lsls	r0, r2, #13
 800466a:	d504      	bpl.n	8004676 <HAL_DMA_IRQHandler+0x102>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 800466c:	681b      	ldr	r3, [r3, #0]
 800466e:	0319      	lsls	r1, r3, #12
 8004670:	d40e      	bmi.n	8004690 <HAL_DMA_IRQHandler+0x11c>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8004672:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8004674:	e00d      	b.n	8004692 <HAL_DMA_IRQHandler+0x11e>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8004676:	681a      	ldr	r2, [r3, #0]
 8004678:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 800467c:	d108      	bne.n	8004690 <HAL_DMA_IRQHandler+0x11c>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 800467e:	6819      	ldr	r1, [r3, #0]
 8004680:	f021 0110 	bic.w	r1, r1, #16
 8004684:	6019      	str	r1, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 8004686:	2301      	movs	r3, #1
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 8004688:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 800468c:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
 8004690:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004692:	b10b      	cbz	r3, 8004698 <HAL_DMA_IRQHandler+0x124>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8004694:	4620      	mov	r0, r4
 8004696:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8004698:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800469a:	b303      	cbz	r3, 80046de <HAL_DMA_IRQHandler+0x16a>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 800469c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800469e:	07da      	lsls	r2, r3, #31
 80046a0:	d519      	bpl.n	80046d6 <HAL_DMA_IRQHandler+0x162>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 80046a2:	2305      	movs	r3, #5

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 80046a4:	6822      	ldr	r2, [r4, #0]
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 80046a6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 80046aa:	6813      	ldr	r3, [r2, #0]
 80046ac:	f023 0301 	bic.w	r3, r3, #1
 80046b0:	6013      	str	r3, [r2, #0]
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
  uint32_t timeout = SystemCoreClock / 9600U;
 80046b2:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 80046b6:	fbb7 f7f3 	udiv	r7, r7, r3
      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);

      do
      {
        if (++count > timeout)
 80046ba:	9b01      	ldr	r3, [sp, #4]
 80046bc:	3301      	adds	r3, #1
 80046be:	429f      	cmp	r7, r3
 80046c0:	9301      	str	r3, [sp, #4]
 80046c2:	d302      	bcc.n	80046ca <HAL_DMA_IRQHandler+0x156>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 80046c4:	6813      	ldr	r3, [r2, #0]
      hdma->State = HAL_DMA_STATE_ABORT;

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);

      do
 80046c6:	07db      	lsls	r3, r3, #31
 80046c8:	d4f7      	bmi.n	80046ba <HAL_DMA_IRQHandler+0x146>
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80046ca:	2300      	movs	r3, #0
 80046cc:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 80046d0:	2301      	movs	r3, #1
 80046d2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    }

    if(hdma->XferErrorCallback != NULL)
 80046d6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80046d8:	b10b      	cbz	r3, 80046de <HAL_DMA_IRQHandler+0x16a>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 80046da:	4620      	mov	r0, r4
 80046dc:	4798      	blx	r3
    }
  }
}
 80046de:	b003      	add	sp, #12
 80046e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80046e2:	bf00      	nop
 80046e4:	20000004 	.word	0x20000004

080046e8 <_ZL24FLASH_Program_DoubleWordmy>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80046e8:	4908      	ldr	r1, [pc, #32]	; (800470c <_ZL24FLASH_Program_DoubleWordmy+0x24>)
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 80046ea:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80046ec:	690c      	ldr	r4, [r1, #16]
 80046ee:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 80046f2:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 80046f4:	690c      	ldr	r4, [r1, #16]
 80046f6:	f444 7440 	orr.w	r4, r4, #768	; 0x300
 80046fa:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_CR_PG;
 80046fc:	690c      	ldr	r4, [r1, #16]
 80046fe:	f044 0401 	orr.w	r4, r4, #1
 8004702:	610c      	str	r4, [r1, #16]

  /* Program the double-word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8004704:	6002      	str	r2, [r0, #0]
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8004706:	6043      	str	r3, [r0, #4]
 8004708:	bd10      	pop	{r4, pc}
 800470a:	bf00      	nop
 800470c:	40023c00 	.word	0x40023c00

08004710 <_ZL18FLASH_Program_Wordmm>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8004710:	4b07      	ldr	r3, [pc, #28]	; (8004730 <_ZL18FLASH_Program_Wordmm+0x20>)
 8004712:	691a      	ldr	r2, [r3, #16]
 8004714:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8004718:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 800471a:	691a      	ldr	r2, [r3, #16]
 800471c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8004720:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8004722:	691a      	ldr	r2, [r3, #16]
 8004724:	f042 0201 	orr.w	r2, r2, #1
 8004728:	611a      	str	r2, [r3, #16]

  *(__IO uint32_t*)Address = Data;
 800472a:	6001      	str	r1, [r0, #0]
 800472c:	4770      	bx	lr
 800472e:	bf00      	nop
 8004730:	40023c00 	.word	0x40023c00

08004734 <_ZL22FLASH_Program_HalfWordmt>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8004734:	4b07      	ldr	r3, [pc, #28]	; (8004754 <_ZL22FLASH_Program_HalfWordmt+0x20>)
 8004736:	691a      	ldr	r2, [r3, #16]
 8004738:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800473c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 800473e:	691a      	ldr	r2, [r3, #16]
 8004740:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8004744:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8004746:	691a      	ldr	r2, [r3, #16]
 8004748:	f042 0201 	orr.w	r2, r2, #1
 800474c:	611a      	str	r2, [r3, #16]

  *(__IO uint16_t*)Address = Data;
 800474e:	8001      	strh	r1, [r0, #0]
 8004750:	4770      	bx	lr
 8004752:	bf00      	nop
 8004754:	40023c00 	.word	0x40023c00

08004758 <_ZL18FLASH_SetErrorCodev>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8004758:	4b21      	ldr	r3, [pc, #132]	; (80047e0 <_ZL18FLASH_SetErrorCodev+0x88>)
 800475a:	68da      	ldr	r2, [r3, #12]
 800475c:	06d2      	lsls	r2, r2, #27
 800475e:	d506      	bpl.n	800476e <_ZL18FLASH_SetErrorCodev+0x16>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8004760:	4920      	ldr	r1, [pc, #128]	; (80047e4 <_ZL18FLASH_SetErrorCodev+0x8c>)
 8004762:	69ca      	ldr	r2, [r1, #28]
 8004764:	f042 0210 	orr.w	r2, r2, #16
 8004768:	61ca      	str	r2, [r1, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 800476a:	2210      	movs	r2, #16
 800476c:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 800476e:	68db      	ldr	r3, [r3, #12]
 8004770:	069b      	lsls	r3, r3, #26
 8004772:	d507      	bpl.n	8004784 <_ZL18FLASH_SetErrorCodev+0x2c>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8004774:	4a1b      	ldr	r2, [pc, #108]	; (80047e4 <_ZL18FLASH_SetErrorCodev+0x8c>)
 8004776:	69d3      	ldr	r3, [r2, #28]
 8004778:	f043 0308 	orr.w	r3, r3, #8
 800477c:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 800477e:	4b18      	ldr	r3, [pc, #96]	; (80047e0 <_ZL18FLASH_SetErrorCodev+0x88>)
 8004780:	2220      	movs	r2, #32
 8004782:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8004784:	4b16      	ldr	r3, [pc, #88]	; (80047e0 <_ZL18FLASH_SetErrorCodev+0x88>)
 8004786:	68da      	ldr	r2, [r3, #12]
 8004788:	0650      	lsls	r0, r2, #25
 800478a:	d506      	bpl.n	800479a <_ZL18FLASH_SetErrorCodev+0x42>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 800478c:	4915      	ldr	r1, [pc, #84]	; (80047e4 <_ZL18FLASH_SetErrorCodev+0x8c>)
 800478e:	69ca      	ldr	r2, [r1, #28]
 8004790:	f042 0204 	orr.w	r2, r2, #4
 8004794:	61ca      	str	r2, [r1, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 8004796:	2240      	movs	r2, #64	; 0x40
 8004798:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 800479a:	68db      	ldr	r3, [r3, #12]
 800479c:	0619      	lsls	r1, r3, #24
 800479e:	d507      	bpl.n	80047b0 <_ZL18FLASH_SetErrorCodev+0x58>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 80047a0:	4a10      	ldr	r2, [pc, #64]	; (80047e4 <_ZL18FLASH_SetErrorCodev+0x8c>)
 80047a2:	69d3      	ldr	r3, [r2, #28]
 80047a4:	f043 0302 	orr.w	r3, r3, #2
 80047a8:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 80047aa:	4b0d      	ldr	r3, [pc, #52]	; (80047e0 <_ZL18FLASH_SetErrorCodev+0x88>)
 80047ac:	2280      	movs	r2, #128	; 0x80
 80047ae:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR) 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
 80047b0:	4b0b      	ldr	r3, [pc, #44]	; (80047e0 <_ZL18FLASH_SetErrorCodev+0x88>)
 80047b2:	68da      	ldr	r2, [r3, #12]
 80047b4:	05d2      	lsls	r2, r2, #23
 80047b6:	d507      	bpl.n	80047c8 <_ZL18FLASH_SetErrorCodev+0x70>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 80047b8:	490a      	ldr	r1, [pc, #40]	; (80047e4 <_ZL18FLASH_SetErrorCodev+0x8c>)
 80047ba:	69ca      	ldr	r2, [r1, #28]
 80047bc:	f042 0201 	orr.w	r2, r2, #1
 80047c0:	61ca      	str	r2, [r1, #28]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 80047c2:	f44f 7280 	mov.w	r2, #256	; 0x100
 80047c6:	60da      	str	r2, [r3, #12]
  }
#endif /* FLASH_SR_RDERR */  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 80047c8:	68db      	ldr	r3, [r3, #12]
 80047ca:	079b      	lsls	r3, r3, #30
 80047cc:	d507      	bpl.n	80047de <_ZL18FLASH_SetErrorCodev+0x86>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 80047ce:	4a05      	ldr	r2, [pc, #20]	; (80047e4 <_ZL18FLASH_SetErrorCodev+0x8c>)
 80047d0:	69d3      	ldr	r3, [r2, #28]
 80047d2:	f043 0320 	orr.w	r3, r3, #32
 80047d6:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 80047d8:	4b01      	ldr	r3, [pc, #4]	; (80047e0 <_ZL18FLASH_SetErrorCodev+0x88>)
 80047da:	2202      	movs	r2, #2
 80047dc:	60da      	str	r2, [r3, #12]
 80047de:	4770      	bx	lr
 80047e0:	40023c00 	.word	0x40023c00
 80047e4:	20003ce0 	.word	0x20003ce0

080047e8 <HAL_FLASH_Unlock>:
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;

  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80047e8:	4b06      	ldr	r3, [pc, #24]	; (8004804 <HAL_FLASH_Unlock+0x1c>)
 80047ea:	691a      	ldr	r2, [r3, #16]
 80047ec:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 80047ee:	bfbf      	itttt	lt
 80047f0:	4a05      	ldrlt	r2, [pc, #20]	; (8004808 <HAL_FLASH_Unlock+0x20>)
 80047f2:	605a      	strlt	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 80047f4:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 80047f8:	605a      	strlt	r2, [r3, #4]

    /* Verify Flash is unlocked */
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 80047fa:	bfba      	itte	lt
 80047fc:	6918      	ldrlt	r0, [r3, #16]
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;
 80047fe:	0fc0      	lsrlt	r0, r0, #31
 8004800:	2000      	movge	r0, #0
      status = HAL_ERROR;
    }
  }

  return status;
}
 8004802:	4770      	bx	lr
 8004804:	40023c00 	.word	0x40023c00
 8004808:	45670123 	.word	0x45670123

0800480c <HAL_FLASH_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 800480c:	4a03      	ldr	r2, [pc, #12]	; (800481c <HAL_FLASH_Lock+0x10>)
 800480e:	6913      	ldr	r3, [r2, #16]
 8004810:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8004814:	6113      	str	r3, [r2, #16]
  
  return HAL_OK;  
}
 8004816:	2000      	movs	r0, #0
 8004818:	4770      	bx	lr
 800481a:	bf00      	nop
 800481c:	40023c00 	.word	0x40023c00

08004820 <FLASH_WaitForLastOperation>:
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
  uint32_t tickstart = 0U;
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8004820:	4b12      	ldr	r3, [pc, #72]	; (800486c <FLASH_WaitForLastOperation+0x4c>)
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operationtimeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 8004822:	b570      	push	{r4, r5, r6, lr}
  uint32_t tickstart = 0U;
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8004824:	2200      	movs	r2, #0
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operationtimeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 8004826:	4604      	mov	r4, r0
  uint32_t tickstart = 0U;
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8004828:	61da      	str	r2, [r3, #28]
  
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  /* Get tick */
  tickstart = HAL_GetTick();
 800482a:	f7ff fbfd 	bl	8004028 <HAL_GetTick>

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 800482e:	4e10      	ldr	r6, [pc, #64]	; (8004870 <FLASH_WaitForLastOperation+0x50>)
  
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  /* Get tick */
  tickstart = HAL_GetTick();
 8004830:	4605      	mov	r5, r0

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8004832:	68f3      	ldr	r3, [r6, #12]
 8004834:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8004838:	4b0d      	ldr	r3, [pc, #52]	; (8004870 <FLASH_WaitForLastOperation+0x50>)
 800483a:	d008      	beq.n	800484e <FLASH_WaitForLastOperation+0x2e>
  { 
    if(Timeout != HAL_MAX_DELAY)
 800483c:	1c61      	adds	r1, r4, #1
 800483e:	d0f8      	beq.n	8004832 <FLASH_WaitForLastOperation+0x12>
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8004840:	b194      	cbz	r4, 8004868 <FLASH_WaitForLastOperation+0x48>
 8004842:	f7ff fbf1 	bl	8004028 <HAL_GetTick>
 8004846:	1b40      	subs	r0, r0, r5
 8004848:	4284      	cmp	r4, r0
 800484a:	d30d      	bcc.n	8004868 <FLASH_WaitForLastOperation+0x48>
 800484c:	e7f1      	b.n	8004832 <FLASH_WaitForLastOperation+0x12>
      }
    } 
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 800484e:	68da      	ldr	r2, [r3, #12]
 8004850:	07d2      	lsls	r2, r2, #31
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8004852:	bf44      	itt	mi
 8004854:	2201      	movmi	r2, #1
 8004856:	60da      	strmi	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR)  
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 8004858:	68d8      	ldr	r0, [r3, #12]
 800485a:	f410 70f9 	ands.w	r0, r0, #498	; 0x1f2
 800485e:	d004      	beq.n	800486a <FLASH_WaitForLastOperation+0x4a>
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
                           FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)
#endif /* FLASH_SR_RDERR */
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
 8004860:	f7ff ff7a 	bl	8004758 <_ZL18FLASH_SetErrorCodev>
    return HAL_ERROR;
 8004864:	2001      	movs	r0, #1
 8004866:	bd70      	pop	{r4, r5, r6, pc}
  { 
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
      {
        return HAL_TIMEOUT;
 8004868:	2003      	movs	r0, #3
  }

  /* If there is no error flag set */
  return HAL_OK;
  
}  
 800486a:	bd70      	pop	{r4, r5, r6, pc}
 800486c:	20003ce0 	.word	0x20003ce0
 8004870:	40023c00 	.word	0x40023c00

08004874 <HAL_FLASH_Program>:
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8004874:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8004878:	4d20      	ldr	r5, [pc, #128]	; (80048fc <HAL_FLASH_Program+0x88>)
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 800487a:	4698      	mov	r8, r3
  HAL_StatusTypeDef status = HAL_ERROR;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 800487c:	7e2b      	ldrb	r3, [r5, #24]
 800487e:	2b01      	cmp	r3, #1
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8004880:	4607      	mov	r7, r0
 8004882:	460e      	mov	r6, r1
 8004884:	4614      	mov	r4, r2
  HAL_StatusTypeDef status = HAL_ERROR;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8004886:	d035      	beq.n	80048f4 <HAL_FLASH_Program+0x80>
 8004888:	2301      	movs	r3, #1
  
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800488a:	f24c 3050 	movw	r0, #50000	; 0xc350
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
  HAL_StatusTypeDef status = HAL_ERROR;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 800488e:	762b      	strb	r3, [r5, #24]
  
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8004890:	f7ff ffc6 	bl	8004820 <FLASH_WaitForLastOperation>
  
  if(status == HAL_OK)
 8004894:	bb50      	cbnz	r0, 80048ec <HAL_FLASH_Program+0x78>
  {
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 8004896:	b96f      	cbnz	r7, 80048b4 <HAL_FLASH_Program+0x40>
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8004898:	4b19      	ldr	r3, [pc, #100]	; (8004900 <HAL_FLASH_Program+0x8c>)
 800489a:	691a      	ldr	r2, [r3, #16]
 800489c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80048a0:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 80048a2:	691a      	ldr	r2, [r3, #16]
 80048a4:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 80048a6:	691a      	ldr	r2, [r3, #16]
  if(status == HAL_OK)
  {
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
    {
      /*Program byte (8-bit) at a specified address.*/
      FLASH_Program_Byte(Address, (uint8_t) Data);
 80048a8:	b2e4      	uxtb	r4, r4
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
  FLASH->CR |= FLASH_PSIZE_BYTE;
  FLASH->CR |= FLASH_CR_PG;
 80048aa:	f042 0201 	orr.w	r2, r2, #1
 80048ae:	611a      	str	r2, [r3, #16]

  *(__IO uint8_t*)Address = Data;
 80048b0:	7034      	strb	r4, [r6, #0]
 80048b2:	e012      	b.n	80048da <HAL_FLASH_Program+0x66>
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
    {
      /*Program byte (8-bit) at a specified address.*/
      FLASH_Program_Byte(Address, (uint8_t) Data);
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 80048b4:	2f01      	cmp	r7, #1
 80048b6:	d104      	bne.n	80048c2 <HAL_FLASH_Program+0x4e>
    {
      /*Program halfword (16-bit) at a specified address.*/
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 80048b8:	b2a1      	uxth	r1, r4
 80048ba:	4630      	mov	r0, r6
 80048bc:	f7ff ff3a 	bl	8004734 <_ZL22FLASH_Program_HalfWordmt>
 80048c0:	e00b      	b.n	80048da <HAL_FLASH_Program+0x66>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 80048c2:	2f02      	cmp	r7, #2
 80048c4:	d104      	bne.n	80048d0 <HAL_FLASH_Program+0x5c>
    {
      /*Program word (32-bit) at a specified address.*/
      FLASH_Program_Word(Address, (uint32_t) Data);
 80048c6:	4621      	mov	r1, r4
 80048c8:	4630      	mov	r0, r6
 80048ca:	f7ff ff21 	bl	8004710 <_ZL18FLASH_Program_Wordmm>
 80048ce:	e004      	b.n	80048da <HAL_FLASH_Program+0x66>
    }
    else
    {
      /*Program double word (64-bit) at a specified address.*/
      FLASH_Program_DoubleWord(Address, Data);
 80048d0:	4622      	mov	r2, r4
 80048d2:	4643      	mov	r3, r8
 80048d4:	4630      	mov	r0, r6
 80048d6:	f7ff ff07 	bl	80046e8 <_ZL24FLASH_Program_DoubleWordmy>
    }
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80048da:	f24c 3050 	movw	r0, #50000	; 0xc350
 80048de:	f7ff ff9f 	bl	8004820 <FLASH_WaitForLastOperation>
    
    /* If the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);  
 80048e2:	4a07      	ldr	r2, [pc, #28]	; (8004900 <HAL_FLASH_Program+0x8c>)
 80048e4:	6913      	ldr	r3, [r2, #16]
 80048e6:	f023 0301 	bic.w	r3, r3, #1
 80048ea:	6113      	str	r3, [r2, #16]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 80048ec:	2300      	movs	r3, #0
 80048ee:	762b      	strb	r3, [r5, #24]
  
  return status;
 80048f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
  HAL_StatusTypeDef status = HAL_ERROR;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 80048f4:	2002      	movs	r0, #2
  
  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
  
  return status;
}
 80048f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80048fa:	bf00      	nop
 80048fc:	20003ce0 	.word	0x20003ce0
 8004900:	40023c00 	.word	0x40023c00

08004904 <_ZL15FLASH_MassErasehm.isra.0>:
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));
  
  /* If the previous operation is completed, proceed to erase all sectors */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8004904:	4b07      	ldr	r3, [pc, #28]	; (8004924 <_ZL15FLASH_MassErasehm.isra.0+0x20>)
 8004906:	691a      	ldr	r2, [r3, #16]
 8004908:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800490c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_MER;
 800490e:	691a      	ldr	r2, [r3, #16]
 8004910:	f042 0204 	orr.w	r2, r2, #4
 8004914:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
 8004916:	691a      	ldr	r2, [r3, #16]
 8004918:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800491c:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 8004920:	6118      	str	r0, [r3, #16]
 8004922:	4770      	bx	lr
 8004924:	40023c00 	.word	0x40023c00

08004928 <FLASH_Erase_Sector>:

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
 8004928:	b151      	cbz	r1, 8004940 <FLASH_Erase_Sector+0x18>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
 800492a:	2901      	cmp	r1, #1
 800492c:	d006      	beq.n	800493c <FLASH_Erase_Sector+0x14>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
 800492e:	2902      	cmp	r1, #2
  {
    tmp_psize = FLASH_PSIZE_WORD;
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8004930:	bf0c      	ite	eq
 8004932:	f44f 7100 	moveq.w	r1, #512	; 0x200
 8004936:	f44f 7140 	movne.w	r1, #768	; 0x300
 800493a:	e001      	b.n	8004940 <FLASH_Erase_Sector+0x18>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 800493c:	f44f 7180 	mov.w	r1, #256	; 0x100
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }

  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8004940:	4b0b      	ldr	r3, [pc, #44]	; (8004970 <FLASH_Erase_Sector+0x48>)
 8004942:	691a      	ldr	r2, [r3, #16]
 8004944:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8004948:	611a      	str	r2, [r3, #16]
  FLASH->CR |= tmp_psize;
 800494a:	691a      	ldr	r2, [r3, #16]
 800494c:	4311      	orrs	r1, r2
 800494e:	6119      	str	r1, [r3, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 8004950:	691a      	ldr	r2, [r3, #16]
 8004952:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8004956:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 8004958:	691a      	ldr	r2, [r3, #16]
 800495a:	f042 0202 	orr.w	r2, r2, #2
 800495e:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
 8004962:	6118      	str	r0, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT;
 8004964:	691a      	ldr	r2, [r3, #16]
 8004966:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800496a:	611a      	str	r2, [r3, #16]
 800496c:	4770      	bx	lr
 800496e:	bf00      	nop
 8004970:	40023c00 	.word	0x40023c00

08004974 <FLASH_FlushCaches>:
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
 8004974:	4b14      	ldr	r3, [pc, #80]	; (80049c8 <FLASH_FlushCaches+0x54>)
 8004976:	681a      	ldr	r2, [r3, #0]
 8004978:	0591      	lsls	r1, r2, #22
 800497a:	d50f      	bpl.n	800499c <FLASH_FlushCaches+0x28>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 800497c:	681a      	ldr	r2, [r3, #0]
 800497e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8004982:	601a      	str	r2, [r3, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8004984:	681a      	ldr	r2, [r3, #0]
 8004986:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800498a:	601a      	str	r2, [r3, #0]
 800498c:	681a      	ldr	r2, [r3, #0]
 800498e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8004992:	601a      	str	r2, [r3, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8004994:	681a      	ldr	r2, [r3, #0]
 8004996:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800499a:	601a      	str	r2, [r3, #0]
  }
  
  /* Flush data cache */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 800499c:	4b0a      	ldr	r3, [pc, #40]	; (80049c8 <FLASH_FlushCaches+0x54>)
 800499e:	681a      	ldr	r2, [r3, #0]
 80049a0:	0552      	lsls	r2, r2, #21
 80049a2:	d50f      	bpl.n	80049c4 <FLASH_FlushCaches+0x50>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
 80049a4:	681a      	ldr	r2, [r3, #0]
 80049a6:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80049aa:	601a      	str	r2, [r3, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 80049ac:	681a      	ldr	r2, [r3, #0]
 80049ae:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80049b2:	601a      	str	r2, [r3, #0]
 80049b4:	681a      	ldr	r2, [r3, #0]
 80049b6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80049ba:	601a      	str	r2, [r3, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 80049bc:	681a      	ldr	r2, [r3, #0]
 80049be:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80049c2:	601a      	str	r2, [r3, #0]
 80049c4:	4770      	bx	lr
 80049c6:	bf00      	nop
 80049c8:	40023c00 	.word	0x40023c00

080049cc <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
 80049cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t index = 0U;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 80049d0:	4e24      	ldr	r6, [pc, #144]	; (8004a64 <HAL_FLASHEx_Erase+0x98>)
 80049d2:	7e33      	ldrb	r3, [r6, #24]
 80049d4:	2b01      	cmp	r3, #1
  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
 80049d6:	4605      	mov	r5, r0
 80049d8:	4688      	mov	r8, r1
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t index = 0U;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 80049da:	d040      	beq.n	8004a5e <HAL_FLASHEx_Erase+0x92>
 80049dc:	2301      	movs	r3, #1

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80049de:	f24c 3050 	movw	r0, #50000	; 0xc350
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t index = 0U;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 80049e2:	7633      	strb	r3, [r6, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80049e4:	f7ff ff1c 	bl	8004820 <FLASH_WaitForLastOperation>

  if(status == HAL_OK)
 80049e8:	4604      	mov	r4, r0
 80049ea:	bb98      	cbnz	r0, 8004a54 <HAL_FLASHEx_Erase+0x88>
  {
    /*Initialization of SectorError variable*/
    *SectorError = 0xFFFFFFFFU;
 80049ec:	f04f 33ff 	mov.w	r3, #4294967295
 80049f0:	f8c8 3000 	str.w	r3, [r8]
    
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 80049f4:	682b      	ldr	r3, [r5, #0]
 80049f6:	2b01      	cmp	r3, #1
 80049f8:	d10d      	bne.n	8004a16 <HAL_FLASHEx_Erase+0x4a>
    {
      /*Mass erase to be done*/
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 80049fa:	7c28      	ldrb	r0, [r5, #16]
 80049fc:	f7ff ff82 	bl	8004904 <_ZL15FLASH_MassErasehm.isra.0>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8004a00:	f24c 3050 	movw	r0, #50000	; 0xc350
 8004a04:	f7ff ff0c 	bl	8004820 <FLASH_WaitForLastOperation>
      
      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= (~FLASH_MER_BIT);
 8004a08:	4a17      	ldr	r2, [pc, #92]	; (8004a68 <HAL_FLASHEx_Erase+0x9c>)
 8004a0a:	6913      	ldr	r3, [r2, #16]
 8004a0c:	f023 0304 	bic.w	r3, r3, #4
    {
      /*Mass erase to be done*/
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8004a10:	4604      	mov	r4, r0
      
      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= (~FLASH_MER_BIT);
 8004a12:	6113      	str	r3, [r2, #16]
 8004a14:	e01c      	b.n	8004a50 <HAL_FLASHEx_Erase+0x84>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8004a16:	68af      	ldr	r7, [r5, #8]

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
        
        /* If the erase operation is completed, disable the SER and SNB Bits */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 8004a18:	f8df 904c 	ldr.w	r9, [pc, #76]	; 8004a68 <HAL_FLASHEx_Erase+0x9c>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8004a1c:	68ea      	ldr	r2, [r5, #12]
 8004a1e:	68ab      	ldr	r3, [r5, #8]
 8004a20:	4413      	add	r3, r2
 8004a22:	429f      	cmp	r7, r3
 8004a24:	d214      	bcs.n	8004a50 <HAL_FLASHEx_Erase+0x84>
      {
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 8004a26:	7c29      	ldrb	r1, [r5, #16]
 8004a28:	4638      	mov	r0, r7
 8004a2a:	f7ff ff7d 	bl	8004928 <FLASH_Erase_Sector>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8004a2e:	f24c 3050 	movw	r0, #50000	; 0xc350
 8004a32:	f7ff fef5 	bl	8004820 <FLASH_WaitForLastOperation>
        
        /* If the erase operation is completed, disable the SER and SNB Bits */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 8004a36:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8004a3a:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
 8004a3e:	f8c9 3010 	str.w	r3, [r9, #16]

        if(status != HAL_OK) 
 8004a42:	b118      	cbz	r0, 8004a4c <HAL_FLASHEx_Erase+0x80>
        {
          /* In case of error, stop erase procedure and return the faulty sector*/
          *SectorError = index;
 8004a44:	f8c8 7000 	str.w	r7, [r8]
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
      {
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8004a48:	4604      	mov	r4, r0

        if(status != HAL_OK) 
        {
          /* In case of error, stop erase procedure and return the faulty sector*/
          *SectorError = index;
          break;
 8004a4a:	e001      	b.n	8004a50 <HAL_FLASHEx_Erase+0x84>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8004a4c:	3701      	adds	r7, #1
 8004a4e:	e7e5      	b.n	8004a1c <HAL_FLASHEx_Erase+0x50>
          break;
        }
      }
    }
    /* Flush the caches to be sure of the data consistency */
    FLASH_FlushCaches();    
 8004a50:	f7ff ff90 	bl	8004974 <FLASH_FlushCaches>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 8004a54:	2300      	movs	r3, #0
 8004a56:	7633      	strb	r3, [r6, #24]

  return status;
 8004a58:	4620      	mov	r0, r4
 8004a5a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
{
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t index = 0U;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8004a5e:	2002      	movs	r0, #2

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);

  return status;
}
 8004a60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004a64:	20003ce0 	.word	0x20003ce0
 8004a68:	40023c00 	.word	0x40023c00

08004a6c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8004a6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8004a70:	4e5b      	ldr	r6, [pc, #364]	; (8004be0 <HAL_GPIO_Init+0x174>)
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8004a72:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004a74:	f8df 8170 	ldr.w	r8, [pc, #368]	; 8004be8 <HAL_GPIO_Init+0x17c>
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8004a78:	b085      	sub	sp, #20

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8004a7a:	f04f 0901 	mov.w	r9, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8004a7e:	9301      	str	r3, [sp, #4]
 8004a80:	46b6      	mov	lr, r6
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8004a82:	2300      	movs	r3, #0
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8004a84:	9a01      	ldr	r2, [sp, #4]

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8004a86:	fa09 f403 	lsl.w	r4, r9, r3
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8004a8a:	ea34 0202 	bics.w	r2, r4, r2
 8004a8e:	f040 80a0 	bne.w	8004bd2 <HAL_GPIO_Init+0x166>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8004a92:	684a      	ldr	r2, [r1, #4]
 8004a94:	f022 0c10 	bic.w	ip, r2, #16
 8004a98:	f1bc 0f02 	cmp.w	ip, #2
 8004a9c:	d114      	bne.n	8004ac8 <HAL_GPIO_Init+0x5c>
 8004a9e:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8004aa2:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8004aa6:	f003 0b07 	and.w	fp, r3, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8004aaa:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8004aae:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8004ab2:	250f      	movs	r5, #15
 8004ab4:	fa05 f50b 	lsl.w	r5, r5, fp
 8004ab8:	ea27 0505 	bic.w	r5, r7, r5
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8004abc:	690f      	ldr	r7, [r1, #16]
 8004abe:	fa07 f70b 	lsl.w	r7, r7, fp
 8004ac2:	432f      	orrs	r7, r5
        GPIOx->AFR[position >> 3U] = temp;
 8004ac4:	f8ca 7020 	str.w	r7, [sl, #32]
 8004ac8:	ea4f 0b43 	mov.w	fp, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8004acc:	2703      	movs	r7, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8004ace:	6805      	ldr	r5, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8004ad0:	fa07 fa0b 	lsl.w	sl, r7, fp
 8004ad4:	ea6f 0a0a 	mvn.w	sl, sl
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8004ad8:	4017      	ands	r7, r2
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8004ada:	ea05 050a 	and.w	r5, r5, sl
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8004ade:	fa07 f70b 	lsl.w	r7, r7, fp
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8004ae2:	f10c 3cff 	add.w	ip, ip, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8004ae6:	433d      	orrs	r5, r7
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8004ae8:	f1bc 0f01 	cmp.w	ip, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 8004aec:	6005      	str	r5, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8004aee:	d80f      	bhi.n	8004b10 <HAL_GPIO_Init+0xa4>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8004af0:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
 8004af2:	68cf      	ldr	r7, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8004af4:	ea0a 0505 	and.w	r5, sl, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 8004af8:	fa07 f70b 	lsl.w	r7, r7, fp
 8004afc:	432f      	orrs	r7, r5
        GPIOx->OSPEEDR = temp;
 8004afe:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8004b00:	6845      	ldr	r5, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8004b02:	f3c2 1700 	ubfx	r7, r2, #4, #1
        temp |= (GPIO_Init->Speed << (position * 2U));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8004b06:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8004b0a:	409f      	lsls	r7, r3
 8004b0c:	433d      	orrs	r5, r7
        GPIOx->OTYPER = temp;
 8004b0e:	6045      	str	r5, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8004b10:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8004b12:	ea0a 0a05 	and.w	sl, sl, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8004b16:	688d      	ldr	r5, [r1, #8]
 8004b18:	fa05 f50b 	lsl.w	r5, r5, fp
 8004b1c:	ea45 050a 	orr.w	r5, r5, sl
      GPIOx->PUPDR = temp;
 8004b20:	60c5      	str	r5, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8004b22:	00d5      	lsls	r5, r2, #3
 8004b24:	d555      	bpl.n	8004bd2 <HAL_GPIO_Init+0x166>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004b26:	2500      	movs	r5, #0
 8004b28:	9503      	str	r5, [sp, #12]
 8004b2a:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
 8004b2e:	f445 4580 	orr.w	r5, r5, #16384	; 0x4000
 8004b32:	f8c8 5044 	str.w	r5, [r8, #68]	; 0x44
 8004b36:	f8d8 5044 	ldr.w	r5, [r8, #68]	; 0x44
 8004b3a:	f023 0c03 	bic.w	ip, r3, #3
 8004b3e:	f10c 4c80 	add.w	ip, ip, #1073741824	; 0x40000000
 8004b42:	f405 4580 	and.w	r5, r5, #16384	; 0x4000
 8004b46:	f50c 3c9c 	add.w	ip, ip, #79872	; 0x13800
 8004b4a:	9503      	str	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8004b4c:	f003 0a03 	and.w	sl, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004b50:	9d03      	ldr	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8004b52:	f8dc 5008 	ldr.w	r5, [ip, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8004b56:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8004b5a:	270f      	movs	r7, #15
 8004b5c:	fa07 f70a 	lsl.w	r7, r7, sl
 8004b60:	ea25 0507 	bic.w	r5, r5, r7
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8004b64:	4f1f      	ldr	r7, [pc, #124]	; (8004be4 <HAL_GPIO_Init+0x178>)
 8004b66:	42b8      	cmp	r0, r7
 8004b68:	d00a      	beq.n	8004b80 <HAL_GPIO_Init+0x114>
 8004b6a:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 8004b6e:	42b8      	cmp	r0, r7
 8004b70:	d008      	beq.n	8004b84 <HAL_GPIO_Init+0x118>
 8004b72:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 8004b76:	42b8      	cmp	r0, r7
 8004b78:	bf14      	ite	ne
 8004b7a:	2707      	movne	r7, #7
 8004b7c:	2702      	moveq	r7, #2
 8004b7e:	e002      	b.n	8004b86 <HAL_GPIO_Init+0x11a>
 8004b80:	2700      	movs	r7, #0
 8004b82:	e000      	b.n	8004b86 <HAL_GPIO_Init+0x11a>
 8004b84:	2701      	movs	r7, #1
 8004b86:	fa07 fa0a 	lsl.w	sl, r7, sl
 8004b8a:	ea4a 0505 	orr.w	r5, sl, r5
        SYSCFG->EXTICR[position >> 2U] = temp;
 8004b8e:	f8cc 5008 	str.w	r5, [ip, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8004b92:	6835      	ldr	r5, [r6, #0]
        temp &= ~((uint32_t)iocurrent);
 8004b94:	43e7      	mvns	r7, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8004b96:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8004b9a:	bf0c      	ite	eq
 8004b9c:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8004b9e:	4325      	orrne	r5, r4
        }
        EXTI->IMR = temp;
 8004ba0:	f8ce 5000 	str.w	r5, [lr]

        temp = EXTI->EMR;
 8004ba4:	f8de 5004 	ldr.w	r5, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8004ba8:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 8004bac:	bf0c      	ite	eq
 8004bae:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8004bb0:	4325      	orrne	r5, r4
        }
        EXTI->EMR = temp;
 8004bb2:	6075      	str	r5, [r6, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8004bb4:	68b5      	ldr	r5, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8004bb6:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8004bba:	bf0c      	ite	eq
 8004bbc:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8004bbe:	4325      	orrne	r5, r4
        }
        EXTI->RTSR = temp;
 8004bc0:	f8ce 5008 	str.w	r5, [lr, #8]

        temp = EXTI->FTSR;
 8004bc4:	f8de 500c 	ldr.w	r5, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8004bc8:	0292      	lsls	r2, r2, #10
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 8004bca:	bf54      	ite	pl
 8004bcc:	403d      	andpl	r5, r7
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8004bce:	4325      	orrmi	r5, r4
        }
        EXTI->FTSR = temp;
 8004bd0:	60f5      	str	r5, [r6, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8004bd2:	3301      	adds	r3, #1
 8004bd4:	2b10      	cmp	r3, #16
 8004bd6:	f47f af55 	bne.w	8004a84 <HAL_GPIO_Init+0x18>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8004bda:	b005      	add	sp, #20
 8004bdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004be0:	40013c00 	.word	0x40013c00
 8004be4:	40020000 	.word	0x40020000
 8004be8:	40023800 	.word	0x40023800

08004bec <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8004bec:	b902      	cbnz	r2, 8004bf0 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8004bee:	0409      	lsls	r1, r1, #16
 8004bf0:	6181      	str	r1, [r0, #24]
 8004bf2:	4770      	bx	lr

08004bf4 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8004bf4:	6943      	ldr	r3, [r0, #20]
 8004bf6:	4059      	eors	r1, r3
 8004bf8:	6141      	str	r1, [r0, #20]
 8004bfa:	4770      	bx	lr

08004bfc <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8004bfc:	4913      	ldr	r1, [pc, #76]	; (8004c4c <HAL_RCC_GetSysClockFreq+0x50>)
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004bfe:	b508      	push	{r3, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8004c00:	688b      	ldr	r3, [r1, #8]
 8004c02:	f003 030c 	and.w	r3, r3, #12
 8004c06:	2b04      	cmp	r3, #4
 8004c08:	d01c      	beq.n	8004c44 <HAL_RCC_GetSysClockFreq+0x48>
 8004c0a:	2b08      	cmp	r3, #8
 8004c0c:	d11c      	bne.n	8004c48 <HAL_RCC_GetSysClockFreq+0x4c>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004c0e:	684a      	ldr	r2, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8004c10:	684b      	ldr	r3, [r1, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004c12:	6849      	ldr	r1, [r1, #4]
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8004c14:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004c18:	bf14      	ite	ne
 8004c1a:	480d      	ldrne	r0, [pc, #52]	; (8004c50 <HAL_RCC_GetSysClockFreq+0x54>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004c1c:	480d      	ldreq	r0, [pc, #52]	; (8004c54 <HAL_RCC_GetSysClockFreq+0x58>)
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004c1e:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8004c22:	bf18      	it	ne
 8004c24:	2300      	movne	r3, #0
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004c26:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004c2a:	fba1 0100 	umull	r0, r1, r1, r0
 8004c2e:	f7fb fafd 	bl	800022c <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8004c32:	4b06      	ldr	r3, [pc, #24]	; (8004c4c <HAL_RCC_GetSysClockFreq+0x50>)
 8004c34:	685b      	ldr	r3, [r3, #4]

      sysclockfreq = pllvco/pllp;
 8004c36:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8004c3a:	3301      	adds	r3, #1
 8004c3c:	005b      	lsls	r3, r3, #1
 8004c3e:	fbb0 f0f3 	udiv	r0, r0, r3
 8004c42:	bd08      	pop	{r3, pc}
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8004c44:	4802      	ldr	r0, [pc, #8]	; (8004c50 <HAL_RCC_GetSysClockFreq+0x54>)
 8004c46:	bd08      	pop	{r3, pc}
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8004c48:	4802      	ldr	r0, [pc, #8]	; (8004c54 <HAL_RCC_GetSysClockFreq+0x58>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8004c4a:	bd08      	pop	{r3, pc}
 8004c4c:	40023800 	.word	0x40023800
 8004c50:	007a1200 	.word	0x007a1200
 8004c54:	00f42400 	.word	0x00f42400

08004c58 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8004c58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004c5c:	460d      	mov	r5, r1
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8004c5e:	4604      	mov	r4, r0
 8004c60:	b910      	cbnz	r0, 8004c68 <HAL_RCC_ClockConfig+0x10>
  {
    return HAL_ERROR;
 8004c62:	2001      	movs	r0, #1
 8004c64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8004c68:	4b44      	ldr	r3, [pc, #272]	; (8004d7c <HAL_RCC_ClockConfig+0x124>)
 8004c6a:	681a      	ldr	r2, [r3, #0]
 8004c6c:	f002 020f 	and.w	r2, r2, #15
 8004c70:	428a      	cmp	r2, r1
 8004c72:	d317      	bcc.n	8004ca4 <HAL_RCC_ClockConfig+0x4c>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004c74:	6822      	ldr	r2, [r4, #0]
 8004c76:	0796      	lsls	r6, r2, #30
 8004c78:	d51c      	bpl.n	8004cb4 <HAL_RCC_ClockConfig+0x5c>
 8004c7a:	4b41      	ldr	r3, [pc, #260]	; (8004d80 <HAL_RCC_ClockConfig+0x128>)
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004c7c:	f012 0f04 	tst.w	r2, #4
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8004c80:	bf1e      	ittt	ne
 8004c82:	6899      	ldrne	r1, [r3, #8]
 8004c84:	f441 51e0 	orrne.w	r1, r1, #7168	; 0x1c00
 8004c88:	6099      	strne	r1, [r3, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004c8a:	0710      	lsls	r0, r2, #28
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8004c8c:	bf42      	ittt	mi
 8004c8e:	6899      	ldrmi	r1, [r3, #8]
 8004c90:	f441 4160 	orrmi.w	r1, r1, #57344	; 0xe000
 8004c94:	6099      	strmi	r1, [r3, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8004c96:	6899      	ldr	r1, [r3, #8]
 8004c98:	f021 00f0 	bic.w	r0, r1, #240	; 0xf0
 8004c9c:	68a1      	ldr	r1, [r4, #8]
 8004c9e:	4301      	orrs	r1, r0
 8004ca0:	6099      	str	r1, [r3, #8]
 8004ca2:	e007      	b.n	8004cb4 <HAL_RCC_ClockConfig+0x5c>

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004ca4:	b2ca      	uxtb	r2, r1
 8004ca6:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8004ca8:	681b      	ldr	r3, [r3, #0]
 8004caa:	f003 030f 	and.w	r3, r3, #15
 8004cae:	4299      	cmp	r1, r3
 8004cb0:	d1d7      	bne.n	8004c62 <HAL_RCC_ClockConfig+0xa>
 8004cb2:	e7df      	b.n	8004c74 <HAL_RCC_ClockConfig+0x1c>
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8004cb4:	07d1      	lsls	r1, r2, #31
 8004cb6:	d52c      	bpl.n	8004d12 <HAL_RCC_ClockConfig+0xba>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004cb8:	6863      	ldr	r3, [r4, #4]
 8004cba:	4a31      	ldr	r2, [pc, #196]	; (8004d80 <HAL_RCC_ClockConfig+0x128>)
 8004cbc:	2b01      	cmp	r3, #1
 8004cbe:	d103      	bne.n	8004cc8 <HAL_RCC_ClockConfig+0x70>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004cc0:	6812      	ldr	r2, [r2, #0]
 8004cc2:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8004cc6:	e008      	b.n	8004cda <HAL_RCC_ClockConfig+0x82>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004cc8:	1e99      	subs	r1, r3, #2
 8004cca:	2901      	cmp	r1, #1
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004ccc:	6812      	ldr	r2, [r2, #0]
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004cce:	d802      	bhi.n	8004cd6 <HAL_RCC_ClockConfig+0x7e>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004cd0:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8004cd4:	e001      	b.n	8004cda <HAL_RCC_ClockConfig+0x82>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004cd6:	f012 0f02 	tst.w	r2, #2
 8004cda:	d0c2      	beq.n	8004c62 <HAL_RCC_ClockConfig+0xa>
      {
        return HAL_ERROR;
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004cdc:	4e28      	ldr	r6, [pc, #160]	; (8004d80 <HAL_RCC_ClockConfig+0x128>)
 8004cde:	68b2      	ldr	r2, [r6, #8]
 8004ce0:	f022 0203 	bic.w	r2, r2, #3
 8004ce4:	4313      	orrs	r3, r2
 8004ce6:	60b3      	str	r3, [r6, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8004ce8:	f7ff f99e 	bl	8004028 <HAL_GetTick>

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004cec:	f241 3788 	movw	r7, #5000	; 0x1388
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8004cf0:	4680      	mov	r8, r0

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004cf2:	68b3      	ldr	r3, [r6, #8]
 8004cf4:	6862      	ldr	r2, [r4, #4]
 8004cf6:	f003 030c 	and.w	r3, r3, #12
 8004cfa:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8004cfe:	d008      	beq.n	8004d12 <HAL_RCC_ClockConfig+0xba>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004d00:	f7ff f992 	bl	8004028 <HAL_GetTick>
 8004d04:	ebc8 0000 	rsb	r0, r8, r0
 8004d08:	42b8      	cmp	r0, r7
 8004d0a:	d9f2      	bls.n	8004cf2 <HAL_RCC_ClockConfig+0x9a>
      {
        return HAL_TIMEOUT;
 8004d0c:	2003      	movs	r0, #3

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (TICK_INT_PRIORITY);

  return HAL_OK;
}
 8004d0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8004d12:	4b1a      	ldr	r3, [pc, #104]	; (8004d7c <HAL_RCC_ClockConfig+0x124>)
 8004d14:	681a      	ldr	r2, [r3, #0]
 8004d16:	f002 020f 	and.w	r2, r2, #15
 8004d1a:	4295      	cmp	r5, r2
 8004d1c:	d30a      	bcc.n	8004d34 <HAL_RCC_ClockConfig+0xdc>
      return HAL_ERROR;
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004d1e:	6821      	ldr	r1, [r4, #0]
 8004d20:	074a      	lsls	r2, r1, #29
 8004d22:	d50f      	bpl.n	8004d44 <HAL_RCC_ClockConfig+0xec>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8004d24:	4816      	ldr	r0, [pc, #88]	; (8004d80 <HAL_RCC_ClockConfig+0x128>)
 8004d26:	6883      	ldr	r3, [r0, #8]
 8004d28:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8004d2c:	68e3      	ldr	r3, [r4, #12]
 8004d2e:	4313      	orrs	r3, r2
 8004d30:	6083      	str	r3, [r0, #8]
 8004d32:	e007      	b.n	8004d44 <HAL_RCC_ClockConfig+0xec>

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004d34:	b2ea      	uxtb	r2, r5
 8004d36:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8004d38:	681b      	ldr	r3, [r3, #0]
 8004d3a:	f003 030f 	and.w	r3, r3, #15
 8004d3e:	429d      	cmp	r5, r3
 8004d40:	d18f      	bne.n	8004c62 <HAL_RCC_ClockConfig+0xa>
 8004d42:	e7ec      	b.n	8004d1e <HAL_RCC_ClockConfig+0xc6>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004d44:	070b      	lsls	r3, r1, #28
 8004d46:	d507      	bpl.n	8004d58 <HAL_RCC_ClockConfig+0x100>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8004d48:	4a0d      	ldr	r2, [pc, #52]	; (8004d80 <HAL_RCC_ClockConfig+0x128>)
 8004d4a:	6921      	ldr	r1, [r4, #16]
 8004d4c:	6893      	ldr	r3, [r2, #8]
 8004d4e:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8004d52:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8004d56:	6093      	str	r3, [r2, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8004d58:	f7ff ff50 	bl	8004bfc <HAL_RCC_GetSysClockFreq>
 8004d5c:	4b08      	ldr	r3, [pc, #32]	; (8004d80 <HAL_RCC_ClockConfig+0x128>)
 8004d5e:	4a09      	ldr	r2, [pc, #36]	; (8004d84 <HAL_RCC_ClockConfig+0x12c>)
 8004d60:	689b      	ldr	r3, [r3, #8]
 8004d62:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8004d66:	5cd3      	ldrb	r3, [r2, r3]
 8004d68:	40d8      	lsrs	r0, r3
 8004d6a:	4b07      	ldr	r3, [pc, #28]	; (8004d88 <HAL_RCC_ClockConfig+0x130>)
 8004d6c:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (TICK_INT_PRIORITY);
 8004d6e:	2000      	movs	r0, #0
 8004d70:	f7ff f924 	bl	8003fbc <HAL_InitTick>

  return HAL_OK;
 8004d74:	2000      	movs	r0, #0
 8004d76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004d7a:	bf00      	nop
 8004d7c:	40023c00 	.word	0x40023c00
 8004d80:	40023800 	.word	0x40023800
 8004d84:	080091c4 	.word	0x080091c4
 8004d88:	20000004 	.word	0x20000004

08004d8c <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8004d8c:	4b01      	ldr	r3, [pc, #4]	; (8004d94 <HAL_RCC_GetHCLKFreq+0x8>)
 8004d8e:	6818      	ldr	r0, [r3, #0]
 8004d90:	4770      	bx	lr
 8004d92:	bf00      	nop
 8004d94:	20000004 	.word	0x20000004

08004d98 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8004d98:	4b04      	ldr	r3, [pc, #16]	; (8004dac <HAL_RCC_GetPCLK1Freq+0x14>)
 8004d9a:	4a05      	ldr	r2, [pc, #20]	; (8004db0 <HAL_RCC_GetPCLK1Freq+0x18>)
 8004d9c:	689b      	ldr	r3, [r3, #8]
 8004d9e:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8004da2:	5cd3      	ldrb	r3, [r2, r3]
 8004da4:	4a03      	ldr	r2, [pc, #12]	; (8004db4 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8004da6:	6810      	ldr	r0, [r2, #0]
}
 8004da8:	40d8      	lsrs	r0, r3
 8004daa:	4770      	bx	lr
 8004dac:	40023800 	.word	0x40023800
 8004db0:	080091d4 	.word	0x080091d4
 8004db4:	20000004 	.word	0x20000004

08004db8 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8004db8:	4b04      	ldr	r3, [pc, #16]	; (8004dcc <HAL_RCC_GetPCLK2Freq+0x14>)
 8004dba:	4a05      	ldr	r2, [pc, #20]	; (8004dd0 <HAL_RCC_GetPCLK2Freq+0x18>)
 8004dbc:	689b      	ldr	r3, [r3, #8]
 8004dbe:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8004dc2:	5cd3      	ldrb	r3, [r2, r3]
 8004dc4:	4a03      	ldr	r2, [pc, #12]	; (8004dd4 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8004dc6:	6810      	ldr	r0, [r2, #0]
}
 8004dc8:	40d8      	lsrs	r0, r3
 8004dca:	4770      	bx	lr
 8004dcc:	40023800 	.word	0x40023800
 8004dd0:	080091d4 	.word	0x080091d4
 8004dd4:	20000004 	.word	0x20000004

08004dd8 <HAL_RCC_OscConfig>:
  uint32_t tickstart = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004dd8:	6803      	ldr	r3, [r0, #0]
  * @note   This function add the PLL/PLLR factor management during PLL configuration this feature
  *         is only available in STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx devices
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8004dda:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t tickstart = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004dde:	07d9      	lsls	r1, r3, #31
  * @note   This function add the PLL/PLLR factor management during PLL configuration this feature
  *         is only available in STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx/STM32F412Zx/STM32F412Vx/STM32F412Rx/STM32F412Cx devices
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8004de0:	4604      	mov	r4, r0
  uint32_t tickstart = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004de2:	d517      	bpl.n	8004e14 <HAL_RCC_OscConfig+0x3c>
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 8004de4:	4ba2      	ldr	r3, [pc, #648]	; (8005070 <HAL_RCC_OscConfig+0x298>)
 8004de6:	689a      	ldr	r2, [r3, #8]
 8004de8:	f002 020c 	and.w	r2, r2, #12
 8004dec:	2a04      	cmp	r2, #4
 8004dee:	d009      	beq.n	8004e04 <HAL_RCC_OscConfig+0x2c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8004df0:	689a      	ldr	r2, [r3, #8]
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 8004df2:	f002 020c 	and.w	r2, r2, #12
 8004df6:	2a08      	cmp	r2, #8
 8004df8:	f040 80f9 	bne.w	8004fee <HAL_RCC_OscConfig+0x216>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8004dfc:	685a      	ldr	r2, [r3, #4]
 8004dfe:	0252      	lsls	r2, r2, #9
 8004e00:	f140 80f5 	bpl.w	8004fee <HAL_RCC_OscConfig+0x216>
#endif /* STM32F446xx */
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8004e04:	4b9a      	ldr	r3, [pc, #616]	; (8005070 <HAL_RCC_OscConfig+0x298>)
 8004e06:	681b      	ldr	r3, [r3, #0]
 8004e08:	0399      	lsls	r1, r3, #14
 8004e0a:	d503      	bpl.n	8004e14 <HAL_RCC_OscConfig+0x3c>
 8004e0c:	6863      	ldr	r3, [r4, #4]
 8004e0e:	2b00      	cmp	r3, #0
 8004e10:	f000 80ac 	beq.w	8004f6c <HAL_RCC_OscConfig+0x194>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8004e14:	6823      	ldr	r3, [r4, #0]
 8004e16:	079e      	lsls	r6, r3, #30
 8004e18:	d525      	bpl.n	8004e66 <HAL_RCC_OscConfig+0x8e>
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 8004e1a:	4b95      	ldr	r3, [pc, #596]	; (8005070 <HAL_RCC_OscConfig+0x298>)
 8004e1c:	689a      	ldr	r2, [r3, #8]
 8004e1e:	f012 0f0c 	tst.w	r2, #12
 8004e22:	f000 813e 	beq.w	80050a2 <HAL_RCC_OscConfig+0x2ca>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8004e26:	689a      	ldr	r2, [r3, #8]
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 8004e28:	f002 020c 	and.w	r2, r2, #12
 8004e2c:	2a08      	cmp	r2, #8
 8004e2e:	d103      	bne.n	8004e38 <HAL_RCC_OscConfig+0x60>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8004e30:	685b      	ldr	r3, [r3, #4]
 8004e32:	025d      	lsls	r5, r3, #9
 8004e34:	f140 8135 	bpl.w	80050a2 <HAL_RCC_OscConfig+0x2ca>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8004e38:	68e3      	ldr	r3, [r4, #12]
 8004e3a:	4a8e      	ldr	r2, [pc, #568]	; (8005074 <HAL_RCC_OscConfig+0x29c>)
 8004e3c:	2b00      	cmp	r3, #0
 8004e3e:	f000 8121 	beq.w	8005084 <HAL_RCC_OscConfig+0x2ac>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8004e42:	2301      	movs	r3, #1
 8004e44:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004e46:	f7ff f8ef 	bl	8004028 <HAL_GetTick>

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004e4a:	4e89      	ldr	r6, [pc, #548]	; (8005070 <HAL_RCC_OscConfig+0x298>)
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004e4c:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004e4e:	6833      	ldr	r3, [r6, #0]
 8004e50:	4a87      	ldr	r2, [pc, #540]	; (8005070 <HAL_RCC_OscConfig+0x298>)
 8004e52:	0798      	lsls	r0, r3, #30
 8004e54:	f140 8104 	bpl.w	8005060 <HAL_RCC_OscConfig+0x288>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004e58:	6813      	ldr	r3, [r2, #0]
 8004e5a:	6921      	ldr	r1, [r4, #16]
 8004e5c:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8004e60:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8004e64:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004e66:	6823      	ldr	r3, [r4, #0]
 8004e68:	071a      	lsls	r2, r3, #28
 8004e6a:	d520      	bpl.n	8004eae <HAL_RCC_OscConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8004e6c:	6962      	ldr	r2, [r4, #20]
 8004e6e:	4b82      	ldr	r3, [pc, #520]	; (8005078 <HAL_RCC_OscConfig+0x2a0>)
 8004e70:	b17a      	cbz	r2, 8004e92 <HAL_RCC_OscConfig+0xba>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8004e72:	2201      	movs	r2, #1
 8004e74:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004e76:	f7ff f8d7 	bl	8004028 <HAL_GetTick>

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8004e7a:	4e7d      	ldr	r6, [pc, #500]	; (8005070 <HAL_RCC_OscConfig+0x298>)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004e7c:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8004e7e:	6f73      	ldr	r3, [r6, #116]	; 0x74
 8004e80:	079b      	lsls	r3, r3, #30
 8004e82:	d414      	bmi.n	8004eae <HAL_RCC_OscConfig+0xd6>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8004e84:	f7ff f8d0 	bl	8004028 <HAL_GetTick>
 8004e88:	1b40      	subs	r0, r0, r5
 8004e8a:	2802      	cmp	r0, #2
 8004e8c:	d9f7      	bls.n	8004e7e <HAL_RCC_OscConfig+0xa6>
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8004e8e:	2003      	movs	r0, #3
 8004e90:	e117      	b.n	80050c2 <HAL_RCC_OscConfig+0x2ea>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8004e92:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004e94:	f7ff f8c8 	bl	8004028 <HAL_GetTick>

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8004e98:	4e75      	ldr	r6, [pc, #468]	; (8005070 <HAL_RCC_OscConfig+0x298>)
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004e9a:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8004e9c:	6f73      	ldr	r3, [r6, #116]	; 0x74
 8004e9e:	079f      	lsls	r7, r3, #30
 8004ea0:	d505      	bpl.n	8004eae <HAL_RCC_OscConfig+0xd6>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8004ea2:	f7ff f8c1 	bl	8004028 <HAL_GetTick>
 8004ea6:	1b40      	subs	r0, r0, r5
 8004ea8:	2802      	cmp	r0, #2
 8004eaa:	d9f7      	bls.n	8004e9c <HAL_RCC_OscConfig+0xc4>
 8004eac:	e7ef      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004eae:	6823      	ldr	r3, [r4, #0]
 8004eb0:	075d      	lsls	r5, r3, #29
 8004eb2:	d551      	bpl.n	8004f58 <HAL_RCC_OscConfig+0x180>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8004eb4:	2300      	movs	r3, #0
 8004eb6:	9301      	str	r3, [sp, #4]
 8004eb8:	4b6d      	ldr	r3, [pc, #436]	; (8005070 <HAL_RCC_OscConfig+0x298>)

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8004eba:	4d70      	ldr	r5, [pc, #448]	; (800507c <HAL_RCC_OscConfig+0x2a4>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8004ebc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004ebe:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8004ec2:	641a      	str	r2, [r3, #64]	; 0x40
 8004ec4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004ec6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004eca:	9301      	str	r3, [sp, #4]
 8004ecc:	9b01      	ldr	r3, [sp, #4]

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8004ece:	682b      	ldr	r3, [r5, #0]
 8004ed0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004ed4:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8004ed6:	f7ff f8a7 	bl	8004028 <HAL_GetTick>
 8004eda:	4606      	mov	r6, r0

    while((PWR->CR & PWR_CR_DBP) == RESET)
 8004edc:	682b      	ldr	r3, [r5, #0]
 8004ede:	05d8      	lsls	r0, r3, #23
 8004ee0:	d405      	bmi.n	8004eee <HAL_RCC_OscConfig+0x116>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8004ee2:	f7ff f8a1 	bl	8004028 <HAL_GetTick>
 8004ee6:	1b80      	subs	r0, r0, r6
 8004ee8:	2802      	cmp	r0, #2
 8004eea:	d9f7      	bls.n	8004edc <HAL_RCC_OscConfig+0x104>
 8004eec:	e7cf      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004eee:	68a3      	ldr	r3, [r4, #8]
 8004ef0:	4d5f      	ldr	r5, [pc, #380]	; (8005070 <HAL_RCC_OscConfig+0x298>)
 8004ef2:	2b01      	cmp	r3, #1
 8004ef4:	d005      	beq.n	8004f02 <HAL_RCC_OscConfig+0x12a>
 8004ef6:	2b05      	cmp	r3, #5
 8004ef8:	d108      	bne.n	8004f0c <HAL_RCC_OscConfig+0x134>
 8004efa:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8004efc:	f043 0304 	orr.w	r3, r3, #4
 8004f00:	672b      	str	r3, [r5, #112]	; 0x70
 8004f02:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8004f04:	f043 0301 	orr.w	r3, r3, #1
 8004f08:	672b      	str	r3, [r5, #112]	; 0x70
 8004f0a:	e008      	b.n	8004f1e <HAL_RCC_OscConfig+0x146>
 8004f0c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8004f0e:	f022 0201 	bic.w	r2, r2, #1
 8004f12:	672a      	str	r2, [r5, #112]	; 0x70
 8004f14:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8004f16:	f022 0204 	bic.w	r2, r2, #4
 8004f1a:	672a      	str	r2, [r5, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8004f1c:	b173      	cbz	r3, 8004f3c <HAL_RCC_OscConfig+0x164>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004f1e:	f7ff f883 	bl	8004028 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004f22:	4f53      	ldr	r7, [pc, #332]	; (8005070 <HAL_RCC_OscConfig+0x298>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004f24:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004f26:	f241 3588 	movw	r5, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004f2a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8004f2c:	0799      	lsls	r1, r3, #30
 8004f2e:	d413      	bmi.n	8004f58 <HAL_RCC_OscConfig+0x180>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004f30:	f7ff f87a 	bl	8004028 <HAL_GetTick>
 8004f34:	1b80      	subs	r0, r0, r6
 8004f36:	42a8      	cmp	r0, r5
 8004f38:	d9f7      	bls.n	8004f2a <HAL_RCC_OscConfig+0x152>
 8004f3a:	e7a8      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004f3c:	f7ff f874 	bl	8004028 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004f40:	f241 3688 	movw	r6, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004f44:	4607      	mov	r7, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8004f46:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8004f48:	079a      	lsls	r2, r3, #30
 8004f4a:	d505      	bpl.n	8004f58 <HAL_RCC_OscConfig+0x180>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004f4c:	f7ff f86c 	bl	8004028 <HAL_GetTick>
 8004f50:	1bc0      	subs	r0, r0, r7
 8004f52:	42b0      	cmp	r0, r6
 8004f54:	d9f7      	bls.n	8004f46 <HAL_RCC_OscConfig+0x16e>
 8004f56:	e79a      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8004f58:	69a2      	ldr	r2, [r4, #24]
 8004f5a:	b90a      	cbnz	r2, 8004f60 <HAL_RCC_OscConfig+0x188>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8004f5c:	2000      	movs	r0, #0
 8004f5e:	e0b0      	b.n	80050c2 <HAL_RCC_OscConfig+0x2ea>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8004f60:	4d43      	ldr	r5, [pc, #268]	; (8005070 <HAL_RCC_OscConfig+0x298>)
 8004f62:	68ab      	ldr	r3, [r5, #8]
 8004f64:	f003 030c 	and.w	r3, r3, #12
 8004f68:	2b08      	cmp	r3, #8
 8004f6a:	d101      	bne.n	8004f70 <HAL_RCC_OscConfig+0x198>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
#endif /* STM32F446xx */
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
      {
        return HAL_ERROR;
 8004f6c:	2001      	movs	r0, #1
 8004f6e:	e0a8      	b.n	80050c2 <HAL_RCC_OscConfig+0x2ea>
 8004f70:	4e43      	ldr	r6, [pc, #268]	; (8005080 <HAL_RCC_OscConfig+0x2a8>)
 8004f72:	2300      	movs	r3, #0
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8004f74:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8004f76:	6033      	str	r3, [r6, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8004f78:	d12d      	bne.n	8004fd6 <HAL_RCC_OscConfig+0x1fe>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004f7a:	f7ff f855 	bl	8004028 <HAL_GetTick>
 8004f7e:	4680      	mov	r8, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004f80:	682b      	ldr	r3, [r5, #0]
 8004f82:	4f3b      	ldr	r7, [pc, #236]	; (8005070 <HAL_RCC_OscConfig+0x298>)
 8004f84:	019b      	lsls	r3, r3, #6
 8004f86:	d506      	bpl.n	8004f96 <HAL_RCC_OscConfig+0x1be>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8004f88:	f7ff f84e 	bl	8004028 <HAL_GetTick>
 8004f8c:	ebc8 0000 	rsb	r0, r8, r0
 8004f90:	2802      	cmp	r0, #2
 8004f92:	d9f5      	bls.n	8004f80 <HAL_RCC_OscConfig+0x1a8>
 8004f94:	e77b      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8004f96:	69e2      	ldr	r2, [r4, #28]
 8004f98:	6a23      	ldr	r3, [r4, #32]
 8004f9a:	4313      	orrs	r3, r2
 8004f9c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004f9e:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8004fa2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8004fa4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8004fa8:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004faa:	ea43 7202 	orr.w	r2, r3, r2, lsl #28
 8004fae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004fb0:	085b      	lsrs	r3, r3, #1
 8004fb2:	3b01      	subs	r3, #1
 8004fb4:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
                             RCC_OscInitStruct->PLL.PLLM,
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);
 8004fb8:	607b      	str	r3, [r7, #4]

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8004fba:	2301      	movs	r3, #1
 8004fbc:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004fbe:	f7ff f833 	bl	8004028 <HAL_GetTick>
 8004fc2:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004fc4:	683b      	ldr	r3, [r7, #0]
 8004fc6:	019d      	lsls	r5, r3, #6
 8004fc8:	d4c8      	bmi.n	8004f5c <HAL_RCC_OscConfig+0x184>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8004fca:	f7ff f82d 	bl	8004028 <HAL_GetTick>
 8004fce:	1b00      	subs	r0, r0, r4
 8004fd0:	2802      	cmp	r0, #2
 8004fd2:	d9f7      	bls.n	8004fc4 <HAL_RCC_OscConfig+0x1ec>
 8004fd4:	e75b      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004fd6:	f7ff f827 	bl	8004028 <HAL_GetTick>
 8004fda:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004fdc:	682b      	ldr	r3, [r5, #0]
 8004fde:	0198      	lsls	r0, r3, #6
 8004fe0:	d5bc      	bpl.n	8004f5c <HAL_RCC_OscConfig+0x184>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8004fe2:	f7ff f821 	bl	8004028 <HAL_GetTick>
 8004fe6:	1b00      	subs	r0, r0, r4
 8004fe8:	2802      	cmp	r0, #2
 8004fea:	d9f7      	bls.n	8004fdc <HAL_RCC_OscConfig+0x204>
 8004fec:	e74f      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004fee:	6862      	ldr	r2, [r4, #4]
 8004ff0:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8004ff4:	d104      	bne.n	8005000 <HAL_RCC_OscConfig+0x228>
 8004ff6:	681a      	ldr	r2, [r3, #0]
 8004ff8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004ffc:	601a      	str	r2, [r3, #0]
 8004ffe:	e014      	b.n	800502a <HAL_RCC_OscConfig+0x252>
 8005000:	4d1b      	ldr	r5, [pc, #108]	; (8005070 <HAL_RCC_OscConfig+0x298>)
 8005002:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
 8005006:	682b      	ldr	r3, [r5, #0]
 8005008:	d107      	bne.n	800501a <HAL_RCC_OscConfig+0x242>
 800500a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800500e:	602b      	str	r3, [r5, #0]
 8005010:	682b      	ldr	r3, [r5, #0]
 8005012:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8005016:	602b      	str	r3, [r5, #0]
 8005018:	e007      	b.n	800502a <HAL_RCC_OscConfig+0x252>
 800501a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800501e:	602b      	str	r3, [r5, #0]
 8005020:	682b      	ldr	r3, [r5, #0]
 8005022:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8005026:	602b      	str	r3, [r5, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8005028:	b16a      	cbz	r2, 8005046 <HAL_RCC_OscConfig+0x26e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800502a:	f7fe fffd 	bl	8004028 <HAL_GetTick>

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800502e:	4e10      	ldr	r6, [pc, #64]	; (8005070 <HAL_RCC_OscConfig+0x298>)

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005030:	4605      	mov	r5, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8005032:	6833      	ldr	r3, [r6, #0]
 8005034:	039b      	lsls	r3, r3, #14
 8005036:	f53f aeed 	bmi.w	8004e14 <HAL_RCC_OscConfig+0x3c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800503a:	f7fe fff5 	bl	8004028 <HAL_GetTick>
 800503e:	1b40      	subs	r0, r0, r5
 8005040:	2864      	cmp	r0, #100	; 0x64
 8005042:	d9f6      	bls.n	8005032 <HAL_RCC_OscConfig+0x25a>
 8005044:	e723      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005046:	f7fe ffef 	bl	8004028 <HAL_GetTick>
 800504a:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800504c:	682b      	ldr	r3, [r5, #0]
 800504e:	039f      	lsls	r7, r3, #14
 8005050:	f57f aee0 	bpl.w	8004e14 <HAL_RCC_OscConfig+0x3c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8005054:	f7fe ffe8 	bl	8004028 <HAL_GetTick>
 8005058:	1b80      	subs	r0, r0, r6
 800505a:	2864      	cmp	r0, #100	; 0x64
 800505c:	d9f6      	bls.n	800504c <HAL_RCC_OscConfig+0x274>
 800505e:	e716      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8005060:	f7fe ffe2 	bl	8004028 <HAL_GetTick>
 8005064:	1b40      	subs	r0, r0, r5
 8005066:	2802      	cmp	r0, #2
 8005068:	f67f aef1 	bls.w	8004e4e <HAL_RCC_OscConfig+0x76>
 800506c:	e70f      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
 800506e:	bf00      	nop
 8005070:	40023800 	.word	0x40023800
 8005074:	42470000 	.word	0x42470000
 8005078:	42470e80 	.word	0x42470e80
 800507c:	40007000 	.word	0x40007000
 8005080:	42470060 	.word	0x42470060
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8005084:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8005086:	f7fe ffcf 	bl	8004028 <HAL_GetTick>

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800508a:	4e0f      	ldr	r6, [pc, #60]	; (80050c8 <HAL_RCC_OscConfig+0x2f0>)
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800508c:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800508e:	6833      	ldr	r3, [r6, #0]
 8005090:	0799      	lsls	r1, r3, #30
 8005092:	f57f aee8 	bpl.w	8004e66 <HAL_RCC_OscConfig+0x8e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8005096:	f7fe ffc7 	bl	8004028 <HAL_GetTick>
 800509a:	1b40      	subs	r0, r0, r5
 800509c:	2802      	cmp	r0, #2
 800509e:	d9f6      	bls.n	800508e <HAL_RCC_OscConfig+0x2b6>
 80050a0:	e6f5      	b.n	8004e8e <HAL_RCC_OscConfig+0xb6>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
#endif /* STM32F446xx */
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80050a2:	4b09      	ldr	r3, [pc, #36]	; (80050c8 <HAL_RCC_OscConfig+0x2f0>)
 80050a4:	681a      	ldr	r2, [r3, #0]
 80050a6:	0792      	lsls	r2, r2, #30
 80050a8:	d503      	bpl.n	80050b2 <HAL_RCC_OscConfig+0x2da>
 80050aa:	68e2      	ldr	r2, [r4, #12]
 80050ac:	2a01      	cmp	r2, #1
 80050ae:	f47f af5d 	bne.w	8004f6c <HAL_RCC_OscConfig+0x194>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80050b2:	681a      	ldr	r2, [r3, #0]
 80050b4:	6921      	ldr	r1, [r4, #16]
 80050b6:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80050ba:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 80050be:	601a      	str	r2, [r3, #0]
 80050c0:	e6d1      	b.n	8004e66 <HAL_RCC_OscConfig+0x8e>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 80050c2:	b002      	add	sp, #8
 80050c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80050c8:	40023800 	.word	0x40023800

080050cc <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm>:
  * @param Timeout Timeout duration
  * @param Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout, uint32_t Tickstart)
{
 80050cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80050d0:	9f06      	ldr	r7, [sp, #24]
 80050d2:	4604      	mov	r4, r0
 80050d4:	460e      	mov	r6, r1
 80050d6:	4690      	mov	r8, r2
 80050d8:	461d      	mov	r5, r3
  while((((hspi->Instance->SR & Flag) == (Flag)) ? SET : RESET) != State)
 80050da:	6823      	ldr	r3, [r4, #0]
 80050dc:	689a      	ldr	r2, [r3, #8]
 80050de:	ea36 0202 	bics.w	r2, r6, r2
 80050e2:	bf0c      	ite	eq
 80050e4:	2201      	moveq	r2, #1
 80050e6:	2200      	movne	r2, #0
 80050e8:	4590      	cmp	r8, r2
 80050ea:	d008      	beq.n	80050fe <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0x32>
  {
    if(Timeout != HAL_MAX_DELAY)
 80050ec:	1c6a      	adds	r2, r5, #1
 80050ee:	d0f5      	beq.n	80050dc <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0x10>
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
 80050f0:	b145      	cbz	r5, 8005104 <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0x38>
 80050f2:	f7fe ff99 	bl	8004028 <HAL_GetTick>
 80050f6:	1bc0      	subs	r0, r0, r7
 80050f8:	4285      	cmp	r5, r0
 80050fa:	d903      	bls.n	8005104 <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0x38>
 80050fc:	e7ed      	b.n	80050da <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0xe>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 80050fe:	2000      	movs	r0, #0
 8005100:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8005104:	6823      	ldr	r3, [r4, #0]
 8005106:	685a      	ldr	r2, [r3, #4]
 8005108:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 800510c:	605a      	str	r2, [r3, #4]

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800510e:	6862      	ldr	r2, [r4, #4]
 8005110:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 8005114:	d10a      	bne.n	800512c <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0x60>
 8005116:	68a2      	ldr	r2, [r4, #8]
 8005118:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 800511c:	d002      	beq.n	8005124 <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0x58>
 800511e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8005122:	d103      	bne.n	800512c <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0x60>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8005124:	681a      	ldr	r2, [r3, #0]
 8005126:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800512a:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800512c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800512e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8005132:	d108      	bne.n	8005146 <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm+0x7a>
        {
          SPI_RESET_CRC(hspi);
 8005134:	6819      	ldr	r1, [r3, #0]
 8005136:	f64d 72ff 	movw	r2, #57343	; 0xdfff
 800513a:	400a      	ands	r2, r1
 800513c:	601a      	str	r2, [r3, #0]
 800513e:	681a      	ldr	r2, [r3, #0]
 8005140:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8005144:	601a      	str	r2, [r3, #0]
        }

        hspi->State= HAL_SPI_STATE_READY;
 8005146:	2301      	movs	r3, #1
 8005148:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 800514c:	2300      	movs	r3, #0
 800514e:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
 8005152:	2003      	movs	r0, #3
 8005154:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005158 <_ZL17SPI_CheckFlag_BSYP19__SPI_HandleTypeDefmm>:
  * @param Timeout Timeout duration
  * @param Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8005158:	b513      	push	{r0, r1, r4, lr}
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800515a:	460b      	mov	r3, r1
 800515c:	9200      	str	r2, [sp, #0]
 800515e:	2180      	movs	r1, #128	; 0x80
 8005160:	2200      	movs	r2, #0
  * @param Timeout Timeout duration
  * @param Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8005162:	4604      	mov	r4, r0
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8005164:	f7ff ffb2 	bl	80050cc <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm>
 8005168:	b120      	cbz	r0, 8005174 <_ZL17SPI_CheckFlag_BSYP19__SPI_HandleTypeDefmm+0x1c>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800516a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800516c:	f043 0320 	orr.w	r3, r3, #32
 8005170:	6563      	str	r3, [r4, #84]	; 0x54
    return HAL_TIMEOUT;
 8005172:	2003      	movs	r0, #3
  }
  return HAL_OK;
}
 8005174:	b002      	add	sp, #8
 8005176:	bd10      	pop	{r4, pc}

08005178 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8005178:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 800517a:	4604      	mov	r4, r0
 800517c:	2800      	cmp	r0, #0
 800517e:	d036      	beq.n	80051ee <HAL_SPI_Init+0x76>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005180:	2300      	movs	r3, #0
 8005182:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if(hspi->State == HAL_SPI_STATE_RESET)
 8005184:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 8005188:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800518c:	b91b      	cbnz	r3, 8005196 <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800518e:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8005192:	f7fe f8c5 	bl	8003320 <HAL_SPI_MspInit>
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8005196:	68a1      	ldr	r1, [r4, #8]
 8005198:	6860      	ldr	r0, [r4, #4]
 800519a:	4308      	orrs	r0, r1
 800519c:	68e1      	ldr	r1, [r4, #12]
 800519e:	4308      	orrs	r0, r1
 80051a0:	6921      	ldr	r1, [r4, #16]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80051a2:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80051a4:	4308      	orrs	r0, r1
 80051a6:	6961      	ldr	r1, [r4, #20]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80051a8:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80051ac:	6823      	ldr	r3, [r4, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80051ae:	4308      	orrs	r0, r1
 80051b0:	69e1      	ldr	r1, [r4, #28]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80051b2:	681a      	ldr	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80051b4:	4308      	orrs	r0, r1
 80051b6:	6a21      	ldr	r1, [r4, #32]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80051b8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80051bc:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80051be:	4308      	orrs	r0, r1
 80051c0:	69a2      	ldr	r2, [r4, #24]
 80051c2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80051c4:	4308      	orrs	r0, r1
 80051c6:	f402 7100 	and.w	r1, r2, #512	; 0x200
 80051ca:	4301      	orrs	r1, r0
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );
 80051cc:	6019      	str	r1, [r3, #0]

  /* Configure : NSS management */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80051ce:	0c12      	lsrs	r2, r2, #16
 80051d0:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80051d2:	f002 0204 	and.w	r2, r2, #4
 80051d6:	430a      	orrs	r2, r1
 80051d8:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80051da:	69da      	ldr	r2, [r3, #28]
 80051dc:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80051e0:	61da      	str	r2, [r3, #28]
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80051e2:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 80051e4:	2301      	movs	r3, #1
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80051e6:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80051e8:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  return HAL_OK;
 80051ec:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 80051ee:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;

  return HAL_OK;
}
 80051f0:	bd10      	pop	{r4, pc}

080051f2 <HAL_SPI_Transmit>:
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80051f2:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80051f6:	461e      	mov	r6, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 80051f8:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 80051fc:	2b01      	cmp	r3, #1
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80051fe:	4604      	mov	r4, r0
 8005200:	460d      	mov	r5, r1
 8005202:	4690      	mov	r8, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8005204:	f000 808a 	beq.w	800531c <HAL_SPI_Transmit+0x12a>
 8005208:	2301      	movs	r3, #1
 800520a:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800520e:	f7fe ff0b 	bl	8004028 <HAL_GetTick>
 8005212:	4607      	mov	r7, r0

  if(hspi->State != HAL_SPI_STATE_READY)
 8005214:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
 8005218:	b2c0      	uxtb	r0, r0
 800521a:	2801      	cmp	r0, #1
 800521c:	d176      	bne.n	800530c <HAL_SPI_Transmit+0x11a>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pData == NULL ) || (Size == 0))
 800521e:	2d00      	cmp	r5, #0
 8005220:	d075      	beq.n	800530e <HAL_SPI_Transmit+0x11c>
 8005222:	f1b8 0f00 	cmp.w	r8, #0
 8005226:	d072      	beq.n	800530e <HAL_SPI_Transmit+0x11c>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8005228:	2303      	movs	r3, #3
 800522a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800522e:	2300      	movs	r3, #0
 8005230:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8005232:	63a3      	str	r3, [r4, #56]	; 0x38
  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
 8005234:	f8a4 8036 	strh.w	r8, [r4, #54]	; 0x36

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0U;
 8005238:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 800523a:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->TxISR       = NULL;
 800523c:	6463      	str	r3, [r4, #68]	; 0x44
  hspi->RxISR       = NULL;
 800523e:	6423      	str	r3, [r4, #64]	; 0x40

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8005240:	68a3      	ldr	r3, [r4, #8]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8005242:	6325      	str	r5, [r4, #48]	; 0x30
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8005244:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8005248:	6823      	ldr	r3, [r4, #0]

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
 800524a:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 800524e:	bf02      	ittt	eq
 8005250:	681a      	ldreq	r2, [r3, #0]
 8005252:	f442 4280 	orreq.w	r2, r2, #16384	; 0x4000
 8005256:	601a      	streq	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8005258:	681a      	ldr	r2, [r3, #0]
 800525a:	0652      	lsls	r2, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 800525c:	bf5e      	ittt	pl
 800525e:	681a      	ldrpl	r2, [r3, #0]
 8005260:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 8005264:	601a      	strpl	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8005266:	68e2      	ldr	r2, [r4, #12]
 8005268:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800526c:	6862      	ldr	r2, [r4, #4]
 800526e:	d116      	bne.n	800529e <HAL_SPI_Transmit+0xac>
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
 8005270:	2a00      	cmp	r2, #0
 8005272:	d055      	beq.n	8005320 <HAL_SPI_Transmit+0x12e>
 8005274:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8005276:	b292      	uxth	r2, r2
 8005278:	2a01      	cmp	r2, #1
 800527a:	d051      	beq.n	8005320 <HAL_SPI_Transmit+0x12e>
      hspi->Instance->DR = *((uint16_t *)pData);
      pData += sizeof(uint16_t);
      hspi->TxXferCount--;
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 800527c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800527e:	b29b      	uxth	r3, r3
 8005280:	b323      	cbz	r3, 80052cc <HAL_SPI_Transmit+0xda>
    {
      /* Wait until TXE flag is set to send data */
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8005282:	6823      	ldr	r3, [r4, #0]
 8005284:	689a      	ldr	r2, [r3, #8]
 8005286:	0790      	lsls	r0, r2, #30
 8005288:	d44a      	bmi.n	8005320 <HAL_SPI_Transmit+0x12e>
          hspi->TxXferCount--;
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 800528a:	2e00      	cmp	r6, #0
 800528c:	d050      	beq.n	8005330 <HAL_SPI_Transmit+0x13e>
 800528e:	1c71      	adds	r1, r6, #1
 8005290:	d0f4      	beq.n	800527c <HAL_SPI_Transmit+0x8a>
 8005292:	f7fe fec9 	bl	8004028 <HAL_GetTick>
 8005296:	1bc0      	subs	r0, r0, r7
 8005298:	4286      	cmp	r6, r0
 800529a:	d949      	bls.n	8005330 <HAL_SPI_Transmit+0x13e>
 800529c:	e7ee      	b.n	800527c <HAL_SPI_Transmit+0x8a>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
 800529e:	2a00      	cmp	r2, #0
 80052a0:	d048      	beq.n	8005334 <HAL_SPI_Transmit+0x142>
 80052a2:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80052a4:	b292      	uxth	r2, r2
 80052a6:	2a01      	cmp	r2, #1
 80052a8:	d044      	beq.n	8005334 <HAL_SPI_Transmit+0x142>
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
      pData += sizeof(uint8_t);
      hspi->TxXferCount--;
    }
    while (hspi->TxXferCount > 0U)
 80052aa:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80052ac:	b29b      	uxth	r3, r3
 80052ae:	b16b      	cbz	r3, 80052cc <HAL_SPI_Transmit+0xda>
    {
      /* Wait until TXE flag is set to send data */
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80052b0:	6823      	ldr	r3, [r4, #0]
 80052b2:	689a      	ldr	r2, [r3, #8]
 80052b4:	0792      	lsls	r2, r2, #30
 80052b6:	d43d      	bmi.n	8005334 <HAL_SPI_Transmit+0x142>
        hspi->TxXferCount--;
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 80052b8:	2e00      	cmp	r6, #0
 80052ba:	d039      	beq.n	8005330 <HAL_SPI_Transmit+0x13e>
 80052bc:	1c73      	adds	r3, r6, #1
 80052be:	d0f4      	beq.n	80052aa <HAL_SPI_Transmit+0xb8>
 80052c0:	f7fe feb2 	bl	8004028 <HAL_GetTick>
 80052c4:	1bc0      	subs	r0, r0, r7
 80052c6:	4286      	cmp	r6, r0
 80052c8:	d932      	bls.n	8005330 <HAL_SPI_Transmit+0x13e>
 80052ca:	e7ee      	b.n	80052aa <HAL_SPI_Transmit+0xb8>
      }
    }
  }

  /* Wait until TXE flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
 80052cc:	9700      	str	r7, [sp, #0]
 80052ce:	4633      	mov	r3, r6
 80052d0:	2201      	movs	r2, #1
 80052d2:	2102      	movs	r1, #2
 80052d4:	4620      	mov	r0, r4
 80052d6:	f7ff fef9 	bl	80050cc <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm>
 80052da:	bb48      	cbnz	r0, 8005330 <HAL_SPI_Transmit+0x13e>
    errorcode = HAL_TIMEOUT;
    goto error;
  }
  
  /* Check Busy flag */
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
 80052dc:	463a      	mov	r2, r7
 80052de:	4631      	mov	r1, r6
 80052e0:	4620      	mov	r0, r4
 80052e2:	f7ff ff39 	bl	8005158 <_ZL17SPI_CheckFlag_BSYP19__SPI_HandleTypeDefmm>
 80052e6:	b118      	cbz	r0, 80052f0 <HAL_SPI_Transmit+0xfe>
  {
    errorcode = HAL_ERROR;
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80052e8:	2320      	movs	r3, #32
 80052ea:	6563      	str	r3, [r4, #84]	; 0x54
  }
  
  /* Check Busy flag */
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
  {
    errorcode = HAL_ERROR;
 80052ec:	2001      	movs	r0, #1
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
    goto error;
 80052ee:	e00e      	b.n	800530e <HAL_SPI_Transmit+0x11c>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80052f0:	68a3      	ldr	r3, [r4, #8]
 80052f2:	b933      	cbnz	r3, 8005302 <HAL_SPI_Transmit+0x110>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80052f4:	9303      	str	r3, [sp, #12]
 80052f6:	6823      	ldr	r3, [r4, #0]
 80052f8:	68da      	ldr	r2, [r3, #12]
 80052fa:	9203      	str	r2, [sp, #12]
 80052fc:	689b      	ldr	r3, [r3, #8]
 80052fe:	9303      	str	r3, [sp, #12]
 8005300:	9b03      	ldr	r3, [sp, #12]
  {
     SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8005302:	6d60      	ldr	r0, [r4, #84]	; 0x54
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if(hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 8005304:	3000      	adds	r0, #0
 8005306:	bf18      	it	ne
 8005308:	2001      	movne	r0, #1
 800530a:	e000      	b.n	800530e <HAL_SPI_Transmit+0x11c>
 800530c:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 800530e:	2301      	movs	r3, #1
 8005310:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 8005314:	2300      	movs	r3, #0
 8005316:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  return errorcode;
 800531a:	e013      	b.n	8005344 <HAL_SPI_Transmit+0x152>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800531c:	2002      	movs	r0, #2
 800531e:	e011      	b.n	8005344 <HAL_SPI_Transmit+0x152>
  /* Transmit data in 16 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
    {
      hspi->Instance->DR = *((uint16_t *)pData);
 8005320:	f835 2b02 	ldrh.w	r2, [r5], #2
 8005324:	60da      	str	r2, [r3, #12]
      pData += sizeof(uint16_t);
      hspi->TxXferCount--;
 8005326:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8005328:	3b01      	subs	r3, #1
 800532a:	b29b      	uxth	r3, r3
 800532c:	86e3      	strh	r3, [r4, #54]	; 0x36
 800532e:	e7a5      	b.n	800527c <HAL_SPI_Transmit+0x8a>
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
        {
          errorcode = HAL_TIMEOUT;
 8005330:	2003      	movs	r0, #3
 8005332:	e7ec      	b.n	800530e <HAL_SPI_Transmit+0x11c>
  /* Transmit data in 8 Bit mode */
  else
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
 8005334:	f815 2b01 	ldrb.w	r2, [r5], #1
 8005338:	731a      	strb	r2, [r3, #12]
      pData += sizeof(uint8_t);
      hspi->TxXferCount--;
 800533a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800533c:	3b01      	subs	r3, #1
 800533e:	b29b      	uxth	r3, r3
 8005340:	86e3      	strh	r3, [r4, #54]	; 0x36
 8005342:	e7b2      	b.n	80052aa <HAL_SPI_Transmit+0xb8>
error:
  hspi->State = HAL_SPI_STATE_READY;
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8005344:	b004      	add	sp, #16
 8005346:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800534a <HAL_SPI_TransmitReceive>:
  * @param  Size amount of data to be sent and received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 800534a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800534e:	4698      	mov	r8, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8005350:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
  * @param  Size amount of data to be sent and received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8005354:	b085      	sub	sp, #20

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8005356:	2b01      	cmp	r3, #1
  * @param  Size amount of data to be sent and received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 8005358:	4604      	mov	r4, r0
 800535a:	460d      	mov	r5, r1
 800535c:	4616      	mov	r6, r2
 800535e:	9f0c      	ldr	r7, [sp, #48]	; 0x30

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8005360:	f000 8088 	beq.w	8005474 <HAL_SPI_TransmitReceive+0x12a>
 8005364:	2301      	movs	r3, #1
 8005366:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800536a:	f7fe fe5d 	bl	8004028 <HAL_GetTick>
  
  tmp  = hspi->State;
 800536e:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
  tmp1 = hspi->Init.Mode;
 8005372:	6861      	ldr	r1, [r4, #4]
  __HAL_LOCK(hspi);

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
  
  tmp  = hspi->State;
 8005374:	b2db      	uxtb	r3, r3
  tmp1 = hspi->Init.Mode;
  
  if(!((tmp == HAL_SPI_STATE_READY) || \
 8005376:	2b01      	cmp	r3, #1

  /* Process Locked */
  __HAL_LOCK(hspi);

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8005378:	4681      	mov	r9, r0
  
  tmp  = hspi->State;
  tmp1 = hspi->Init.Mode;
  
  if(!((tmp == HAL_SPI_STATE_READY) || \
 800537a:	d007      	beq.n	800538c <HAL_SPI_TransmitReceive+0x42>
    ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 800537c:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
 8005380:	d16e      	bne.n	8005460 <HAL_SPI_TransmitReceive+0x116>
 8005382:	68a2      	ldr	r2, [r4, #8]
 8005384:	2a00      	cmp	r2, #0
 8005386:	d16b      	bne.n	8005460 <HAL_SPI_TransmitReceive+0x116>
 8005388:	2b04      	cmp	r3, #4
 800538a:	d169      	bne.n	8005460 <HAL_SPI_TransmitReceive+0x116>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
 800538c:	2d00      	cmp	r5, #0
 800538e:	d069      	beq.n	8005464 <HAL_SPI_TransmitReceive+0x11a>
 8005390:	2e00      	cmp	r6, #0
 8005392:	d067      	beq.n	8005464 <HAL_SPI_TransmitReceive+0x11a>
 8005394:	f1b8 0f00 	cmp.w	r8, #0
 8005398:	d064      	beq.n	8005464 <HAL_SPI_TransmitReceive+0x11a>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if(hspi->State == HAL_SPI_STATE_READY)
 800539a:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 800539e:	63a6      	str	r6, [r4, #56]	; 0x38
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if(hspi->State == HAL_SPI_STATE_READY)
 80053a0:	2b01      	cmp	r3, #1
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80053a2:	bf04      	itt	eq
 80053a4:	2305      	moveq	r3, #5
 80053a6:	f884 3051 	strbeq.w	r3, [r4, #81]	; 0x51
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80053aa:	2300      	movs	r3, #0
 80053ac:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 80053ae:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 80053b0:	6463      	str	r3, [r4, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 80053b2:	6823      	ldr	r3, [r4, #0]
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
 80053b4:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e
  hspi->RxXferSize  = Size;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferCount = Size;
 80053b8:	f8a4 8036 	strh.w	r8, [r4, #54]	; 0x36
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 80053bc:	681a      	ldr	r2, [r3, #0]

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
  hspi->RxXferSize  = Size;
 80053be:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
 80053c2:	0650      	lsls	r0, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80053c4:	bf58      	it	pl
 80053c6:	681a      	ldrpl	r2, [r3, #0]
  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
  hspi->RxXferSize  = Size;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80053c8:	6325      	str	r5, [r4, #48]	; 0x30

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80053ca:	bf58      	it	pl
 80053cc:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
  hspi->RxXferSize  = Size;
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;
 80053d0:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80053d4:	bf58      	it	pl
 80053d6:	601a      	strpl	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 80053d8:	68e2      	ldr	r2, [r4, #12]
 80053da:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 80053de:	d110      	bne.n	8005402 <HAL_SPI_TransmitReceive+0xb8>
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 80053e0:	2900      	cmp	r1, #0
 80053e2:	d049      	beq.n	8005478 <HAL_SPI_TransmitReceive+0x12e>
 80053e4:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80053e6:	b292      	uxth	r2, r2
 80053e8:	2a01      	cmp	r2, #1
 80053ea:	d045      	beq.n	8005478 <HAL_SPI_TransmitReceive+0x12e>
  * @param  Size amount of data to be sent and received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
{
 80053ec:	f04f 0801 	mov.w	r8, #1
    {
      hspi->Instance->DR = *((uint16_t *)pTxData);
      pTxData += sizeof(uint16_t);
      hspi->TxXferCount--;
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 80053f0:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80053f2:	b29b      	uxth	r3, r3
 80053f4:	2b00      	cmp	r3, #0
 80053f6:	d147      	bne.n	8005488 <HAL_SPI_TransmitReceive+0x13e>
 80053f8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80053fa:	b29b      	uxth	r3, r3
 80053fc:	2b00      	cmp	r3, #0
 80053fe:	d143      	bne.n	8005488 <HAL_SPI_TransmitReceive+0x13e>
 8005400:	e00f      	b.n	8005422 <HAL_SPI_TransmitReceive+0xd8>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 8005402:	2900      	cmp	r1, #0
 8005404:	d070      	beq.n	80054e8 <HAL_SPI_TransmitReceive+0x19e>
 8005406:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8005408:	b292      	uxth	r2, r2
 800540a:	2a01      	cmp	r2, #1
 800540c:	d06c      	beq.n	80054e8 <HAL_SPI_TransmitReceive+0x19e>
      {
        *((uint16_t *)pRxData) = hspi->Instance->DR;
        pRxData += sizeof(uint16_t);
        hspi->RxXferCount--;
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
 800540e:	f04f 0801 	mov.w	r8, #1
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pTxData);
      pTxData += sizeof(uint8_t);
      hspi->TxXferCount--;
    }
    while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8005412:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8005414:	b29b      	uxth	r3, r3
 8005416:	2b00      	cmp	r3, #0
 8005418:	d16e      	bne.n	80054f8 <HAL_SPI_TransmitReceive+0x1ae>
 800541a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800541c:	b29b      	uxth	r3, r3
 800541e:	2b00      	cmp	r3, #0
 8005420:	d16a      	bne.n	80054f8 <HAL_SPI_TransmitReceive+0x1ae>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Wait until TXE flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
 8005422:	f8cd 9000 	str.w	r9, [sp]
 8005426:	463b      	mov	r3, r7
 8005428:	2201      	movs	r2, #1
 800542a:	2102      	movs	r1, #2
 800542c:	4620      	mov	r0, r4
 800542e:	f7ff fe4d 	bl	80050cc <_ZL29SPI_WaitFlagStateUntilTimeoutP19__SPI_HandleTypeDefmmmm>
 8005432:	b108      	cbz	r0, 8005438 <HAL_SPI_TransmitReceive+0xee>
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
      {
        errorcode = HAL_TIMEOUT;
 8005434:	2003      	movs	r0, #3
 8005436:	e016      	b.n	8005466 <HAL_SPI_TransmitReceive+0x11c>
    errorcode = HAL_TIMEOUT;
    goto error;
  }
  
  /* Check Busy flag */
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
 8005438:	464a      	mov	r2, r9
 800543a:	4639      	mov	r1, r7
 800543c:	4620      	mov	r0, r4
 800543e:	f7ff fe8b 	bl	8005158 <_ZL17SPI_CheckFlag_BSYP19__SPI_HandleTypeDefmm>
 8005442:	b110      	cbz	r0, 800544a <HAL_SPI_TransmitReceive+0x100>
  {
    errorcode = HAL_ERROR;
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8005444:	2320      	movs	r3, #32
 8005446:	6563      	str	r3, [r4, #84]	; 0x54
 8005448:	e00c      	b.n	8005464 <HAL_SPI_TransmitReceive+0x11a>
    goto error;
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800544a:	68a3      	ldr	r3, [r4, #8]
 800544c:	b95b      	cbnz	r3, 8005466 <HAL_SPI_TransmitReceive+0x11c>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800544e:	6822      	ldr	r2, [r4, #0]
 8005450:	9303      	str	r3, [sp, #12]
 8005452:	68d1      	ldr	r1, [r2, #12]
 8005454:	9103      	str	r1, [sp, #12]
 8005456:	6892      	ldr	r2, [r2, #8]
 8005458:	9203      	str	r2, [sp, #12]
 800545a:	9a03      	ldr	r2, [sp, #12]
  __IO uint16_t tmpreg1 = 0U;
#endif /* USE_SPI_CRC */
  uint32_t tickstart = 0U;
  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t txallowed = 1U;
  HAL_StatusTypeDef errorcode = HAL_OK;
 800545c:	4618      	mov	r0, r3
 800545e:	e002      	b.n	8005466 <HAL_SPI_TransmitReceive+0x11c>
  tmp1 = hspi->Init.Mode;
  
  if(!((tmp == HAL_SPI_STATE_READY) || \
    ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
  {
    errorcode = HAL_BUSY;
 8005460:	2002      	movs	r0, #2
 8005462:	e000      	b.n	8005466 <HAL_SPI_TransmitReceive+0x11c>
    goto error;
  }

  if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
  {
    errorcode = HAL_ERROR;
 8005464:	2001      	movs	r0, #1
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
  }
  
error :
  hspi->State = HAL_SPI_STATE_READY;
 8005466:	2301      	movs	r3, #1
 8005468:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 800546c:	2300      	movs	r3, #0
 800546e:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
 8005472:	e073      	b.n	800555c <HAL_SPI_TransmitReceive+0x212>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8005474:	2002      	movs	r0, #2
 8005476:	e071      	b.n	800555c <HAL_SPI_TransmitReceive+0x212>
  /* Transmit and Receive data in 16 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
    {
      hspi->Instance->DR = *((uint16_t *)pTxData);
 8005478:	f835 2b02 	ldrh.w	r2, [r5], #2
 800547c:	60da      	str	r2, [r3, #12]
      pTxData += sizeof(uint16_t);
      hspi->TxXferCount--;
 800547e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8005480:	3b01      	subs	r3, #1
 8005482:	b29b      	uxth	r3, r3
 8005484:	86e3      	strh	r3, [r4, #54]	; 0x36
 8005486:	e7b1      	b.n	80053ec <HAL_SPI_TransmitReceive+0xa2>
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
    {
      /* Check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 8005488:	f1b8 0f00 	cmp.w	r8, #0
 800548c:	d008      	beq.n	80054a0 <HAL_SPI_TransmitReceive+0x156>
 800548e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8005490:	b29b      	uxth	r3, r3
 8005492:	b11b      	cbz	r3, 800549c <HAL_SPI_TransmitReceive+0x152>
 8005494:	6823      	ldr	r3, [r4, #0]
 8005496:	689a      	ldr	r2, [r3, #8]
 8005498:	0791      	lsls	r1, r2, #30
 800549a:	d411      	bmi.n	80054c0 <HAL_SPI_TransmitReceive+0x176>
 800549c:	f04f 0801 	mov.w	r8, #1
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 80054a0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80054a2:	b29b      	uxth	r3, r3
 80054a4:	b11b      	cbz	r3, 80054ae <HAL_SPI_TransmitReceive+0x164>
 80054a6:	6823      	ldr	r3, [r4, #0]
 80054a8:	689a      	ldr	r2, [r3, #8]
 80054aa:	07d2      	lsls	r2, r2, #31
 80054ac:	d412      	bmi.n	80054d4 <HAL_SPI_TransmitReceive+0x18a>
        pRxData += sizeof(uint16_t);
        hspi->RxXferCount--;
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 80054ae:	1c78      	adds	r0, r7, #1
 80054b0:	d09e      	beq.n	80053f0 <HAL_SPI_TransmitReceive+0xa6>
 80054b2:	f7fe fdb9 	bl	8004028 <HAL_GetTick>
 80054b6:	ebc9 0000 	rsb	r0, r9, r0
 80054ba:	4287      	cmp	r7, r0
 80054bc:	d898      	bhi.n	80053f0 <HAL_SPI_TransmitReceive+0xa6>
 80054be:	e7b9      	b.n	8005434 <HAL_SPI_TransmitReceive+0xea>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
    {
      /* Check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
      {
        hspi->Instance->DR = *((uint16_t *)pTxData);
 80054c0:	f835 2b02 	ldrh.w	r2, [r5], #2
 80054c4:	60da      	str	r2, [r3, #12]
        pTxData += sizeof(uint16_t);
        hspi->TxXferCount--;
 80054c6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80054c8:	3b01      	subs	r3, #1
 80054ca:	b29b      	uxth	r3, r3
 80054cc:	86e3      	strh	r3, [r4, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */ 
        txallowed = 0U;
 80054ce:	f04f 0800 	mov.w	r8, #0
 80054d2:	e7e5      	b.n	80054a0 <HAL_SPI_TransmitReceive+0x156>
      }

      /* Check RXNE flag */
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
      {
        *((uint16_t *)pRxData) = hspi->Instance->DR;
 80054d4:	68db      	ldr	r3, [r3, #12]
 80054d6:	f826 3b02 	strh.w	r3, [r6], #2
        pRxData += sizeof(uint16_t);
        hspi->RxXferCount--;
 80054da:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80054dc:	3b01      	subs	r3, #1
 80054de:	b29b      	uxth	r3, r3
 80054e0:	87e3      	strh	r3, [r4, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
 80054e2:	f04f 0801 	mov.w	r8, #1
 80054e6:	e7e2      	b.n	80054ae <HAL_SPI_TransmitReceive+0x164>
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pTxData);
 80054e8:	f815 2b01 	ldrb.w	r2, [r5], #1
 80054ec:	731a      	strb	r2, [r3, #12]
      pTxData += sizeof(uint8_t);
      hspi->TxXferCount--;
 80054ee:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80054f0:	3b01      	subs	r3, #1
 80054f2:	b29b      	uxth	r3, r3
 80054f4:	86e3      	strh	r3, [r4, #54]	; 0x36
 80054f6:	e78a      	b.n	800540e <HAL_SPI_TransmitReceive+0xc4>
    }
    while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
    {
      /* check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 80054f8:	f1b8 0f00 	cmp.w	r8, #0
 80054fc:	d008      	beq.n	8005510 <HAL_SPI_TransmitReceive+0x1c6>
 80054fe:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8005500:	b29b      	uxth	r3, r3
 8005502:	b11b      	cbz	r3, 800550c <HAL_SPI_TransmitReceive+0x1c2>
 8005504:	6823      	ldr	r3, [r4, #0]
 8005506:	689a      	ldr	r2, [r3, #8]
 8005508:	0791      	lsls	r1, r2, #30
 800550a:	d413      	bmi.n	8005534 <HAL_SPI_TransmitReceive+0x1ea>
 800550c:	f04f 0801 	mov.w	r8, #1
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 8005510:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8005512:	b29b      	uxth	r3, r3
 8005514:	b11b      	cbz	r3, 800551e <HAL_SPI_TransmitReceive+0x1d4>
 8005516:	6823      	ldr	r3, [r4, #0]
 8005518:	689a      	ldr	r2, [r3, #8]
 800551a:	07d2      	lsls	r2, r2, #31
 800551c:	d414      	bmi.n	8005548 <HAL_SPI_TransmitReceive+0x1fe>
        (*(uint8_t *)pRxData++) = hspi->Instance->DR;
        hspi->RxXferCount--;
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
      }
      if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
 800551e:	1c7b      	adds	r3, r7, #1
 8005520:	f43f af77 	beq.w	8005412 <HAL_SPI_TransmitReceive+0xc8>
 8005524:	f7fe fd80 	bl	8004028 <HAL_GetTick>
 8005528:	ebc9 0000 	rsb	r0, r9, r0
 800552c:	4287      	cmp	r7, r0
 800552e:	f63f af70 	bhi.w	8005412 <HAL_SPI_TransmitReceive+0xc8>
 8005532:	e77f      	b.n	8005434 <HAL_SPI_TransmitReceive+0xea>
    while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
    {
      /* check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 8005534:	782a      	ldrb	r2, [r5, #0]
 8005536:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8005538:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800553a:	3b01      	subs	r3, #1
 800553c:	b29b      	uxth	r3, r3
 800553e:	86e3      	strh	r3, [r4, #54]	; 0x36
    while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
    {
      /* check TXE flag */
      if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 8005540:	3501      	adds	r5, #1
        hspi->TxXferCount--;
        /* Next Data is a reception (Rx). Tx not allowed */ 
        txallowed = 0U;
 8005542:	f04f 0800 	mov.w	r8, #0
 8005546:	e7e3      	b.n	8005510 <HAL_SPI_TransmitReceive+0x1c6>
      }

      /* Wait until RXNE flag is reset */
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
      {
        (*(uint8_t *)pRxData++) = hspi->Instance->DR;
 8005548:	68db      	ldr	r3, [r3, #12]
 800554a:	7033      	strb	r3, [r6, #0]
        hspi->RxXferCount--;
 800554c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800554e:	3b01      	subs	r3, #1
 8005550:	b29b      	uxth	r3, r3
 8005552:	87e3      	strh	r3, [r4, #62]	; 0x3e
      }

      /* Wait until RXNE flag is reset */
      if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
      {
        (*(uint8_t *)pRxData++) = hspi->Instance->DR;
 8005554:	3601      	adds	r6, #1
        hspi->RxXferCount--;
        /* Next Data is a Transmission (Tx). Tx is allowed */ 
        txallowed = 1U;
 8005556:	f04f 0801 	mov.w	r8, #1
 800555a:	e7e0      	b.n	800551e <HAL_SPI_TransmitReceive+0x1d4>
  
error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 800555c:	b005      	add	sp, #20
 800555e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08005562 <HAL_SPI_Receive>:
  * @param  Size amount of data to be received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8005562:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8005566:	461e      	mov	r6, r3
  __IO uint16_t tmpreg = 0U;
#endif /* USE_SPI_CRC */
  uint32_t tickstart = 0U;
  HAL_StatusTypeDef errorcode = HAL_OK;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8005568:	6843      	ldr	r3, [r0, #4]
 800556a:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  * @param  Size amount of data to be received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800556e:	4604      	mov	r4, r0
 8005570:	460d      	mov	r5, r1
 8005572:	4690      	mov	r8, r2
  __IO uint16_t tmpreg = 0U;
#endif /* USE_SPI_CRC */
  uint32_t tickstart = 0U;
  HAL_StatusTypeDef errorcode = HAL_OK;

  if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8005574:	d10a      	bne.n	800558c <HAL_SPI_Receive+0x2a>
 8005576:	6883      	ldr	r3, [r0, #8]
 8005578:	b943      	cbnz	r3, 800558c <HAL_SPI_Receive+0x2a>
  {
     hspi->State = HAL_SPI_STATE_BUSY_RX;
 800557a:	2304      	movs	r3, #4
 800557c:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51
     /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
 8005580:	4613      	mov	r3, r2
 8005582:	9600      	str	r6, [sp, #0]
 8005584:	460a      	mov	r2, r1
 8005586:	f7ff fee0 	bl	800534a <HAL_SPI_TransmitReceive>
 800558a:	e089      	b.n	80056a0 <HAL_SPI_Receive+0x13e>
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 800558c:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8005590:	2b01      	cmp	r3, #1
 8005592:	f000 8081 	beq.w	8005698 <HAL_SPI_Receive+0x136>
 8005596:	2301      	movs	r3, #1
 8005598:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800559c:	f7fe fd44 	bl	8004028 <HAL_GetTick>
 80055a0:	4607      	mov	r7, r0

  if(hspi->State != HAL_SPI_STATE_READY)
 80055a2:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
 80055a6:	b2c0      	uxtb	r0, r0
 80055a8:	2801      	cmp	r0, #1
 80055aa:	d16d      	bne.n	8005688 <HAL_SPI_Receive+0x126>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pData == NULL ) || (Size == 0))
 80055ac:	2d00      	cmp	r5, #0
 80055ae:	d06c      	beq.n	800568a <HAL_SPI_Receive+0x128>
 80055b0:	f1b8 0f00 	cmp.w	r8, #0
 80055b4:	d069      	beq.n	800568a <HAL_SPI_Receive+0x128>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 80055b6:	2304      	movs	r3, #4
 80055b8:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80055bc:	2300      	movs	r3, #0
 80055be:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;

  /*Init field not used in handle to zero */
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 80055c0:	6323      	str	r3, [r4, #48]	; 0x30
  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pData;
  hspi->RxXferSize  = Size;
  hspi->RxXferCount = Size;
 80055c2:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e

  /*Init field not used in handle to zero */
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
  hspi->TxXferSize  = 0U;
 80055c6:	86a3      	strh	r3, [r4, #52]	; 0x34
  hspi->TxXferCount = 0U;
 80055c8:	86e3      	strh	r3, [r4, #54]	; 0x36
  hspi->RxISR       = NULL;
 80055ca:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 80055cc:	6463      	str	r3, [r4, #68]	; 0x44
    hspi->RxXferCount--;
  }
#endif /* USE_SPI_CRC */

  /* Configure communication direction: 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80055ce:	68a3      	ldr	r3, [r4, #8]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 80055d0:	63a5      	str	r5, [r4, #56]	; 0x38
    hspi->RxXferCount--;
  }
#endif /* USE_SPI_CRC */

  /* Configure communication direction: 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80055d2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80055d6:	6823      	ldr	r3, [r4, #0]

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pData;
  hspi->RxXferSize  = Size;
 80055d8:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
#endif /* USE_SPI_CRC */

  /* Configure communication direction: 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_RX(hspi);
 80055dc:	bf02      	ittt	eq
 80055de:	681a      	ldreq	r2, [r3, #0]
 80055e0:	f422 4280 	biceq.w	r2, r2, #16384	; 0x4000
 80055e4:	601a      	streq	r2, [r3, #0]
  }

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80055e6:	681a      	ldr	r2, [r3, #0]
 80055e8:	0652      	lsls	r2, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80055ea:	bf5e      	ittt	pl
 80055ec:	681a      	ldrpl	r2, [r3, #0]
 80055ee:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 80055f2:	601a      	strpl	r2, [r3, #0]
  }

    /* Receive data in 8 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 80055f4:	68e3      	ldr	r3, [r4, #12]
 80055f6:	bb23      	cbnz	r3, 8005642 <HAL_SPI_Receive+0xe0>
  {
    /* Transfer loop */
    while(hspi->RxXferCount > 0U)
 80055f8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80055fa:	b29b      	uxth	r3, r3
 80055fc:	2b00      	cmp	r3, #0
 80055fe:	d02e      	beq.n	800565e <HAL_SPI_Receive+0xfc>
    {
      /* Check the RXNE flag */
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 8005600:	6823      	ldr	r3, [r4, #0]
 8005602:	689a      	ldr	r2, [r3, #8]
 8005604:	07d0      	lsls	r0, r2, #31
 8005606:	d507      	bpl.n	8005618 <HAL_SPI_Receive+0xb6>
      {
        /* read the received data */
        (* (uint8_t *)pData)= *(__IO uint8_t *)&hspi->Instance->DR;
 8005608:	7b1b      	ldrb	r3, [r3, #12]
 800560a:	f805 3b01 	strb.w	r3, [r5], #1
        pData += sizeof(uint8_t);
        hspi->RxXferCount--;
 800560e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8005610:	3b01      	subs	r3, #1
 8005612:	b29b      	uxth	r3, r3
 8005614:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8005616:	e7ef      	b.n	80055f8 <HAL_SPI_Receive+0x96>
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 8005618:	2e00      	cmp	r6, #0
 800561a:	d03f      	beq.n	800569c <HAL_SPI_Receive+0x13a>
 800561c:	1c71      	adds	r1, r6, #1
 800561e:	d0eb      	beq.n	80055f8 <HAL_SPI_Receive+0x96>
 8005620:	f7fe fd02 	bl	8004028 <HAL_GetTick>
 8005624:	1bc0      	subs	r0, r0, r7
 8005626:	4286      	cmp	r6, r0
 8005628:	d938      	bls.n	800569c <HAL_SPI_Receive+0x13a>
 800562a:	e7e5      	b.n	80055f8 <HAL_SPI_Receive+0x96>
  {
    /* Transfer loop */
    while(hspi->RxXferCount > 0U)
    {
      /* Check the RXNE flag */
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 800562c:	6823      	ldr	r3, [r4, #0]
 800562e:	689a      	ldr	r2, [r3, #8]
 8005630:	07d2      	lsls	r2, r2, #31
 8005632:	d50b      	bpl.n	800564c <HAL_SPI_Receive+0xea>
      {
        *((uint16_t*)pData) = hspi->Instance->DR;
 8005634:	68db      	ldr	r3, [r3, #12]
 8005636:	f825 3b02 	strh.w	r3, [r5], #2
        pData += sizeof(uint16_t);
        hspi->RxXferCount--;
 800563a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800563c:	3b01      	subs	r3, #1
 800563e:	b29b      	uxth	r3, r3
 8005640:	87e3      	strh	r3, [r4, #62]	; 0x3e
    }
  }
  else
  {
    /* Transfer loop */
    while(hspi->RxXferCount > 0U)
 8005642:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8005644:	b29b      	uxth	r3, r3
 8005646:	2b00      	cmp	r3, #0
 8005648:	d1f0      	bne.n	800562c <HAL_SPI_Receive+0xca>
 800564a:	e008      	b.n	800565e <HAL_SPI_Receive+0xfc>
        hspi->RxXferCount--;
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 800564c:	b336      	cbz	r6, 800569c <HAL_SPI_Receive+0x13a>
 800564e:	1c73      	adds	r3, r6, #1
 8005650:	d0f7      	beq.n	8005642 <HAL_SPI_Receive+0xe0>
 8005652:	f7fe fce9 	bl	8004028 <HAL_GetTick>
 8005656:	1bc0      	subs	r0, r0, r7
 8005658:	4286      	cmp	r6, r0
 800565a:	d91f      	bls.n	800569c <HAL_SPI_Receive+0x13a>
 800565c:	e7f1      	b.n	8005642 <HAL_SPI_Receive+0xe0>
    UNUSED(tmpreg);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800565e:	6863      	ldr	r3, [r4, #4]
 8005660:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8005664:	d10b      	bne.n	800567e <HAL_SPI_Receive+0x11c>
 8005666:	68a3      	ldr	r3, [r4, #8]
 8005668:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800566c:	d002      	beq.n	8005674 <HAL_SPI_Receive+0x112>
 800566e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005672:	d104      	bne.n	800567e <HAL_SPI_Receive+0x11c>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 8005674:	6822      	ldr	r2, [r4, #0]
 8005676:	6813      	ldr	r3, [r2, #0]
 8005678:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800567c:	6013      	str	r3, [r2, #0]
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
  }
#endif /* USE_SPI_CRC */

  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800567e:	6d60      	ldr	r0, [r4, #84]	; 0x54
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if(hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 8005680:	3000      	adds	r0, #0
 8005682:	bf18      	it	ne
 8005684:	2001      	movne	r0, #1
 8005686:	e000      	b.n	800568a <HAL_SPI_Receive+0x128>
 8005688:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 800568a:	2301      	movs	r3, #1
 800568c:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 8005690:	2300      	movs	r3, #0
 8005692:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  return errorcode;
 8005696:	e003      	b.n	80056a0 <HAL_SPI_Receive+0x13e>
     /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8005698:	2002      	movs	r0, #2
 800569a:	e001      	b.n	80056a0 <HAL_SPI_Receive+0x13e>
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
        {
          errorcode = HAL_TIMEOUT;
 800569c:	2003      	movs	r0, #3
 800569e:	e7f4      	b.n	800568a <HAL_SPI_Receive+0x128>

error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 80056a0:	b002      	add	sp, #8
 80056a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080056a6 <HAL_SPI_ErrorCallback>:
 80056a6:	4770      	bx	lr

080056a8 <HAL_SPI_IRQHandler>:
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
  uint32_t itsource = hspi->Instance->CR2;
 80056a8:	6803      	ldr	r3, [r0, #0]
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 80056aa:	b530      	push	{r4, r5, lr}
  uint32_t itsource = hspi->Instance->CR2;
 80056ac:	6859      	ldr	r1, [r3, #4]
  uint32_t itflag   = hspi->Instance->SR;
 80056ae:	689a      	ldr	r2, [r3, #8]

  /* SPI in mode Receiver ----------------------------------------------------*/
  if(((itflag & SPI_FLAG_OVR) == RESET) &&
 80056b0:	f002 0541 	and.w	r5, r2, #65	; 0x41
 80056b4:	2d01      	cmp	r5, #1
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 80056b6:	b085      	sub	sp, #20
 80056b8:	4604      	mov	r4, r0
  uint32_t itsource = hspi->Instance->CR2;
  uint32_t itflag   = hspi->Instance->SR;

  /* SPI in mode Receiver ----------------------------------------------------*/
  if(((itflag & SPI_FLAG_OVR) == RESET) &&
 80056ba:	d103      	bne.n	80056c4 <HAL_SPI_IRQHandler+0x1c>
     ((itflag & SPI_FLAG_RXNE) != RESET) && ((itsource & SPI_IT_RXNE) != RESET))
 80056bc:	064d      	lsls	r5, r1, #25
 80056be:	d501      	bpl.n	80056c4 <HAL_SPI_IRQHandler+0x1c>
  {
    hspi->RxISR(hspi);
 80056c0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80056c2:	e005      	b.n	80056d0 <HAL_SPI_IRQHandler+0x28>
    return;
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if(((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
 80056c4:	0795      	lsls	r5, r2, #30
 80056c6:	d505      	bpl.n	80056d4 <HAL_SPI_IRQHandler+0x2c>
 80056c8:	0608      	lsls	r0, r1, #24
 80056ca:	d503      	bpl.n	80056d4 <HAL_SPI_IRQHandler+0x2c>
  {
    hspi->TxISR(hspi);
 80056cc:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80056ce:	4620      	mov	r0, r4
 80056d0:	4798      	blx	r3
    return;
 80056d2:	e057      	b.n	8005784 <HAL_SPI_IRQHandler+0xdc>
  }

  /* SPI in Error Treatment --------------------------------------------------*/
  if(((itflag & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET) && ((itsource & SPI_IT_ERR) != RESET))
 80056d4:	f412 7fb0 	tst.w	r2, #352	; 0x160
 80056d8:	d054      	beq.n	8005784 <HAL_SPI_IRQHandler+0xdc>
 80056da:	068d      	lsls	r5, r1, #26
 80056dc:	d552      	bpl.n	8005784 <HAL_SPI_IRQHandler+0xdc>
  {
    /* SPI Overrun error interrupt occurred ----------------------------------*/
    if((itflag & SPI_FLAG_OVR) != RESET)
 80056de:	0650      	lsls	r0, r2, #25
 80056e0:	d517      	bpl.n	8005712 <HAL_SPI_IRQHandler+0x6a>
    {
      if(hspi->State != HAL_SPI_STATE_BUSY_TX)
 80056e2:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
 80056e6:	2803      	cmp	r0, #3
 80056e8:	f04f 0500 	mov.w	r5, #0
 80056ec:	d00a      	beq.n	8005704 <HAL_SPI_IRQHandler+0x5c>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 80056ee:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80056f0:	f040 0004 	orr.w	r0, r0, #4
 80056f4:	6560      	str	r0, [r4, #84]	; 0x54
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80056f6:	9500      	str	r5, [sp, #0]
 80056f8:	68d8      	ldr	r0, [r3, #12]
 80056fa:	9000      	str	r0, [sp, #0]
 80056fc:	6898      	ldr	r0, [r3, #8]
 80056fe:	9000      	str	r0, [sp, #0]
 8005700:	9800      	ldr	r0, [sp, #0]
 8005702:	e006      	b.n	8005712 <HAL_SPI_IRQHandler+0x6a>
      }
      else
      {
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8005704:	9501      	str	r5, [sp, #4]
 8005706:	68da      	ldr	r2, [r3, #12]
 8005708:	9201      	str	r2, [sp, #4]
 800570a:	689b      	ldr	r3, [r3, #8]
 800570c:	9301      	str	r3, [sp, #4]
 800570e:	9b01      	ldr	r3, [sp, #4]
        return;
 8005710:	e038      	b.n	8005784 <HAL_SPI_IRQHandler+0xdc>
      }
    }

    /* SPI Mode Fault error interrupt occurred -------------------------------*/
    if((itflag & SPI_FLAG_MODF) != RESET)
 8005712:	0695      	lsls	r5, r2, #26
 8005714:	d50c      	bpl.n	8005730 <HAL_SPI_IRQHandler+0x88>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8005716:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8005718:	f040 0001 	orr.w	r0, r0, #1
 800571c:	6560      	str	r0, [r4, #84]	; 0x54
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 800571e:	2000      	movs	r0, #0
 8005720:	9002      	str	r0, [sp, #8]
 8005722:	6898      	ldr	r0, [r3, #8]
 8005724:	9002      	str	r0, [sp, #8]
 8005726:	6818      	ldr	r0, [r3, #0]
 8005728:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800572c:	6018      	str	r0, [r3, #0]
 800572e:	9802      	ldr	r0, [sp, #8]
    }

    /* SPI Frame error interrupt occurred ------------------------------------*/
    if((itflag & SPI_FLAG_FRE) != RESET)
 8005730:	05d0      	lsls	r0, r2, #23
 8005732:	d508      	bpl.n	8005746 <HAL_SPI_IRQHandler+0x9e>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8005734:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8005736:	f042 0208 	orr.w	r2, r2, #8
 800573a:	6562      	str	r2, [r4, #84]	; 0x54
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 800573c:	2200      	movs	r2, #0
 800573e:	9203      	str	r2, [sp, #12]
 8005740:	689a      	ldr	r2, [r3, #8]
 8005742:	9203      	str	r2, [sp, #12]
 8005744:	9a03      	ldr	r2, [sp, #12]
    }

    if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8005746:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8005748:	b1e2      	cbz	r2, 8005784 <HAL_SPI_IRQHandler+0xdc>
    {
      /* Disable all interrupts */
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 800574a:	685a      	ldr	r2, [r3, #4]
 800574c:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8005750:	605a      	str	r2, [r3, #4]

      hspi->State = HAL_SPI_STATE_READY;
 8005752:	2201      	movs	r2, #1
 8005754:	f884 2051 	strb.w	r2, [r4, #81]	; 0x51
      /* Disable the SPI DMA requests if enabled */
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN))||(HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 8005758:	078a      	lsls	r2, r1, #30
 800575a:	d010      	beq.n	800577e <HAL_SPI_IRQHandler+0xd6>
      {
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 800575c:	685a      	ldr	r2, [r3, #4]

        /* Abort the SPI DMA Rx channel */
        if(hspi->hdmarx != NULL)
 800575e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c

      hspi->State = HAL_SPI_STATE_READY;
      /* Disable the SPI DMA requests if enabled */
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN))||(HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
      {
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 8005760:	f022 0203 	bic.w	r2, r2, #3
 8005764:	605a      	str	r2, [r3, #4]

        /* Abort the SPI DMA Rx channel */
        if(hspi->hdmarx != NULL)
 8005766:	b118      	cbz	r0, 8005770 <HAL_SPI_IRQHandler+0xc8>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 8005768:	4b07      	ldr	r3, [pc, #28]	; (8005788 <HAL_SPI_IRQHandler+0xe0>)
 800576a:	6503      	str	r3, [r0, #80]	; 0x50
          HAL_DMA_Abort_IT(hspi->hdmarx);
 800576c:	f7fe fef0 	bl	8004550 <HAL_DMA_Abort_IT>
        }
        /* Abort the SPI DMA Tx channel */
        if(hspi->hdmatx != NULL)
 8005770:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8005772:	b138      	cbz	r0, 8005784 <HAL_SPI_IRQHandler+0xdc>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 8005774:	4b04      	ldr	r3, [pc, #16]	; (8005788 <HAL_SPI_IRQHandler+0xe0>)
 8005776:	6503      	str	r3, [r0, #80]	; 0x50
          HAL_DMA_Abort_IT(hspi->hdmatx);
 8005778:	f7fe feea 	bl	8004550 <HAL_DMA_Abort_IT>
 800577c:	e002      	b.n	8005784 <HAL_SPI_IRQHandler+0xdc>
        }
      }
      else
      {
        /* Call user error callback */
        HAL_SPI_ErrorCallback(hspi);
 800577e:	4620      	mov	r0, r4
 8005780:	f7ff ff91 	bl	80056a6 <HAL_SPI_ErrorCallback>
      }
    }
    return;
  }
}
 8005784:	b005      	add	sp, #20
 8005786:	bd30      	pop	{r4, r5, pc}
 8005788:	0800578d 	.word	0x0800578d

0800578c <_ZL19SPI_DMAAbortOnErrorP19__DMA_HandleTypeDef>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 800578c:	b508      	push	{r3, lr}
  SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800578e:	6b80      	ldr	r0, [r0, #56]	; 0x38
  hspi->RxXferCount = 0U;
 8005790:	2300      	movs	r3, #0
 8005792:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hspi->TxXferCount = 0U;
 8005794:	86c3      	strh	r3, [r0, #54]	; 0x36

  HAL_SPI_ErrorCallback(hspi);
 8005796:	f7ff ff86 	bl	80056a6 <HAL_SPI_ErrorCallback>
 800579a:	bd08      	pop	{r3, pc}

0800579c <_ZL18UART_EndRxTransferP18UART_HandleTypeDef>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800579c:	6803      	ldr	r3, [r0, #0]
 800579e:	68da      	ldr	r2, [r3, #12]
 80057a0:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 80057a4:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80057a6:	695a      	ldr	r2, [r3, #20]
 80057a8:	f022 0201 	bic.w	r2, r2, #1
 80057ac:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80057ae:	2320      	movs	r3, #32
 80057b0:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
 80057b4:	4770      	bx	lr
	...

080057b8 <_ZL14UART_SetConfigP18UART_HandleTypeDef>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80057b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 80057bc:	6807      	ldr	r7, [r0, #0]
 80057be:	693b      	ldr	r3, [r7, #16]
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80057c0:	4604      	mov	r4, r0

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80057c2:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80057c6:	68c3      	ldr	r3, [r0, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80057c8:	68a1      	ldr	r1, [r4, #8]
 80057ca:	69c0      	ldr	r0, [r0, #28]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80057cc:	4313      	orrs	r3, r2
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80057ce:	6922      	ldr	r2, [r4, #16]

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
  
  /* Write to USART CR2 */
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 80057d0:	613b      	str	r3, [r7, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;
 80057d2:	68fb      	ldr	r3, [r7, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80057d4:	4311      	orrs	r1, r2
 80057d6:	6962      	ldr	r2, [r4, #20]
  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
                                   USART_CR1_RE | USART_CR1_OVER8));
 80057d8:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80057dc:	430a      	orrs	r2, r1
 80057de:	4302      	orrs	r2, r0
  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
                                   USART_CR1_RE | USART_CR1_OVER8));
 80057e0:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80057e4:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 80057e6:	60fb      	str	r3, [r7, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 80057e8:	697b      	ldr	r3, [r7, #20]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 80057ea:	f423 7240 	bic.w	r2, r3, #768	; 0x300
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 80057ee:	69a3      	ldr	r3, [r4, #24]
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80057f0:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 80057f4:	ea43 0302 	orr.w	r3, r3, r2
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 80057f8:	617b      	str	r3, [r7, #20]
 80057fa:	4b7c      	ldr	r3, [pc, #496]	; (80059ec <_ZL14UART_SetConfigP18UART_HandleTypeDef+0x234>)
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80057fc:	d17c      	bne.n	80058f8 <_ZL14UART_SetConfigP18UART_HandleTypeDef+0x140>
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
#if defined(USART6) 
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 80057fe:	429f      	cmp	r7, r3
 8005800:	d003      	beq.n	800580a <_ZL14UART_SetConfigP18UART_HandleTypeDef+0x52>
 8005802:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005806:	429f      	cmp	r7, r3
 8005808:	d131      	bne.n	800586e <_ZL14UART_SetConfigP18UART_HandleTypeDef+0xb6>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 800580a:	f7ff fad5 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 800580e:	6863      	ldr	r3, [r4, #4]
 8005810:	2519      	movs	r5, #25
 8005812:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8005816:	4368      	muls	r0, r5
 8005818:	fbb0 f8f8 	udiv	r8, r0, r8
 800581c:	f7ff facc 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 8005820:	6866      	ldr	r6, [r4, #4]
 8005822:	4368      	muls	r0, r5
 8005824:	0076      	lsls	r6, r6, #1
 8005826:	fbb0 f6f6 	udiv	r6, r0, r6
 800582a:	f7ff fac5 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 800582e:	6863      	ldr	r3, [r4, #4]
 8005830:	f04f 0964 	mov.w	r9, #100	; 0x64
 8005834:	005b      	lsls	r3, r3, #1
 8005836:	4368      	muls	r0, r5
 8005838:	fbb0 f0f3 	udiv	r0, r0, r3
 800583c:	fbb0 f0f9 	udiv	r0, r0, r9
 8005840:	fb09 6610 	mls	r6, r9, r0, r6
 8005844:	f7ff fab8 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 8005848:	fbb8 f8f9 	udiv	r8, r8, r9
 800584c:	6861      	ldr	r1, [r4, #4]
 800584e:	00f6      	lsls	r6, r6, #3
 8005850:	3632      	adds	r6, #50	; 0x32
 8005852:	fbb6 f6f9 	udiv	r6, r6, r9
 8005856:	0076      	lsls	r6, r6, #1
 8005858:	4368      	muls	r0, r5
 800585a:	0049      	lsls	r1, r1, #1
 800585c:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8005860:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8005864:	fbb0 faf1 	udiv	sl, r0, r1
 8005868:	f7ff faa6 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 800586c:	e030      	b.n	80058d0 <_ZL14UART_SetConfigP18UART_HandleTypeDef+0x118>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }	
#endif /* USART6 */
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 800586e:	f7ff fa93 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 8005872:	6863      	ldr	r3, [r4, #4]
 8005874:	2519      	movs	r5, #25
 8005876:	ea4f 0843 	mov.w	r8, r3, lsl #1
 800587a:	4368      	muls	r0, r5
 800587c:	fbb0 f8f8 	udiv	r8, r0, r8
 8005880:	f7ff fa8a 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 8005884:	6866      	ldr	r6, [r4, #4]
 8005886:	4368      	muls	r0, r5
 8005888:	0076      	lsls	r6, r6, #1
 800588a:	fbb0 f6f6 	udiv	r6, r0, r6
 800588e:	f7ff fa83 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 8005892:	6863      	ldr	r3, [r4, #4]
 8005894:	f04f 0964 	mov.w	r9, #100	; 0x64
 8005898:	005b      	lsls	r3, r3, #1
 800589a:	4368      	muls	r0, r5
 800589c:	fbb0 f0f3 	udiv	r0, r0, r3
 80058a0:	fbb0 f0f9 	udiv	r0, r0, r9
 80058a4:	fb09 6610 	mls	r6, r9, r0, r6
 80058a8:	f7ff fa76 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 80058ac:	fbb8 f8f9 	udiv	r8, r8, r9
 80058b0:	00f6      	lsls	r6, r6, #3
 80058b2:	6861      	ldr	r1, [r4, #4]
 80058b4:	3632      	adds	r6, #50	; 0x32
 80058b6:	fbb6 f6f9 	udiv	r6, r6, r9
 80058ba:	0076      	lsls	r6, r6, #1
 80058bc:	4368      	muls	r0, r5
 80058be:	0049      	lsls	r1, r1, #1
 80058c0:	ea4f 1808 	mov.w	r8, r8, lsl #4
 80058c4:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 80058c8:	fbb0 faf1 	udiv	sl, r0, r1
 80058cc:	f7ff fa64 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 80058d0:	4345      	muls	r5, r0
 80058d2:	6860      	ldr	r0, [r4, #4]
 80058d4:	0040      	lsls	r0, r0, #1
 80058d6:	fbb5 f0f0 	udiv	r0, r5, r0
 80058da:	fbb0 f0f9 	udiv	r0, r0, r9
 80058de:	fb09 a210 	mls	r2, r9, r0, sl
 80058e2:	00d2      	lsls	r2, r2, #3
 80058e4:	3232      	adds	r2, #50	; 0x32
 80058e6:	fbb2 f3f9 	udiv	r3, r2, r9
 80058ea:	f003 0307 	and.w	r3, r3, #7
 80058ee:	4443      	add	r3, r8
 80058f0:	441e      	add	r6, r3
 80058f2:	60be      	str	r6, [r7, #8]
 80058f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
#if defined(USART6) 
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 80058f8:	429f      	cmp	r7, r3
 80058fa:	d002      	beq.n	8005902 <_ZL14UART_SetConfigP18UART_HandleTypeDef+0x14a>
 80058fc:	4b3c      	ldr	r3, [pc, #240]	; (80059f0 <_ZL14UART_SetConfigP18UART_HandleTypeDef+0x238>)
 80058fe:	429f      	cmp	r7, r3
 8005900:	d130      	bne.n	8005964 <_ZL14UART_SetConfigP18UART_HandleTypeDef+0x1ac>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8005902:	f7ff fa59 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 8005906:	6863      	ldr	r3, [r4, #4]
 8005908:	2519      	movs	r5, #25
 800590a:	ea4f 0883 	mov.w	r8, r3, lsl #2
 800590e:	4368      	muls	r0, r5
 8005910:	fbb0 f8f8 	udiv	r8, r0, r8
 8005914:	f7ff fa50 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 8005918:	6866      	ldr	r6, [r4, #4]
 800591a:	4368      	muls	r0, r5
 800591c:	00b6      	lsls	r6, r6, #2
 800591e:	fbb0 f6f6 	udiv	r6, r0, r6
 8005922:	f7ff fa49 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 8005926:	6863      	ldr	r3, [r4, #4]
 8005928:	f04f 0964 	mov.w	r9, #100	; 0x64
 800592c:	009b      	lsls	r3, r3, #2
 800592e:	4368      	muls	r0, r5
 8005930:	fbb0 f0f3 	udiv	r0, r0, r3
 8005934:	fbb0 f0f9 	udiv	r0, r0, r9
 8005938:	fb09 6610 	mls	r6, r9, r0, r6
 800593c:	f7ff fa3c 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 8005940:	fbb8 f8f9 	udiv	r8, r8, r9
 8005944:	6861      	ldr	r1, [r4, #4]
 8005946:	0136      	lsls	r6, r6, #4
 8005948:	4368      	muls	r0, r5
 800594a:	0089      	lsls	r1, r1, #2
 800594c:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8005950:	3632      	adds	r6, #50	; 0x32
 8005952:	fbb0 faf1 	udiv	sl, r0, r1
 8005956:	fbb6 f6f9 	udiv	r6, r6, r9
 800595a:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 800595e:	f7ff fa2b 	bl	8004db8 <HAL_RCC_GetPCLK2Freq>
 8005962:	e02f      	b.n	80059c4 <_ZL14UART_SetConfigP18UART_HandleTypeDef+0x20c>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }	
#endif /* USART6 */
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8005964:	f7ff fa18 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 8005968:	6863      	ldr	r3, [r4, #4]
 800596a:	2519      	movs	r5, #25
 800596c:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8005970:	4368      	muls	r0, r5
 8005972:	fbb0 f8f8 	udiv	r8, r0, r8
 8005976:	f7ff fa0f 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 800597a:	6866      	ldr	r6, [r4, #4]
 800597c:	4368      	muls	r0, r5
 800597e:	00b6      	lsls	r6, r6, #2
 8005980:	fbb0 f6f6 	udiv	r6, r0, r6
 8005984:	f7ff fa08 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 8005988:	6863      	ldr	r3, [r4, #4]
 800598a:	f04f 0964 	mov.w	r9, #100	; 0x64
 800598e:	009b      	lsls	r3, r3, #2
 8005990:	4368      	muls	r0, r5
 8005992:	fbb0 f0f3 	udiv	r0, r0, r3
 8005996:	fbb0 f0f9 	udiv	r0, r0, r9
 800599a:	fb09 6610 	mls	r6, r9, r0, r6
 800599e:	f7ff f9fb 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 80059a2:	fbb8 f8f9 	udiv	r8, r8, r9
 80059a6:	6861      	ldr	r1, [r4, #4]
 80059a8:	0136      	lsls	r6, r6, #4
 80059aa:	3632      	adds	r6, #50	; 0x32
 80059ac:	4368      	muls	r0, r5
 80059ae:	fbb6 f6f9 	udiv	r6, r6, r9
 80059b2:	0089      	lsls	r1, r1, #2
 80059b4:	ea4f 1808 	mov.w	r8, r8, lsl #4
 80059b8:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 80059bc:	fbb0 faf1 	udiv	sl, r0, r1
 80059c0:	f7ff f9ea 	bl	8004d98 <HAL_RCC_GetPCLK1Freq>
 80059c4:	4345      	muls	r5, r0
 80059c6:	6860      	ldr	r0, [r4, #4]
 80059c8:	0080      	lsls	r0, r0, #2
 80059ca:	fbb5 f0f0 	udiv	r0, r5, r0
 80059ce:	fbb0 f0f9 	udiv	r0, r0, r9
 80059d2:	fb09 a210 	mls	r2, r9, r0, sl
 80059d6:	0112      	lsls	r2, r2, #4
 80059d8:	3232      	adds	r2, #50	; 0x32
 80059da:	fbb2 f3f9 	udiv	r3, r2, r9
 80059de:	f003 030f 	and.w	r3, r3, #15
 80059e2:	4433      	add	r3, r6
 80059e4:	4443      	add	r3, r8
 80059e6:	60bb      	str	r3, [r7, #8]
 80059e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80059ec:	40011000 	.word	0x40011000
 80059f0:	40011400 	.word	0x40011400

080059f4 <HAL_UART_Init>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80059f4:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 80059f6:	4604      	mov	r4, r0
 80059f8:	b340      	cbz	r0, 8005a4c <HAL_UART_Init+0x58>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  
  if(huart->gState == HAL_UART_STATE_RESET)
 80059fa:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 80059fe:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005a02:	b91b      	cbnz	r3, 8005a0c <HAL_UART_Init+0x18>
  {  
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8005a04:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 8005a08:	f7fd fd30 	bl	800346c <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8005a0c:	6822      	ldr	r2, [r4, #0]
    huart->Lock = HAL_UNLOCKED;
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8005a0e:	2324      	movs	r3, #36	; 0x24
 8005a10:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8005a14:	68d3      	ldr	r3, [r2, #12]
 8005a16:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005a1a:	60d3      	str	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8005a1c:	4620      	mov	r0, r4
 8005a1e:	f7ff fecb 	bl	80057b8 <_ZL14UART_SetConfigP18UART_HandleTypeDef>
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8005a22:	6823      	ldr	r3, [r4, #0]
 8005a24:	691a      	ldr	r2, [r3, #16]
 8005a26:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8005a2a:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8005a2c:	695a      	ldr	r2, [r3, #20]
 8005a2e:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8005a32:	615a      	str	r2, [r3, #20]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8005a34:	68da      	ldr	r2, [r3, #12]
 8005a36:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8005a3a:	60da      	str	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005a3c:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 8005a3e:	2320      	movs	r3, #32
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005a40:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8005a42:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8005a46:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  
  return HAL_OK;
 8005a4a:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 8005a4c:	2001      	movs	r0, #1
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->gState= HAL_UART_STATE_READY;
  huart->RxState= HAL_UART_STATE_READY;
  
  return HAL_OK;
}
 8005a4e:	bd10      	pop	{r4, pc}

08005a50 <HAL_UART_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8005a50:	b538      	push	{r3, r4, r5, lr}
 8005a52:	4604      	mov	r4, r0
 8005a54:	4613      	mov	r3, r2
  uint32_t *tmp;
  
  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
 8005a56:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8005a5a:	2a20      	cmp	r2, #32
 8005a5c:	d12a      	bne.n	8005ab4 <HAL_UART_Transmit_DMA+0x64>
  {
    if((pData == NULL ) || (Size == 0))
 8005a5e:	b339      	cbz	r1, 8005ab0 <HAL_UART_Transmit_DMA+0x60>
 8005a60:	b333      	cbz	r3, 8005ab0 <HAL_UART_Transmit_DMA+0x60>
    {
      return HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8005a62:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 8005a66:	2a01      	cmp	r2, #1
 8005a68:	d024      	beq.n	8005ab4 <HAL_UART_Transmit_DMA+0x64>
 8005a6a:	2201      	movs	r2, #1
 8005a6c:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->gState = HAL_UART_STATE_BUSY_TX;

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8005a70:	6b20      	ldr	r0, [r4, #48]	; 0x30
    /* Process Locked */
    __HAL_LOCK(huart);

    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
    huart->TxXferCount = Size;
 8005a72:	84e3      	strh	r3, [r4, #38]	; 0x26

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005a74:	2500      	movs	r5, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005a76:	2221      	movs	r2, #33	; 0x21

    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
    huart->TxXferCount = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005a78:	63e5      	str	r5, [r4, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005a7a:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8005a7e:	4a0e      	ldr	r2, [pc, #56]	; (8005ab8 <HAL_UART_Transmit_DMA+0x68>)

    /* Process Locked */
    __HAL_LOCK(huart);

    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
 8005a80:	84a3      	strh	r3, [r4, #36]	; 0x24
    }

    /* Process Locked */
    __HAL_LOCK(huart);

    huart->pTxBuffPtr = pData;
 8005a82:	6221      	str	r1, [r4, #32]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->gState = HAL_UART_STATE_BUSY_TX;

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8005a84:	63c2      	str	r2, [r0, #60]	; 0x3c

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8005a86:	4a0d      	ldr	r2, [pc, #52]	; (8005abc <HAL_UART_Transmit_DMA+0x6c>)
 8005a88:	6402      	str	r2, [r0, #64]	; 0x40

    /* Set the DMA error callback */
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 8005a8a:	4a0d      	ldr	r2, [pc, #52]	; (8005ac0 <HAL_UART_Transmit_DMA+0x70>)
 8005a8c:	64c2      	str	r2, [r0, #76]	; 0x4c
    /* Set the DMA abort callback */
    huart->hdmatx->XferAbortCallback = NULL;

    /* Enable the UART transmit DMA Stream */
    tmp = (uint32_t*)&pData;
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
 8005a8e:	6822      	ldr	r2, [r4, #0]

    /* Set the DMA error callback */
    huart->hdmatx->XferErrorCallback = UART_DMAError;

    /* Set the DMA abort callback */
    huart->hdmatx->XferAbortCallback = NULL;
 8005a90:	6505      	str	r5, [r0, #80]	; 0x50

    /* Enable the UART transmit DMA Stream */
    tmp = (uint32_t*)&pData;
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
 8005a92:	3204      	adds	r2, #4
 8005a94:	f7fe fd1c 	bl	80044d0 <HAL_DMA_Start_IT>
    
    /* Clear the TC flag in the SR register by writing 0 to it */
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 8005a98:	6823      	ldr	r3, [r4, #0]
 8005a9a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8005a9e:	601a      	str	r2, [r3, #0]
    /* Process Unlocked */
    __HAL_UNLOCK(huart);
    
    /* Enable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8005aa0:	695a      	ldr	r2, [r3, #20]
    
    /* Clear the TC flag in the SR register by writing 0 to it */
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
    
    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8005aa2:	f884 5038 	strb.w	r5, [r4, #56]	; 0x38
    
    /* Enable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8005aa6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005aaa:	615a      	str	r2, [r3, #20]
    
    return HAL_OK;
 8005aac:	4628      	mov	r0, r5
 8005aae:	bd38      	pop	{r3, r4, r5, pc}
  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0))
    {
      return HAL_ERROR;
 8005ab0:	2001      	movs	r0, #1
 8005ab2:	bd38      	pop	{r3, r4, r5, pc}
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8005ab4:	2002      	movs	r0, #2
  }
}
 8005ab6:	bd38      	pop	{r3, r4, r5, pc}
 8005ab8:	08005b57 	.word	0x08005b57
 8005abc:	08005b85 	.word	0x08005b85
 8005ac0:	08005c4f 	.word	0x08005c4f

08005ac4 <HAL_UART_Receive_DMA>:
  * @param  Size Amount of data to be received
  * @note   When the UART parity is enabled (PCE = 1) the data received contain the parity bit.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{  
 8005ac4:	4613      	mov	r3, r2
  uint32_t *tmp;
  
  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY) 
 8005ac6:	f890 203a 	ldrb.w	r2, [r0, #58]	; 0x3a
 8005aca:	2a20      	cmp	r2, #32
  * @param  Size Amount of data to be received
  * @note   When the UART parity is enabled (PCE = 1) the data received contain the parity bit.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{  
 8005acc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8005ace:	4605      	mov	r5, r0
  uint32_t *tmp;
  
  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY) 
 8005ad0:	d137      	bne.n	8005b42 <HAL_UART_Receive_DMA+0x7e>
  {
    if((pData == NULL ) || (Size == 0)) 
 8005ad2:	2900      	cmp	r1, #0
 8005ad4:	d033      	beq.n	8005b3e <HAL_UART_Receive_DMA+0x7a>
 8005ad6:	2b00      	cmp	r3, #0
 8005ad8:	d031      	beq.n	8005b3e <HAL_UART_Receive_DMA+0x7a>
    {
      return HAL_ERROR;
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 8005ada:	f890 2038 	ldrb.w	r2, [r0, #56]	; 0x38
 8005ade:	2a01      	cmp	r2, #1
 8005ae0:	d02f      	beq.n	8005b42 <HAL_UART_Receive_DMA+0x7e>
 8005ae2:	2201      	movs	r2, #1
    
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005ae4:	2400      	movs	r4, #0
    {
      return HAL_ERROR;
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 8005ae6:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8005aea:	2222      	movs	r2, #34	; 0x22
    __HAL_LOCK(huart);
    
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005aec:	63c4      	str	r4, [r0, #60]	; 0x3c
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
    
    huart->pRxBuffPtr = pData;
 8005aee:	6281      	str	r1, [r0, #40]	; 0x28
    huart->RxXferSize = Size;
 8005af0:	8583      	strh	r3, [r0, #44]	; 0x2c
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8005af2:	f880 203a 	strb.w	r2, [r0, #58]	; 0x3a
        
    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8005af6:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8005af8:	4a13      	ldr	r2, [pc, #76]	; (8005b48 <HAL_UART_Receive_DMA+0x84>)
 8005afa:	63c2      	str	r2, [r0, #60]	; 0x3c
    /* Set the DMA abort callback */
    huart->hdmarx->XferAbortCallback = NULL;

    /* Enable the DMA Stream */
    tmp = (uint32_t*)&pData;
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
 8005afc:	682e      	ldr	r6, [r5, #0]
        
    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
    
    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8005afe:	4a13      	ldr	r2, [pc, #76]	; (8005b4c <HAL_UART_Receive_DMA+0x88>)
 8005b00:	6402      	str	r2, [r0, #64]	; 0x40
    
    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 8005b02:	4a13      	ldr	r2, [pc, #76]	; (8005b50 <HAL_UART_Receive_DMA+0x8c>)
 8005b04:	64c2      	str	r2, [r0, #76]	; 0x4c
    
    /* Set the DMA abort callback */
    huart->hdmarx->XferAbortCallback = NULL;
 8005b06:	6504      	str	r4, [r0, #80]	; 0x50

    /* Enable the DMA Stream */
    tmp = (uint32_t*)&pData;
    HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
 8005b08:	460a      	mov	r2, r1
 8005b0a:	1d31      	adds	r1, r6, #4
 8005b0c:	f7fe fce0 	bl	80044d0 <HAL_DMA_Start_IT>

    /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
    __HAL_UART_CLEAR_OREFLAG(huart);
 8005b10:	682b      	ldr	r3, [r5, #0]
 8005b12:	9401      	str	r4, [sp, #4]
 8005b14:	681a      	ldr	r2, [r3, #0]
 8005b16:	9201      	str	r2, [sp, #4]
 8005b18:	685a      	ldr	r2, [r3, #4]
 8005b1a:	9201      	str	r2, [sp, #4]
 8005b1c:	9a01      	ldr	r2, [sp, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Parity Error Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8005b1e:	68da      	ldr	r2, [r3, #12]

    /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
    __HAL_UART_CLEAR_OREFLAG(huart);

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8005b20:	f885 4038 	strb.w	r4, [r5, #56]	; 0x38

    /* Enable the UART Parity Error Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8005b24:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005b28:	60da      	str	r2, [r3, #12]

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005b2a:	695a      	ldr	r2, [r3, #20]
 8005b2c:	f042 0201 	orr.w	r2, r2, #1
 8005b30:	615a      	str	r2, [r3, #20]
    
    /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
    in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8005b32:	695a      	ldr	r2, [r3, #20]
 8005b34:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005b38:	615a      	str	r2, [r3, #20]

    return HAL_OK;
 8005b3a:	4620      	mov	r0, r4
 8005b3c:	e002      	b.n	8005b44 <HAL_UART_Receive_DMA+0x80>
  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY) 
  {
    if((pData == NULL ) || (Size == 0)) 
    {
      return HAL_ERROR;
 8005b3e:	2001      	movs	r0, #1
 8005b40:	e000      	b.n	8005b44 <HAL_UART_Receive_DMA+0x80>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8005b42:	2002      	movs	r0, #2
  }
}
 8005b44:	b002      	add	sp, #8
 8005b46:	bd70      	pop	{r4, r5, r6, pc}
 8005b48:	08005b91 	.word	0x08005b91
 8005b4c:	08005c43 	.word	0x08005c43
 8005b50:	08005c4f 	.word	0x08005c4f

08005b54 <HAL_UART_TxCpltCallback>:
 8005b54:	4770      	bx	lr

08005b56 <_ZL20UART_DMATransmitCpltP19__DMA_HandleTypeDef>:
  * @brief  DMA UART transmit process complete callback. 
  * @param  hdma DMA handle
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 8005b56:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  /* DMA Normal mode*/
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8005b58:	6803      	ldr	r3, [r0, #0]
  * @param  hdma DMA handle
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8005b5a:	6b82      	ldr	r2, [r0, #56]	; 0x38
  /* DMA Normal mode*/
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8005b5c:	681b      	ldr	r3, [r3, #0]
 8005b5e:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8005b62:	d10a      	bne.n	8005b7a <_ZL20UART_DMATransmitCpltP19__DMA_HandleTypeDef+0x24>
  {
    huart->TxXferCount = 0U;
 8005b64:	84d3      	strh	r3, [r2, #38]	; 0x26

    /* Disable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8005b66:	6813      	ldr	r3, [r2, #0]
 8005b68:	695a      	ldr	r2, [r3, #20]
 8005b6a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8005b6e:	615a      	str	r2, [r3, #20]

    /* Enable the UART Transmit Complete Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8005b70:	68da      	ldr	r2, [r3, #12]
 8005b72:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005b76:	60da      	str	r2, [r3, #12]
 8005b78:	bd08      	pop	{r3, pc}

  }
  /* DMA Circular mode */
  else
  {
    HAL_UART_TxCpltCallback(huart);
 8005b7a:	4610      	mov	r0, r2
 8005b7c:	f7ff ffea 	bl	8005b54 <HAL_UART_TxCpltCallback>
 8005b80:	bd08      	pop	{r3, pc}

08005b82 <HAL_UART_TxHalfCpltCallback>:
 8005b82:	4770      	bx	lr

08005b84 <_ZL18UART_DMATxHalfCpltP19__DMA_HandleTypeDef>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8005b84:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_UART_TxHalfCpltCallback(huart);
 8005b86:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8005b88:	f7ff fffb 	bl	8005b82 <HAL_UART_TxHalfCpltCallback>
 8005b8c:	bd08      	pop	{r3, pc}

08005b8e <HAL_UART_RxCpltCallback>:
 8005b8e:	4770      	bx	lr

08005b90 <_ZL19UART_DMAReceiveCpltP19__DMA_HandleTypeDef>:
  * @brief  DMA UART receive process complete callback. 
  * @param  hdma DMA handle
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 8005b90:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  /* DMA Normal mode*/
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8005b92:	6803      	ldr	r3, [r0, #0]
  * @param  hdma DMA handle
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8005b94:	6b82      	ldr	r2, [r0, #56]	; 0x38
  /* DMA Normal mode*/
  if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8005b96:	681b      	ldr	r3, [r3, #0]
 8005b98:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8005b9c:	d110      	bne.n	8005bc0 <_ZL19UART_DMAReceiveCpltP19__DMA_HandleTypeDef+0x30>
  {
    huart->RxXferCount = 0U;
 8005b9e:	85d3      	strh	r3, [r2, #46]	; 0x2e
  
    /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8005ba0:	6813      	ldr	r3, [r2, #0]
 8005ba2:	68d9      	ldr	r1, [r3, #12]
 8005ba4:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 8005ba8:	60d9      	str	r1, [r3, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005baa:	6959      	ldr	r1, [r3, #20]
 8005bac:	f021 0101 	bic.w	r1, r1, #1
 8005bb0:	6159      	str	r1, [r3, #20]
    
    /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8005bb2:	6959      	ldr	r1, [r3, #20]
 8005bb4:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8005bb8:	6159      	str	r1, [r3, #20]
	
    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 8005bba:	2320      	movs	r3, #32
 8005bbc:	f882 303a 	strb.w	r3, [r2, #58]	; 0x3a
  }
  HAL_UART_RxCpltCallback(huart);
 8005bc0:	4610      	mov	r0, r2
 8005bc2:	f7ff ffe4 	bl	8005b8e <HAL_UART_RxCpltCallback>
 8005bc6:	bd08      	pop	{r3, pc}

08005bc8 <_ZL15UART_Receive_ITP18UART_HandleTypeDef>:
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8005bc8:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8005bcc:	2b22      	cmp	r3, #34	; 0x22
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 8005bce:	b510      	push	{r4, lr}
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8005bd0:	d132      	bne.n	8005c38 <_ZL15UART_Receive_ITP18UART_HandleTypeDef+0x70>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8005bd2:	6883      	ldr	r3, [r0, #8]
 8005bd4:	6901      	ldr	r1, [r0, #16]
 8005bd6:	6802      	ldr	r2, [r0, #0]
 8005bd8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005bdc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8005bde:	d10b      	bne.n	8005bf8 <_ZL15UART_Receive_ITP18UART_HandleTypeDef+0x30>
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8005be0:	6852      	ldr	r2, [r2, #4]
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
 8005be2:	b921      	cbnz	r1, 8005bee <_ZL15UART_Receive_ITP18UART_HandleTypeDef+0x26>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8005be4:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8005be8:	f823 2b02 	strh.w	r2, [r3], #2
 8005bec:	e002      	b.n	8005bf4 <_ZL15UART_Receive_ITP18UART_HandleTypeDef+0x2c>
        huart->pRxBuffPtr += 2U;
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 8005bee:	b2d2      	uxtb	r2, r2
 8005bf0:	f823 2b01 	strh.w	r2, [r3], #1
        huart->pRxBuffPtr += 1U;
 8005bf4:	6283      	str	r3, [r0, #40]	; 0x28
 8005bf6:	e00a      	b.n	8005c0e <_ZL15UART_Receive_ITP18UART_HandleTypeDef+0x46>
      }
    }
    else
    {
      if(huart->Init.Parity == UART_PARITY_NONE)
 8005bf8:	b919      	cbnz	r1, 8005c02 <_ZL15UART_Receive_ITP18UART_HandleTypeDef+0x3a>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8005bfa:	1c59      	adds	r1, r3, #1
 8005bfc:	6281      	str	r1, [r0, #40]	; 0x28
 8005bfe:	6852      	ldr	r2, [r2, #4]
 8005c00:	e004      	b.n	8005c0c <_ZL15UART_Receive_ITP18UART_HandleTypeDef+0x44>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8005c02:	6852      	ldr	r2, [r2, #4]
 8005c04:	1c59      	adds	r1, r3, #1
 8005c06:	6281      	str	r1, [r0, #40]	; 0x28
 8005c08:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8005c0c:	701a      	strb	r2, [r3, #0]
      }
    }

    if(--huart->RxXferCount == 0U)
 8005c0e:	8dc4      	ldrh	r4, [r0, #46]	; 0x2e
 8005c10:	3c01      	subs	r4, #1
 8005c12:	b2a4      	uxth	r4, r4
 8005c14:	85c4      	strh	r4, [r0, #46]	; 0x2e
 8005c16:	b98c      	cbnz	r4, 8005c3c <_ZL15UART_Receive_ITP18UART_HandleTypeDef+0x74>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8005c18:	6803      	ldr	r3, [r0, #0]
 8005c1a:	68da      	ldr	r2, [r3, #12]
 8005c1c:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8005c20:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005c22:	695a      	ldr	r2, [r3, #20]
 8005c24:	f022 0201 	bic.w	r2, r2, #1
 8005c28:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8005c2a:	2320      	movs	r3, #32
 8005c2c:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
     
      HAL_UART_RxCpltCallback(huart);
 8005c30:	f7ff ffad 	bl	8005b8e <HAL_UART_RxCpltCallback>
 8005c34:	4620      	mov	r0, r4
 8005c36:	bd10      	pop	{r4, pc}
    }
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8005c38:	2002      	movs	r0, #2
 8005c3a:	bd10      	pop	{r4, pc}
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
      }
    }

    if(--huart->RxXferCount == 0U)
 8005c3c:	2000      	movs	r0, #0
  }
  else
  {
    return HAL_BUSY;
  }
}
 8005c3e:	bd10      	pop	{r4, pc}

08005c40 <HAL_UART_RxHalfCpltCallback>:
 8005c40:	4770      	bx	lr

08005c42 <_ZL18UART_DMARxHalfCpltP19__DMA_HandleTypeDef>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8005c42:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_UART_RxHalfCpltCallback(huart); 
 8005c44:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8005c46:	f7ff fffb 	bl	8005c40 <HAL_UART_RxHalfCpltCallback>
 8005c4a:	bd08      	pop	{r3, pc}

08005c4c <HAL_UART_ErrorCallback>:
 8005c4c:	4770      	bx	lr

08005c4e <_ZL13UART_DMAErrorP19__DMA_HandleTypeDef>:
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  uint32_t dmarequest = 0x00U;
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8005c4e:	6b81      	ldr	r1, [r0, #56]	; 0x38
  * @brief  DMA UART communication error callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 8005c50:	b508      	push	{r3, lr}
  uint32_t dmarequest = 0x00U;
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;

  /* Stop UART DMA Tx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 8005c52:	680b      	ldr	r3, [r1, #0]
 8005c54:	695a      	ldr	r2, [r3, #20]
  if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8005c56:	f891 0039 	ldrb.w	r0, [r1, #57]	; 0x39
 8005c5a:	2821      	cmp	r0, #33	; 0x21
 8005c5c:	d101      	bne.n	8005c62 <_ZL13UART_DMAErrorP19__DMA_HandleTypeDef+0x14>
 8005c5e:	0612      	lsls	r2, r2, #24
 8005c60:	d40e      	bmi.n	8005c80 <_ZL13UART_DMAErrorP19__DMA_HandleTypeDef+0x32>
    huart->TxXferCount = 0U;
    UART_EndTxTransfer(huart);
  }

  /* Stop UART DMA Rx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
 8005c62:	695b      	ldr	r3, [r3, #20]
  if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8005c64:	f891 203a 	ldrb.w	r2, [r1, #58]	; 0x3a
 8005c68:	2a22      	cmp	r2, #34	; 0x22
 8005c6a:	d101      	bne.n	8005c70 <_ZL13UART_DMAErrorP19__DMA_HandleTypeDef+0x22>
 8005c6c:	065b      	lsls	r3, r3, #25
 8005c6e:	d411      	bmi.n	8005c94 <_ZL13UART_DMAErrorP19__DMA_HandleTypeDef+0x46>
  {
    huart->RxXferCount = 0U;
    UART_EndRxTransfer(huart);
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8005c70:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8005c72:	f043 0310 	orr.w	r3, r3, #16
 8005c76:	63cb      	str	r3, [r1, #60]	; 0x3c
  HAL_UART_ErrorCallback(huart);
 8005c78:	4608      	mov	r0, r1
 8005c7a:	f7ff ffe7 	bl	8005c4c <HAL_UART_ErrorCallback>
}
 8005c7e:	bd08      	pop	{r3, pc}

  /* Stop UART DMA Tx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
  if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
  {
    huart->TxXferCount = 0U;
 8005c80:	2200      	movs	r2, #0
 8005c82:	84ca      	strh	r2, [r1, #38]	; 0x26
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8005c84:	68da      	ldr	r2, [r3, #12]
 8005c86:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8005c8a:	60da      	str	r2, [r3, #12]

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8005c8c:	2220      	movs	r2, #32
 8005c8e:	f881 2039 	strb.w	r2, [r1, #57]	; 0x39
 8005c92:	e7e6      	b.n	8005c62 <_ZL13UART_DMAErrorP19__DMA_HandleTypeDef+0x14>

  /* Stop UART DMA Rx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
  if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
  {
    huart->RxXferCount = 0U;
 8005c94:	2300      	movs	r3, #0
 8005c96:	85cb      	strh	r3, [r1, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 8005c98:	4608      	mov	r0, r1
 8005c9a:	f7ff fd7f 	bl	800579c <_ZL18UART_EndRxTransferP18UART_HandleTypeDef>
 8005c9e:	e7e7      	b.n	8005c70 <_ZL13UART_DMAErrorP19__DMA_HandleTypeDef+0x22>

08005ca0 <HAL_UART_IRQHandler>:
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8005ca0:	6803      	ldr	r3, [r0, #0]
 8005ca2:	681a      	ldr	r2, [r3, #0]
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8005ca4:	68d9      	ldr	r1, [r3, #12]
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8005ca6:	b570      	push	{r4, r5, r6, lr}
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8005ca8:	0716      	lsls	r6, r2, #28
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8005caa:	4604      	mov	r4, r0
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8005cac:	695d      	ldr	r5, [r3, #20]
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8005cae:	d107      	bne.n	8005cc0 <HAL_UART_IRQHandler+0x20>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8005cb0:	0696      	lsls	r6, r2, #26
 8005cb2:	d53f      	bpl.n	8005d34 <HAL_UART_IRQHandler+0x94>
 8005cb4:	068d      	lsls	r5, r1, #26
 8005cb6:	d53d      	bpl.n	8005d34 <HAL_UART_IRQHandler+0x94>
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8005cb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if(errorflags == RESET)
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
    {
      UART_Receive_IT(huart);
 8005cbc:	f7ff bf84 	b.w	8005bc8 <_ZL15UART_Receive_ITP18UART_HandleTypeDef>
      return;
    }
  }  

  /* If some errors occur */
  if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8005cc0:	f015 0001 	ands.w	r0, r5, #1
 8005cc4:	d102      	bne.n	8005ccc <HAL_UART_IRQHandler+0x2c>
 8005cc6:	f411 7f90 	tst.w	r1, #288	; 0x120
 8005cca:	d033      	beq.n	8005d34 <HAL_UART_IRQHandler+0x94>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8005ccc:	07d6      	lsls	r6, r2, #31
 8005cce:	d505      	bpl.n	8005cdc <HAL_UART_IRQHandler+0x3c>
 8005cd0:	05cd      	lsls	r5, r1, #23
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8005cd2:	bf42      	ittt	mi
 8005cd4:	6be3      	ldrmi	r3, [r4, #60]	; 0x3c
 8005cd6:	f043 0301 	orrmi.w	r3, r3, #1
 8005cda:	63e3      	strmi	r3, [r4, #60]	; 0x3c
    }
    
    /* UART noise error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8005cdc:	0753      	lsls	r3, r2, #29
 8005cde:	d504      	bpl.n	8005cea <HAL_UART_IRQHandler+0x4a>
 8005ce0:	b118      	cbz	r0, 8005cea <HAL_UART_IRQHandler+0x4a>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8005ce2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005ce4:	f043 0302 	orr.w	r3, r3, #2
 8005ce8:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
    
    /* UART frame error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8005cea:	0796      	lsls	r6, r2, #30
 8005cec:	d504      	bpl.n	8005cf8 <HAL_UART_IRQHandler+0x58>
 8005cee:	b118      	cbz	r0, 8005cf8 <HAL_UART_IRQHandler+0x58>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8005cf0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005cf2:	f043 0304 	orr.w	r3, r3, #4
 8005cf6:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
    
    /* UART Over-Run interrupt occurred --------------------------------------*/
    if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8005cf8:	0715      	lsls	r5, r2, #28
 8005cfa:	d504      	bpl.n	8005d06 <HAL_UART_IRQHandler+0x66>
 8005cfc:	b118      	cbz	r0, 8005d06 <HAL_UART_IRQHandler+0x66>
    { 
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8005cfe:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005d00:	f043 0308 	orr.w	r3, r3, #8
 8005d04:	63e3      	str	r3, [r4, #60]	; 0x3c
    }

    /* Call UART Error Call back function if need be --------------------------*/    
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 8005d06:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005d08:	2b00      	cmp	r3, #0
 8005d0a:	d068      	beq.n	8005dde <HAL_UART_IRQHandler+0x13e>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8005d0c:	0690      	lsls	r0, r2, #26
 8005d0e:	d504      	bpl.n	8005d1a <HAL_UART_IRQHandler+0x7a>
 8005d10:	0689      	lsls	r1, r1, #26
 8005d12:	d502      	bpl.n	8005d1a <HAL_UART_IRQHandler+0x7a>
      {
        UART_Receive_IT(huart);
 8005d14:	4620      	mov	r0, r4
 8005d16:	f7ff ff57 	bl	8005bc8 <_ZL15UART_Receive_ITP18UART_HandleTypeDef>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8005d1a:	6823      	ldr	r3, [r4, #0]
 8005d1c:	695b      	ldr	r3, [r3, #20]
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8005d1e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8005d20:	0712      	lsls	r2, r2, #28
 8005d22:	d441      	bmi.n	8005da8 <HAL_UART_IRQHandler+0x108>
 8005d24:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8005d28:	d13e      	bne.n	8005da8 <HAL_UART_IRQHandler+0x108>
      }
      else
      {
        /* Non Blocking error : transfer could go on. 
           Error is notified to user through user error callback */
        HAL_UART_ErrorCallback(huart);
 8005d2a:	4620      	mov	r0, r4
 8005d2c:	f7ff ff8e 	bl	8005c4c <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005d30:	63e5      	str	r5, [r4, #60]	; 0x3c
 8005d32:	bd70      	pop	{r4, r5, r6, pc}
    }
    return;
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8005d34:	0616      	lsls	r6, r2, #24
 8005d36:	d528      	bpl.n	8005d8a <HAL_UART_IRQHandler+0xea>
 8005d38:	060d      	lsls	r5, r1, #24
 8005d3a:	d526      	bpl.n	8005d8a <HAL_UART_IRQHandler+0xea>
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Tx process is ongoing */
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
 8005d3c:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8005d40:	2a21      	cmp	r2, #33	; 0x21
 8005d42:	d14c      	bne.n	8005dde <HAL_UART_IRQHandler+0x13e>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8005d44:	68a2      	ldr	r2, [r4, #8]
 8005d46:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8005d4a:	6a22      	ldr	r2, [r4, #32]
 8005d4c:	d10a      	bne.n	8005d64 <HAL_UART_IRQHandler+0xc4>
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8005d4e:	8811      	ldrh	r1, [r2, #0]
 8005d50:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8005d54:	6059      	str	r1, [r3, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8005d56:	6921      	ldr	r1, [r4, #16]
 8005d58:	b909      	cbnz	r1, 8005d5e <HAL_UART_IRQHandler+0xbe>
      {
        huart->pTxBuffPtr += 2U;
 8005d5a:	3202      	adds	r2, #2
 8005d5c:	e000      	b.n	8005d60 <HAL_UART_IRQHandler+0xc0>
      }
      else
      {
        huart->pTxBuffPtr += 1U;
 8005d5e:	3201      	adds	r2, #1
 8005d60:	6222      	str	r2, [r4, #32]
 8005d62:	e003      	b.n	8005d6c <HAL_UART_IRQHandler+0xcc>
      }
    } 
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8005d64:	1c51      	adds	r1, r2, #1
 8005d66:	6221      	str	r1, [r4, #32]
 8005d68:	7812      	ldrb	r2, [r2, #0]
 8005d6a:	605a      	str	r2, [r3, #4]
    }

    if(--huart->TxXferCount == 0U)
 8005d6c:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8005d6e:	3a01      	subs	r2, #1
 8005d70:	b292      	uxth	r2, r2
 8005d72:	84e2      	strh	r2, [r4, #38]	; 0x26
 8005d74:	2a00      	cmp	r2, #0
 8005d76:	d132      	bne.n	8005dde <HAL_UART_IRQHandler+0x13e>
    {
      /* Disable the UART Transmit Complete Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8005d78:	68da      	ldr	r2, [r3, #12]
 8005d7a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8005d7e:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */    
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8005d80:	68da      	ldr	r2, [r3, #12]
 8005d82:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005d86:	60da      	str	r2, [r3, #12]
 8005d88:	bd70      	pop	{r4, r5, r6, pc}
    UART_Transmit_IT(huart);
    return;
  }
  
  /* UART in mode Transmitter end --------------------------------------------*/
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8005d8a:	0650      	lsls	r0, r2, #25
 8005d8c:	d527      	bpl.n	8005dde <HAL_UART_IRQHandler+0x13e>
 8005d8e:	0649      	lsls	r1, r1, #25
 8005d90:	d525      	bpl.n	8005dde <HAL_UART_IRQHandler+0x13e>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8005d92:	68da      	ldr	r2, [r3, #12]
 8005d94:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005d98:	60da      	str	r2, [r3, #12]
  
  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8005d9a:	2320      	movs	r3, #32
 8005d9c:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    
  HAL_UART_TxCpltCallback(huart);
 8005da0:	4620      	mov	r0, r4
 8005da2:	f7ff fed7 	bl	8005b54 <HAL_UART_TxCpltCallback>
 8005da6:	bd70      	pop	{r4, r5, r6, pc}
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8005da8:	4620      	mov	r0, r4
 8005daa:	f7ff fcf7 	bl	800579c <_ZL18UART_EndRxTransferP18UART_HandleTypeDef>
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8005dae:	6823      	ldr	r3, [r4, #0]
 8005db0:	695a      	ldr	r2, [r3, #20]
 8005db2:	0652      	lsls	r2, r2, #25
 8005db4:	d50f      	bpl.n	8005dd6 <HAL_UART_IRQHandler+0x136>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8005db6:	695a      	ldr	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8005db8:	6b60      	ldr	r0, [r4, #52]	; 0x34
        UART_EndRxTransfer(huart);
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8005dba:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005dbe:	615a      	str	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8005dc0:	b148      	cbz	r0, 8005dd6 <HAL_UART_IRQHandler+0x136>
          {
            /* Set the UART DMA Abort callback : 
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8005dc2:	4b07      	ldr	r3, [pc, #28]	; (8005de0 <HAL_UART_IRQHandler+0x140>)
 8005dc4:	6503      	str	r3, [r0, #80]	; 0x50
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8005dc6:	f7fe fbc3 	bl	8004550 <HAL_DMA_Abort_IT>
 8005dca:	b140      	cbz	r0, 8005dde <HAL_UART_IRQHandler+0x13e>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8005dcc:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8005dce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8005dd2:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8005dd4:	4718      	bx	r3
            }
          }
          else
          {
            /* Call user error callback */
            HAL_UART_ErrorCallback(huart);
 8005dd6:	4620      	mov	r0, r4
 8005dd8:	f7ff ff38 	bl	8005c4c <HAL_UART_ErrorCallback>
 8005ddc:	bd70      	pop	{r4, r5, r6, pc}
 8005dde:	bd70      	pop	{r4, r5, r6, pc}
 8005de0:	08005de5 	.word	0x08005de5

08005de4 <_ZL20UART_DMAAbortOnErrorP19__DMA_HandleTypeDef>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8005de4:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8005de6:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
 8005de8:	2300      	movs	r3, #0
 8005dea:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0U;
 8005dec:	84c3      	strh	r3, [r0, #38]	; 0x26

  HAL_UART_ErrorCallback(huart);
 8005dee:	f7ff ff2d 	bl	8005c4c <HAL_UART_ErrorCallback>
 8005df2:	bd08      	pop	{r3, pc}

08005df4 <_ZNK7Vector3IfErmERKS0_>:
 8005df4:	b580      	push	{r7, lr}
 8005df6:	b08c      	sub	sp, #48	; 0x30
 8005df8:	af00      	add	r7, sp, #0
 8005dfa:	6178      	str	r0, [r7, #20]
 8005dfc:	6139      	str	r1, [r7, #16]
 8005dfe:	697b      	ldr	r3, [r7, #20]
 8005e00:	ed93 7a01 	vldr	s14, [r3, #4]
 8005e04:	693b      	ldr	r3, [r7, #16]
 8005e06:	edd3 7a02 	vldr	s15, [r3, #8]
 8005e0a:	ee27 7a27 	vmul.f32	s14, s14, s15
 8005e0e:	697b      	ldr	r3, [r7, #20]
 8005e10:	edd3 6a02 	vldr	s13, [r3, #8]
 8005e14:	693b      	ldr	r3, [r7, #16]
 8005e16:	edd3 7a01 	vldr	s15, [r3, #4]
 8005e1a:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8005e1e:	ee37 6a67 	vsub.f32	s12, s14, s15
 8005e22:	697b      	ldr	r3, [r7, #20]
 8005e24:	ed93 7a02 	vldr	s14, [r3, #8]
 8005e28:	693b      	ldr	r3, [r7, #16]
 8005e2a:	edd3 7a00 	vldr	s15, [r3]
 8005e2e:	ee27 7a27 	vmul.f32	s14, s14, s15
 8005e32:	697b      	ldr	r3, [r7, #20]
 8005e34:	edd3 6a00 	vldr	s13, [r3]
 8005e38:	693b      	ldr	r3, [r7, #16]
 8005e3a:	edd3 7a02 	vldr	s15, [r3, #8]
 8005e3e:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8005e42:	ee77 5a67 	vsub.f32	s11, s14, s15
 8005e46:	697b      	ldr	r3, [r7, #20]
 8005e48:	ed93 7a00 	vldr	s14, [r3]
 8005e4c:	693b      	ldr	r3, [r7, #16]
 8005e4e:	edd3 7a01 	vldr	s15, [r3, #4]
 8005e52:	ee27 7a27 	vmul.f32	s14, s14, s15
 8005e56:	697b      	ldr	r3, [r7, #20]
 8005e58:	edd3 6a01 	vldr	s13, [r3, #4]
 8005e5c:	693b      	ldr	r3, [r7, #16]
 8005e5e:	edd3 7a00 	vldr	s15, [r3]
 8005e62:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8005e66:	ee77 7a67 	vsub.f32	s15, s14, s15
 8005e6a:	f107 0318 	add.w	r3, r7, #24
 8005e6e:	eeb0 1a67 	vmov.f32	s2, s15
 8005e72:	eef0 0a65 	vmov.f32	s1, s11
 8005e76:	eeb0 0a46 	vmov.f32	s0, s12
 8005e7a:	4618      	mov	r0, r3
 8005e7c:	f000 f9ce 	bl	800621c <_ZN7Vector3IfEC1Efff>
 8005e80:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8005e84:	f107 0218 	add.w	r2, r7, #24
 8005e88:	ca07      	ldmia	r2, {r0, r1, r2}
 8005e8a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8005e8e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8005e90:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005e92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005e94:	ee06 1a90 	vmov	s13, r1
 8005e98:	ee07 2a10 	vmov	s14, r2
 8005e9c:	ee07 3a90 	vmov	s15, r3
 8005ea0:	eeb0 0a66 	vmov.f32	s0, s13
 8005ea4:	eef0 0a47 	vmov.f32	s1, s14
 8005ea8:	eeb0 1a67 	vmov.f32	s2, s15
 8005eac:	3730      	adds	r7, #48	; 0x30
 8005eae:	46bd      	mov	sp, r7
 8005eb0:	bd80      	pop	{r7, pc}
 8005eb2:	bf00      	nop

08005eb4 <_ZNK7Vector3IfEmlERKS0_>:
 8005eb4:	b480      	push	{r7}
 8005eb6:	b083      	sub	sp, #12
 8005eb8:	af00      	add	r7, sp, #0
 8005eba:	6078      	str	r0, [r7, #4]
 8005ebc:	6039      	str	r1, [r7, #0]
 8005ebe:	687b      	ldr	r3, [r7, #4]
 8005ec0:	ed93 7a00 	vldr	s14, [r3]
 8005ec4:	683b      	ldr	r3, [r7, #0]
 8005ec6:	edd3 7a00 	vldr	s15, [r3]
 8005eca:	ee27 7a27 	vmul.f32	s14, s14, s15
 8005ece:	687b      	ldr	r3, [r7, #4]
 8005ed0:	edd3 6a01 	vldr	s13, [r3, #4]
 8005ed4:	683b      	ldr	r3, [r7, #0]
 8005ed6:	edd3 7a01 	vldr	s15, [r3, #4]
 8005eda:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8005ede:	ee37 7a27 	vadd.f32	s14, s14, s15
 8005ee2:	687b      	ldr	r3, [r7, #4]
 8005ee4:	edd3 6a02 	vldr	s13, [r3, #8]
 8005ee8:	683b      	ldr	r3, [r7, #0]
 8005eea:	edd3 7a02 	vldr	s15, [r3, #8]
 8005eee:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8005ef2:	ee77 7a27 	vadd.f32	s15, s14, s15
 8005ef6:	eeb0 0a67 	vmov.f32	s0, s15
 8005efa:	370c      	adds	r7, #12
 8005efc:	46bd      	mov	sp, r7
 8005efe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f02:	4770      	bx	lr

08005f04 <_ZN7Vector3IfEdVEf>:
 8005f04:	b480      	push	{r7}
 8005f06:	b083      	sub	sp, #12
 8005f08:	af00      	add	r7, sp, #0
 8005f0a:	6078      	str	r0, [r7, #4]
 8005f0c:	ed87 0a00 	vstr	s0, [r7]
 8005f10:	687b      	ldr	r3, [r7, #4]
 8005f12:	edd3 6a00 	vldr	s13, [r3]
 8005f16:	ed97 7a00 	vldr	s14, [r7]
 8005f1a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8005f1e:	687b      	ldr	r3, [r7, #4]
 8005f20:	edc3 7a00 	vstr	s15, [r3]
 8005f24:	687b      	ldr	r3, [r7, #4]
 8005f26:	edd3 6a01 	vldr	s13, [r3, #4]
 8005f2a:	ed97 7a00 	vldr	s14, [r7]
 8005f2e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8005f32:	687b      	ldr	r3, [r7, #4]
 8005f34:	edc3 7a01 	vstr	s15, [r3, #4]
 8005f38:	687b      	ldr	r3, [r7, #4]
 8005f3a:	edd3 6a02 	vldr	s13, [r3, #8]
 8005f3e:	ed97 7a00 	vldr	s14, [r7]
 8005f42:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8005f46:	687b      	ldr	r3, [r7, #4]
 8005f48:	edc3 7a02 	vstr	s15, [r3, #8]
 8005f4c:	687b      	ldr	r3, [r7, #4]
 8005f4e:	4618      	mov	r0, r3
 8005f50:	370c      	adds	r7, #12
 8005f52:	46bd      	mov	sp, r7
 8005f54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f58:	4770      	bx	lr
 8005f5a:	bf00      	nop

08005f5c <_ZN7Vector3IfEmIERKS0_>:
 8005f5c:	b480      	push	{r7}
 8005f5e:	b083      	sub	sp, #12
 8005f60:	af00      	add	r7, sp, #0
 8005f62:	6078      	str	r0, [r7, #4]
 8005f64:	6039      	str	r1, [r7, #0]
 8005f66:	687b      	ldr	r3, [r7, #4]
 8005f68:	ed93 7a00 	vldr	s14, [r3]
 8005f6c:	683b      	ldr	r3, [r7, #0]
 8005f6e:	edd3 7a00 	vldr	s15, [r3]
 8005f72:	ee77 7a67 	vsub.f32	s15, s14, s15
 8005f76:	687b      	ldr	r3, [r7, #4]
 8005f78:	edc3 7a00 	vstr	s15, [r3]
 8005f7c:	687b      	ldr	r3, [r7, #4]
 8005f7e:	ed93 7a01 	vldr	s14, [r3, #4]
 8005f82:	683b      	ldr	r3, [r7, #0]
 8005f84:	edd3 7a01 	vldr	s15, [r3, #4]
 8005f88:	ee77 7a67 	vsub.f32	s15, s14, s15
 8005f8c:	687b      	ldr	r3, [r7, #4]
 8005f8e:	edc3 7a01 	vstr	s15, [r3, #4]
 8005f92:	687b      	ldr	r3, [r7, #4]
 8005f94:	ed93 7a02 	vldr	s14, [r3, #8]
 8005f98:	683b      	ldr	r3, [r7, #0]
 8005f9a:	edd3 7a02 	vldr	s15, [r3, #8]
 8005f9e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8005fa2:	687b      	ldr	r3, [r7, #4]
 8005fa4:	edc3 7a02 	vstr	s15, [r3, #8]
 8005fa8:	687b      	ldr	r3, [r7, #4]
 8005faa:	4618      	mov	r0, r3
 8005fac:	370c      	adds	r7, #12
 8005fae:	46bd      	mov	sp, r7
 8005fb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fb4:	4770      	bx	lr
 8005fb6:	bf00      	nop

08005fb8 <_ZN7Vector3IfEpLERKS0_>:
 8005fb8:	b480      	push	{r7}
 8005fba:	b083      	sub	sp, #12
 8005fbc:	af00      	add	r7, sp, #0
 8005fbe:	6078      	str	r0, [r7, #4]
 8005fc0:	6039      	str	r1, [r7, #0]
 8005fc2:	687b      	ldr	r3, [r7, #4]
 8005fc4:	ed93 7a00 	vldr	s14, [r3]
 8005fc8:	683b      	ldr	r3, [r7, #0]
 8005fca:	edd3 7a00 	vldr	s15, [r3]
 8005fce:	ee77 7a27 	vadd.f32	s15, s14, s15
 8005fd2:	687b      	ldr	r3, [r7, #4]
 8005fd4:	edc3 7a00 	vstr	s15, [r3]
 8005fd8:	687b      	ldr	r3, [r7, #4]
 8005fda:	ed93 7a01 	vldr	s14, [r3, #4]
 8005fde:	683b      	ldr	r3, [r7, #0]
 8005fe0:	edd3 7a01 	vldr	s15, [r3, #4]
 8005fe4:	ee77 7a27 	vadd.f32	s15, s14, s15
 8005fe8:	687b      	ldr	r3, [r7, #4]
 8005fea:	edc3 7a01 	vstr	s15, [r3, #4]
 8005fee:	687b      	ldr	r3, [r7, #4]
 8005ff0:	ed93 7a02 	vldr	s14, [r3, #8]
 8005ff4:	683b      	ldr	r3, [r7, #0]
 8005ff6:	edd3 7a02 	vldr	s15, [r3, #8]
 8005ffa:	ee77 7a27 	vadd.f32	s15, s14, s15
 8005ffe:	687b      	ldr	r3, [r7, #4]
 8006000:	edc3 7a02 	vstr	s15, [r3, #8]
 8006004:	687b      	ldr	r3, [r7, #4]
 8006006:	4618      	mov	r0, r3
 8006008:	370c      	adds	r7, #12
 800600a:	46bd      	mov	sp, r7
 800600c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006010:	4770      	bx	lr
 8006012:	bf00      	nop

08006014 <_ZNK7Vector3IfEdvEf>:
 8006014:	b580      	push	{r7, lr}
 8006016:	b08c      	sub	sp, #48	; 0x30
 8006018:	af00      	add	r7, sp, #0
 800601a:	6178      	str	r0, [r7, #20]
 800601c:	ed87 0a04 	vstr	s0, [r7, #16]
 8006020:	697b      	ldr	r3, [r7, #20]
 8006022:	ed93 7a00 	vldr	s14, [r3]
 8006026:	edd7 7a04 	vldr	s15, [r7, #16]
 800602a:	eec7 6a27 	vdiv.f32	s13, s14, s15
 800602e:	697b      	ldr	r3, [r7, #20]
 8006030:	ed93 7a01 	vldr	s14, [r3, #4]
 8006034:	edd7 7a04 	vldr	s15, [r7, #16]
 8006038:	ee87 6a27 	vdiv.f32	s12, s14, s15
 800603c:	697b      	ldr	r3, [r7, #20]
 800603e:	ed93 7a02 	vldr	s14, [r3, #8]
 8006042:	edd7 7a04 	vldr	s15, [r7, #16]
 8006046:	eec7 5a27 	vdiv.f32	s11, s14, s15
 800604a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800604e:	eeb0 1a65 	vmov.f32	s2, s11
 8006052:	eef0 0a46 	vmov.f32	s1, s12
 8006056:	eeb0 0a66 	vmov.f32	s0, s13
 800605a:	4618      	mov	r0, r3
 800605c:	f000 f8de 	bl	800621c <_ZN7Vector3IfEC1Efff>
 8006060:	f107 0318 	add.w	r3, r7, #24
 8006064:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8006068:	ca07      	ldmia	r2, {r0, r1, r2}
 800606a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800606e:	69b9      	ldr	r1, [r7, #24]
 8006070:	69fa      	ldr	r2, [r7, #28]
 8006072:	6a3b      	ldr	r3, [r7, #32]
 8006074:	ee06 1a90 	vmov	s13, r1
 8006078:	ee07 2a10 	vmov	s14, r2
 800607c:	ee07 3a90 	vmov	s15, r3
 8006080:	eeb0 0a66 	vmov.f32	s0, s13
 8006084:	eef0 0a47 	vmov.f32	s1, s14
 8006088:	eeb0 1a67 	vmov.f32	s2, s15
 800608c:	3730      	adds	r7, #48	; 0x30
 800608e:	46bd      	mov	sp, r7
 8006090:	bd80      	pop	{r7, pc}
 8006092:	bf00      	nop

08006094 <_ZNK7Vector3IfEmlEf>:
 8006094:	b580      	push	{r7, lr}
 8006096:	b08c      	sub	sp, #48	; 0x30
 8006098:	af00      	add	r7, sp, #0
 800609a:	6178      	str	r0, [r7, #20]
 800609c:	ed87 0a04 	vstr	s0, [r7, #16]
 80060a0:	697b      	ldr	r3, [r7, #20]
 80060a2:	ed93 7a00 	vldr	s14, [r3]
 80060a6:	edd7 7a04 	vldr	s15, [r7, #16]
 80060aa:	ee67 6a27 	vmul.f32	s13, s14, s15
 80060ae:	697b      	ldr	r3, [r7, #20]
 80060b0:	ed93 7a01 	vldr	s14, [r3, #4]
 80060b4:	edd7 7a04 	vldr	s15, [r7, #16]
 80060b8:	ee27 6a27 	vmul.f32	s12, s14, s15
 80060bc:	697b      	ldr	r3, [r7, #20]
 80060be:	ed93 7a02 	vldr	s14, [r3, #8]
 80060c2:	edd7 7a04 	vldr	s15, [r7, #16]
 80060c6:	ee67 7a27 	vmul.f32	s15, s14, s15
 80060ca:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80060ce:	eeb0 1a67 	vmov.f32	s2, s15
 80060d2:	eef0 0a46 	vmov.f32	s1, s12
 80060d6:	eeb0 0a66 	vmov.f32	s0, s13
 80060da:	4618      	mov	r0, r3
 80060dc:	f000 f89e 	bl	800621c <_ZN7Vector3IfEC1Efff>
 80060e0:	f107 0318 	add.w	r3, r7, #24
 80060e4:	f107 0224 	add.w	r2, r7, #36	; 0x24
 80060e8:	ca07      	ldmia	r2, {r0, r1, r2}
 80060ea:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 80060ee:	69b9      	ldr	r1, [r7, #24]
 80060f0:	69fa      	ldr	r2, [r7, #28]
 80060f2:	6a3b      	ldr	r3, [r7, #32]
 80060f4:	ee06 1a90 	vmov	s13, r1
 80060f8:	ee07 2a10 	vmov	s14, r2
 80060fc:	ee07 3a90 	vmov	s15, r3
 8006100:	eeb0 0a66 	vmov.f32	s0, s13
 8006104:	eef0 0a47 	vmov.f32	s1, s14
 8006108:	eeb0 1a67 	vmov.f32	s2, s15
 800610c:	3730      	adds	r7, #48	; 0x30
 800610e:	46bd      	mov	sp, r7
 8006110:	bd80      	pop	{r7, pc}
 8006112:	bf00      	nop

08006114 <_ZNK7Vector3IfEplERKS0_>:
 8006114:	b580      	push	{r7, lr}
 8006116:	b08c      	sub	sp, #48	; 0x30
 8006118:	af00      	add	r7, sp, #0
 800611a:	6178      	str	r0, [r7, #20]
 800611c:	6139      	str	r1, [r7, #16]
 800611e:	697b      	ldr	r3, [r7, #20]
 8006120:	ed93 7a00 	vldr	s14, [r3]
 8006124:	693b      	ldr	r3, [r7, #16]
 8006126:	edd3 7a00 	vldr	s15, [r3]
 800612a:	ee77 6a27 	vadd.f32	s13, s14, s15
 800612e:	697b      	ldr	r3, [r7, #20]
 8006130:	ed93 7a01 	vldr	s14, [r3, #4]
 8006134:	693b      	ldr	r3, [r7, #16]
 8006136:	edd3 7a01 	vldr	s15, [r3, #4]
 800613a:	ee37 6a27 	vadd.f32	s12, s14, s15
 800613e:	697b      	ldr	r3, [r7, #20]
 8006140:	ed93 7a02 	vldr	s14, [r3, #8]
 8006144:	693b      	ldr	r3, [r7, #16]
 8006146:	edd3 7a02 	vldr	s15, [r3, #8]
 800614a:	ee77 7a27 	vadd.f32	s15, s14, s15
 800614e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8006152:	eeb0 1a67 	vmov.f32	s2, s15
 8006156:	eef0 0a46 	vmov.f32	s1, s12
 800615a:	eeb0 0a66 	vmov.f32	s0, s13
 800615e:	4618      	mov	r0, r3
 8006160:	f000 f85c 	bl	800621c <_ZN7Vector3IfEC1Efff>
 8006164:	f107 0318 	add.w	r3, r7, #24
 8006168:	f107 0224 	add.w	r2, r7, #36	; 0x24
 800616c:	ca07      	ldmia	r2, {r0, r1, r2}
 800616e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8006172:	69b9      	ldr	r1, [r7, #24]
 8006174:	69fa      	ldr	r2, [r7, #28]
 8006176:	6a3b      	ldr	r3, [r7, #32]
 8006178:	ee06 1a90 	vmov	s13, r1
 800617c:	ee07 2a10 	vmov	s14, r2
 8006180:	ee07 3a90 	vmov	s15, r3
 8006184:	eeb0 0a66 	vmov.f32	s0, s13
 8006188:	eef0 0a47 	vmov.f32	s1, s14
 800618c:	eeb0 1a67 	vmov.f32	s2, s15
 8006190:	3730      	adds	r7, #48	; 0x30
 8006192:	46bd      	mov	sp, r7
 8006194:	bd80      	pop	{r7, pc}
 8006196:	bf00      	nop

08006198 <_ZNK7Vector3IfEmiERKS0_>:
 8006198:	b580      	push	{r7, lr}
 800619a:	b08c      	sub	sp, #48	; 0x30
 800619c:	af00      	add	r7, sp, #0
 800619e:	6178      	str	r0, [r7, #20]
 80061a0:	6139      	str	r1, [r7, #16]
 80061a2:	697b      	ldr	r3, [r7, #20]
 80061a4:	ed93 7a00 	vldr	s14, [r3]
 80061a8:	693b      	ldr	r3, [r7, #16]
 80061aa:	edd3 7a00 	vldr	s15, [r3]
 80061ae:	ee77 6a67 	vsub.f32	s13, s14, s15
 80061b2:	697b      	ldr	r3, [r7, #20]
 80061b4:	ed93 7a01 	vldr	s14, [r3, #4]
 80061b8:	693b      	ldr	r3, [r7, #16]
 80061ba:	edd3 7a01 	vldr	s15, [r3, #4]
 80061be:	ee37 6a67 	vsub.f32	s12, s14, s15
 80061c2:	697b      	ldr	r3, [r7, #20]
 80061c4:	ed93 7a02 	vldr	s14, [r3, #8]
 80061c8:	693b      	ldr	r3, [r7, #16]
 80061ca:	edd3 7a02 	vldr	s15, [r3, #8]
 80061ce:	ee77 7a67 	vsub.f32	s15, s14, s15
 80061d2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80061d6:	eeb0 1a67 	vmov.f32	s2, s15
 80061da:	eef0 0a46 	vmov.f32	s1, s12
 80061de:	eeb0 0a66 	vmov.f32	s0, s13
 80061e2:	4618      	mov	r0, r3
 80061e4:	f000 f81a 	bl	800621c <_ZN7Vector3IfEC1Efff>
 80061e8:	f107 0318 	add.w	r3, r7, #24
 80061ec:	f107 0224 	add.w	r2, r7, #36	; 0x24
 80061f0:	ca07      	ldmia	r2, {r0, r1, r2}
 80061f2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 80061f6:	69b9      	ldr	r1, [r7, #24]
 80061f8:	69fa      	ldr	r2, [r7, #28]
 80061fa:	6a3b      	ldr	r3, [r7, #32]
 80061fc:	ee06 1a90 	vmov	s13, r1
 8006200:	ee07 2a10 	vmov	s14, r2
 8006204:	ee07 3a90 	vmov	s15, r3
 8006208:	eeb0 0a66 	vmov.f32	s0, s13
 800620c:	eef0 0a47 	vmov.f32	s1, s14
 8006210:	eeb0 1a67 	vmov.f32	s2, s15
 8006214:	3730      	adds	r7, #48	; 0x30
 8006216:	46bd      	mov	sp, r7
 8006218:	bd80      	pop	{r7, pc}
 800621a:	bf00      	nop

0800621c <_ZN7Vector3IfEC1Efff>:
 800621c:	b480      	push	{r7}
 800621e:	b085      	sub	sp, #20
 8006220:	af00      	add	r7, sp, #0
 8006222:	60f8      	str	r0, [r7, #12]
 8006224:	ed87 0a02 	vstr	s0, [r7, #8]
 8006228:	edc7 0a01 	vstr	s1, [r7, #4]
 800622c:	ed87 1a00 	vstr	s2, [r7]
 8006230:	68fb      	ldr	r3, [r7, #12]
 8006232:	68ba      	ldr	r2, [r7, #8]
 8006234:	601a      	str	r2, [r3, #0]
 8006236:	68fb      	ldr	r3, [r7, #12]
 8006238:	687a      	ldr	r2, [r7, #4]
 800623a:	605a      	str	r2, [r3, #4]
 800623c:	68fb      	ldr	r3, [r7, #12]
 800623e:	683a      	ldr	r2, [r7, #0]
 8006240:	609a      	str	r2, [r3, #8]
 8006242:	68fb      	ldr	r3, [r7, #12]
 8006244:	4618      	mov	r0, r3
 8006246:	3714      	adds	r7, #20
 8006248:	46bd      	mov	sp, r7
 800624a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800624e:	4770      	bx	lr

08006250 <_ZN7Matrix3IfE10from_eulerEfff>:
 8006250:	b580      	push	{r7, lr}
 8006252:	b08a      	sub	sp, #40	; 0x28
 8006254:	af00      	add	r7, sp, #0
 8006256:	60f8      	str	r0, [r7, #12]
 8006258:	ed87 0a02 	vstr	s0, [r7, #8]
 800625c:	edc7 0a01 	vstr	s1, [r7, #4]
 8006260:	ed87 1a00 	vstr	s2, [r7]
 8006264:	ed97 0a01 	vldr	s0, [r7, #4]
 8006268:	f000 fe8c 	bl	8006f84 <cosf>
 800626c:	ed87 0a09 	vstr	s0, [r7, #36]	; 0x24
 8006270:	ed97 0a01 	vldr	s0, [r7, #4]
 8006274:	f000 fec6 	bl	8007004 <sinf>
 8006278:	ed87 0a08 	vstr	s0, [r7, #32]
 800627c:	ed97 0a02 	vldr	s0, [r7, #8]
 8006280:	f000 fec0 	bl	8007004 <sinf>
 8006284:	ed87 0a07 	vstr	s0, [r7, #28]
 8006288:	ed97 0a02 	vldr	s0, [r7, #8]
 800628c:	f000 fe7a 	bl	8006f84 <cosf>
 8006290:	ed87 0a06 	vstr	s0, [r7, #24]
 8006294:	ed97 0a00 	vldr	s0, [r7]
 8006298:	f000 feb4 	bl	8007004 <sinf>
 800629c:	ed87 0a05 	vstr	s0, [r7, #20]
 80062a0:	ed97 0a00 	vldr	s0, [r7]
 80062a4:	f000 fe6e 	bl	8006f84 <cosf>
 80062a8:	ed87 0a04 	vstr	s0, [r7, #16]
 80062ac:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 80062b0:	edd7 7a04 	vldr	s15, [r7, #16]
 80062b4:	ee67 7a27 	vmul.f32	s15, s14, s15
 80062b8:	68fb      	ldr	r3, [r7, #12]
 80062ba:	edc3 7a00 	vstr	s15, [r3]
 80062be:	ed97 7a07 	vldr	s14, [r7, #28]
 80062c2:	edd7 7a08 	vldr	s15, [r7, #32]
 80062c6:	ee27 7a27 	vmul.f32	s14, s14, s15
 80062ca:	edd7 7a04 	vldr	s15, [r7, #16]
 80062ce:	ee27 7a27 	vmul.f32	s14, s14, s15
 80062d2:	edd7 6a06 	vldr	s13, [r7, #24]
 80062d6:	edd7 7a05 	vldr	s15, [r7, #20]
 80062da:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80062de:	ee77 7a67 	vsub.f32	s15, s14, s15
 80062e2:	68fb      	ldr	r3, [r7, #12]
 80062e4:	edc3 7a01 	vstr	s15, [r3, #4]
 80062e8:	ed97 7a06 	vldr	s14, [r7, #24]
 80062ec:	edd7 7a08 	vldr	s15, [r7, #32]
 80062f0:	ee27 7a27 	vmul.f32	s14, s14, s15
 80062f4:	edd7 7a04 	vldr	s15, [r7, #16]
 80062f8:	ee27 7a27 	vmul.f32	s14, s14, s15
 80062fc:	edd7 6a07 	vldr	s13, [r7, #28]
 8006300:	edd7 7a05 	vldr	s15, [r7, #20]
 8006304:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8006308:	ee77 7a27 	vadd.f32	s15, s14, s15
 800630c:	68fb      	ldr	r3, [r7, #12]
 800630e:	edc3 7a02 	vstr	s15, [r3, #8]
 8006312:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
 8006316:	edd7 7a05 	vldr	s15, [r7, #20]
 800631a:	ee67 7a27 	vmul.f32	s15, s14, s15
 800631e:	68fb      	ldr	r3, [r7, #12]
 8006320:	edc3 7a03 	vstr	s15, [r3, #12]
 8006324:	ed97 7a07 	vldr	s14, [r7, #28]
 8006328:	edd7 7a08 	vldr	s15, [r7, #32]
 800632c:	ee27 7a27 	vmul.f32	s14, s14, s15
 8006330:	edd7 7a05 	vldr	s15, [r7, #20]
 8006334:	ee27 7a27 	vmul.f32	s14, s14, s15
 8006338:	edd7 6a06 	vldr	s13, [r7, #24]
 800633c:	edd7 7a04 	vldr	s15, [r7, #16]
 8006340:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8006344:	ee77 7a27 	vadd.f32	s15, s14, s15
 8006348:	68fb      	ldr	r3, [r7, #12]
 800634a:	edc3 7a04 	vstr	s15, [r3, #16]
 800634e:	ed97 7a06 	vldr	s14, [r7, #24]
 8006352:	edd7 7a08 	vldr	s15, [r7, #32]
 8006356:	ee27 7a27 	vmul.f32	s14, s14, s15
 800635a:	edd7 7a05 	vldr	s15, [r7, #20]
 800635e:	ee27 7a27 	vmul.f32	s14, s14, s15
 8006362:	edd7 6a07 	vldr	s13, [r7, #28]
 8006366:	edd7 7a04 	vldr	s15, [r7, #16]
 800636a:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800636e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8006372:	68fb      	ldr	r3, [r7, #12]
 8006374:	edc3 7a05 	vstr	s15, [r3, #20]
 8006378:	edd7 7a08 	vldr	s15, [r7, #32]
 800637c:	eef1 7a67 	vneg.f32	s15, s15
 8006380:	68fb      	ldr	r3, [r7, #12]
 8006382:	edc3 7a06 	vstr	s15, [r3, #24]
 8006386:	ed97 7a07 	vldr	s14, [r7, #28]
 800638a:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 800638e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8006392:	68fb      	ldr	r3, [r7, #12]
 8006394:	edc3 7a07 	vstr	s15, [r3, #28]
 8006398:	ed97 7a06 	vldr	s14, [r7, #24]
 800639c:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
 80063a0:	ee67 7a27 	vmul.f32	s15, s14, s15
 80063a4:	68fb      	ldr	r3, [r7, #12]
 80063a6:	edc3 7a08 	vstr	s15, [r3, #32]
 80063aa:	bf00      	nop
 80063ac:	3728      	adds	r7, #40	; 0x28
 80063ae:	46bd      	mov	sp, r7
 80063b0:	bd80      	pop	{r7, pc}
 80063b2:	bf00      	nop

080063b4 <_ZNK7Matrix3IfEmlERK7Vector3IfE>:
 80063b4:	b580      	push	{r7, lr}
 80063b6:	b08c      	sub	sp, #48	; 0x30
 80063b8:	af00      	add	r7, sp, #0
 80063ba:	6178      	str	r0, [r7, #20]
 80063bc:	6139      	str	r1, [r7, #16]
 80063be:	697b      	ldr	r3, [r7, #20]
 80063c0:	ed93 7a00 	vldr	s14, [r3]
 80063c4:	693b      	ldr	r3, [r7, #16]
 80063c6:	edd3 7a00 	vldr	s15, [r3]
 80063ca:	ee27 7a27 	vmul.f32	s14, s14, s15
 80063ce:	697b      	ldr	r3, [r7, #20]
 80063d0:	edd3 6a01 	vldr	s13, [r3, #4]
 80063d4:	693b      	ldr	r3, [r7, #16]
 80063d6:	edd3 7a01 	vldr	s15, [r3, #4]
 80063da:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80063de:	ee37 7a27 	vadd.f32	s14, s14, s15
 80063e2:	697b      	ldr	r3, [r7, #20]
 80063e4:	edd3 6a02 	vldr	s13, [r3, #8]
 80063e8:	693b      	ldr	r3, [r7, #16]
 80063ea:	edd3 7a02 	vldr	s15, [r3, #8]
 80063ee:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80063f2:	ee37 6a27 	vadd.f32	s12, s14, s15
 80063f6:	697b      	ldr	r3, [r7, #20]
 80063f8:	ed93 7a03 	vldr	s14, [r3, #12]
 80063fc:	693b      	ldr	r3, [r7, #16]
 80063fe:	edd3 7a00 	vldr	s15, [r3]
 8006402:	ee27 7a27 	vmul.f32	s14, s14, s15
 8006406:	697b      	ldr	r3, [r7, #20]
 8006408:	edd3 6a04 	vldr	s13, [r3, #16]
 800640c:	693b      	ldr	r3, [r7, #16]
 800640e:	edd3 7a01 	vldr	s15, [r3, #4]
 8006412:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8006416:	ee37 7a27 	vadd.f32	s14, s14, s15
 800641a:	697b      	ldr	r3, [r7, #20]
 800641c:	edd3 6a05 	vldr	s13, [r3, #20]
 8006420:	693b      	ldr	r3, [r7, #16]
 8006422:	edd3 7a02 	vldr	s15, [r3, #8]
 8006426:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800642a:	ee77 5a27 	vadd.f32	s11, s14, s15
 800642e:	697b      	ldr	r3, [r7, #20]
 8006430:	ed93 7a06 	vldr	s14, [r3, #24]
 8006434:	693b      	ldr	r3, [r7, #16]
 8006436:	edd3 7a00 	vldr	s15, [r3]
 800643a:	ee27 7a27 	vmul.f32	s14, s14, s15
 800643e:	697b      	ldr	r3, [r7, #20]
 8006440:	edd3 6a07 	vldr	s13, [r3, #28]
 8006444:	693b      	ldr	r3, [r7, #16]
 8006446:	edd3 7a01 	vldr	s15, [r3, #4]
 800644a:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800644e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8006452:	697b      	ldr	r3, [r7, #20]
 8006454:	edd3 6a08 	vldr	s13, [r3, #32]
 8006458:	693b      	ldr	r3, [r7, #16]
 800645a:	edd3 7a02 	vldr	s15, [r3, #8]
 800645e:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8006462:	ee77 7a27 	vadd.f32	s15, s14, s15
 8006466:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800646a:	eeb0 1a67 	vmov.f32	s2, s15
 800646e:	eef0 0a65 	vmov.f32	s1, s11
 8006472:	eeb0 0a46 	vmov.f32	s0, s12
 8006476:	4618      	mov	r0, r3
 8006478:	f7ff fed0 	bl	800621c <_ZN7Vector3IfEC1Efff>
 800647c:	f107 0318 	add.w	r3, r7, #24
 8006480:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8006484:	ca07      	ldmia	r2, {r0, r1, r2}
 8006486:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800648a:	69b9      	ldr	r1, [r7, #24]
 800648c:	69fa      	ldr	r2, [r7, #28]
 800648e:	6a3b      	ldr	r3, [r7, #32]
 8006490:	ee06 1a90 	vmov	s13, r1
 8006494:	ee07 2a10 	vmov	s14, r2
 8006498:	ee07 3a90 	vmov	s15, r3
 800649c:	eeb0 0a66 	vmov.f32	s0, s13
 80064a0:	eef0 0a47 	vmov.f32	s1, s14
 80064a4:	eeb0 1a67 	vmov.f32	s2, s15
 80064a8:	3730      	adds	r7, #48	; 0x30
 80064aa:	46bd      	mov	sp, r7
 80064ac:	bd80      	pop	{r7, pc}
 80064ae:	bf00      	nop

080064b0 <_Z8inv_sqrtf>:
 80064b0:	b480      	push	{r7}
 80064b2:	b087      	sub	sp, #28
 80064b4:	af00      	add	r7, sp, #0
 80064b6:	ed87 0a01 	vstr	s0, [r7, #4]
 80064ba:	edd7 7a01 	vldr	s15, [r7, #4]
 80064be:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 80064c2:	ee67 7a87 	vmul.f32	s15, s15, s14
 80064c6:	edc7 7a05 	vstr	s15, [r7, #20]
 80064ca:	687b      	ldr	r3, [r7, #4]
 80064cc:	613b      	str	r3, [r7, #16]
 80064ce:	f107 0310 	add.w	r3, r7, #16
 80064d2:	681b      	ldr	r3, [r3, #0]
 80064d4:	60fb      	str	r3, [r7, #12]
 80064d6:	68fb      	ldr	r3, [r7, #12]
 80064d8:	105a      	asrs	r2, r3, #1
 80064da:	4b12      	ldr	r3, [pc, #72]	; (8006524 <_Z8inv_sqrtf+0x74>)
 80064dc:	1a9b      	subs	r3, r3, r2
 80064de:	60fb      	str	r3, [r7, #12]
 80064e0:	f107 030c 	add.w	r3, r7, #12
 80064e4:	681b      	ldr	r3, [r3, #0]
 80064e6:	613b      	str	r3, [r7, #16]
 80064e8:	ed97 7a04 	vldr	s14, [r7, #16]
 80064ec:	edd7 7a05 	vldr	s15, [r7, #20]
 80064f0:	ee27 7a27 	vmul.f32	s14, s14, s15
 80064f4:	edd7 7a04 	vldr	s15, [r7, #16]
 80064f8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80064fc:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
 8006500:	ee37 7a67 	vsub.f32	s14, s14, s15
 8006504:	edd7 7a04 	vldr	s15, [r7, #16]
 8006508:	ee67 7a27 	vmul.f32	s15, s14, s15
 800650c:	edc7 7a04 	vstr	s15, [r7, #16]
 8006510:	693b      	ldr	r3, [r7, #16]
 8006512:	ee07 3a90 	vmov	s15, r3
 8006516:	eeb0 0a67 	vmov.f32	s0, s15
 800651a:	371c      	adds	r7, #28
 800651c:	46bd      	mov	sp, r7
 800651e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006522:	4770      	bx	lr
 8006524:	5f3759df 	.word	0x5f3759df

08006528 <__cxa_end_cleanup>:
 8006528:	b41e      	push	{r1, r2, r3, r4}
 800652a:	f000 f89c 	bl	8006666 <__gnu_end_cleanup>
 800652e:	bc1e      	pop	{r1, r2, r3, r4}
 8006530:	f7fa fd82 	bl	8001038 <_Unwind_Resume>

08006534 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>:
 8006534:	7803      	ldrb	r3, [r0, #0]
 8006536:	2b47      	cmp	r3, #71	; 0x47
 8006538:	d117      	bne.n	800656a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800653a:	7843      	ldrb	r3, [r0, #1]
 800653c:	2b4e      	cmp	r3, #78	; 0x4e
 800653e:	d114      	bne.n	800656a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006540:	7883      	ldrb	r3, [r0, #2]
 8006542:	2b55      	cmp	r3, #85	; 0x55
 8006544:	d111      	bne.n	800656a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006546:	78c3      	ldrb	r3, [r0, #3]
 8006548:	2b43      	cmp	r3, #67	; 0x43
 800654a:	d10e      	bne.n	800656a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800654c:	7903      	ldrb	r3, [r0, #4]
 800654e:	2b43      	cmp	r3, #67	; 0x43
 8006550:	d10b      	bne.n	800656a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006552:	7943      	ldrb	r3, [r0, #5]
 8006554:	2b2b      	cmp	r3, #43	; 0x2b
 8006556:	d108      	bne.n	800656a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006558:	7983      	ldrb	r3, [r0, #6]
 800655a:	2b2b      	cmp	r3, #43	; 0x2b
 800655c:	d105      	bne.n	800656a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 800655e:	79c0      	ldrb	r0, [r0, #7]
 8006560:	2801      	cmp	r0, #1
 8006562:	bf8c      	ite	hi
 8006564:	2000      	movhi	r0, #0
 8006566:	2001      	movls	r0, #1
 8006568:	4770      	bx	lr
 800656a:	2000      	movs	r0, #0
 800656c:	4770      	bx	lr
	...

08006570 <__cxa_type_match>:
 8006570:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8006574:	461d      	mov	r5, r3
 8006576:	7803      	ldrb	r3, [r0, #0]
 8006578:	2b47      	cmp	r3, #71	; 0x47
 800657a:	460e      	mov	r6, r1
 800657c:	4602      	mov	r2, r0
 800657e:	79c1      	ldrb	r1, [r0, #7]
 8006580:	d144      	bne.n	800660c <__cxa_type_match+0x9c>
 8006582:	7843      	ldrb	r3, [r0, #1]
 8006584:	2b4e      	cmp	r3, #78	; 0x4e
 8006586:	d141      	bne.n	800660c <__cxa_type_match+0x9c>
 8006588:	7883      	ldrb	r3, [r0, #2]
 800658a:	2b55      	cmp	r3, #85	; 0x55
 800658c:	d13e      	bne.n	800660c <__cxa_type_match+0x9c>
 800658e:	78c3      	ldrb	r3, [r0, #3]
 8006590:	2b43      	cmp	r3, #67	; 0x43
 8006592:	d13b      	bne.n	800660c <__cxa_type_match+0x9c>
 8006594:	7903      	ldrb	r3, [r0, #4]
 8006596:	2b46      	cmp	r3, #70	; 0x46
 8006598:	d138      	bne.n	800660c <__cxa_type_match+0x9c>
 800659a:	7943      	ldrb	r3, [r0, #5]
 800659c:	2b4f      	cmp	r3, #79	; 0x4f
 800659e:	d135      	bne.n	800660c <__cxa_type_match+0x9c>
 80065a0:	7983      	ldrb	r3, [r0, #6]
 80065a2:	2b52      	cmp	r3, #82	; 0x52
 80065a4:	d132      	bne.n	800660c <__cxa_type_match+0x9c>
 80065a6:	2900      	cmp	r1, #0
 80065a8:	d130      	bne.n	800660c <__cxa_type_match+0x9c>
 80065aa:	2301      	movs	r3, #1
 80065ac:	4608      	mov	r0, r1
 80065ae:	2400      	movs	r4, #0
 80065b0:	9401      	str	r4, [sp, #4]
 80065b2:	b983      	cbnz	r3, 80065d6 <__cxa_type_match+0x66>
 80065b4:	b988      	cbnz	r0, 80065da <__cxa_type_match+0x6a>
 80065b6:	2901      	cmp	r1, #1
 80065b8:	bf0a      	itet	eq
 80065ba:	f852 3c20 	ldreq.w	r3, [r2, #-32]
 80065be:	f1a2 0320 	subne.w	r3, r2, #32
 80065c2:	3b78      	subeq	r3, #120	; 0x78
 80065c4:	2901      	cmp	r1, #1
 80065c6:	bf08      	it	eq
 80065c8:	f852 2c20 	ldreq.w	r2, [r2, #-32]
 80065cc:	681c      	ldr	r4, [r3, #0]
 80065ce:	bf18      	it	ne
 80065d0:	3258      	addne	r2, #88	; 0x58
 80065d2:	9201      	str	r2, [sp, #4]
 80065d4:	e002      	b.n	80065dc <__cxa_type_match+0x6c>
 80065d6:	4c13      	ldr	r4, [pc, #76]	; (8006624 <__cxa_type_match+0xb4>)
 80065d8:	e000      	b.n	80065dc <__cxa_type_match+0x6c>
 80065da:	4c13      	ldr	r4, [pc, #76]	; (8006628 <__cxa_type_match+0xb8>)
 80065dc:	6823      	ldr	r3, [r4, #0]
 80065de:	4620      	mov	r0, r4
 80065e0:	689b      	ldr	r3, [r3, #8]
 80065e2:	4798      	blx	r3
 80065e4:	b120      	cbz	r0, 80065f0 <__cxa_type_match+0x80>
 80065e6:	9b01      	ldr	r3, [sp, #4]
 80065e8:	681b      	ldr	r3, [r3, #0]
 80065ea:	9301      	str	r3, [sp, #4]
 80065ec:	2702      	movs	r7, #2
 80065ee:	e000      	b.n	80065f2 <__cxa_type_match+0x82>
 80065f0:	2701      	movs	r7, #1
 80065f2:	6833      	ldr	r3, [r6, #0]
 80065f4:	aa01      	add	r2, sp, #4
 80065f6:	f8d3 8010 	ldr.w	r8, [r3, #16]
 80065fa:	4621      	mov	r1, r4
 80065fc:	2301      	movs	r3, #1
 80065fe:	4630      	mov	r0, r6
 8006600:	47c0      	blx	r8
 8006602:	b158      	cbz	r0, 800661c <__cxa_type_match+0xac>
 8006604:	9b01      	ldr	r3, [sp, #4]
 8006606:	602b      	str	r3, [r5, #0]
 8006608:	4638      	mov	r0, r7
 800660a:	e007      	b.n	800661c <__cxa_type_match+0xac>
 800660c:	4610      	mov	r0, r2
 800660e:	f7ff ff91 	bl	8006534 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 8006612:	f080 0001 	eor.w	r0, r0, #1
 8006616:	b2c0      	uxtb	r0, r0
 8006618:	2300      	movs	r3, #0
 800661a:	e7c8      	b.n	80065ae <__cxa_type_match+0x3e>
 800661c:	b002      	add	sp, #8
 800661e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006622:	bf00      	nop
 8006624:	08009260 	.word	0x08009260
 8006628:	0800928c 	.word	0x0800928c

0800662c <__cxa_begin_cleanup>:
 800662c:	b510      	push	{r4, lr}
 800662e:	4604      	mov	r4, r0
 8006630:	f000 fb4e 	bl	8006cd0 <__cxa_get_globals>
 8006634:	4602      	mov	r2, r0
 8006636:	4620      	mov	r0, r4
 8006638:	f1a4 0120 	sub.w	r1, r4, #32
 800663c:	f7ff ff7a 	bl	8006534 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 8006640:	b150      	cbz	r0, 8006658 <__cxa_begin_cleanup+0x2c>
 8006642:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8006646:	3301      	adds	r3, #1
 8006648:	2b01      	cmp	r3, #1
 800664a:	f844 3c04 	str.w	r3, [r4, #-4]
 800664e:	d108      	bne.n	8006662 <__cxa_begin_cleanup+0x36>
 8006650:	6893      	ldr	r3, [r2, #8]
 8006652:	f844 3c08 	str.w	r3, [r4, #-8]
 8006656:	e003      	b.n	8006660 <__cxa_begin_cleanup+0x34>
 8006658:	6893      	ldr	r3, [r2, #8]
 800665a:	b10b      	cbz	r3, 8006660 <__cxa_begin_cleanup+0x34>
 800665c:	f000 fb48 	bl	8006cf0 <_ZSt9terminatev>
 8006660:	6091      	str	r1, [r2, #8]
 8006662:	2001      	movs	r0, #1
 8006664:	bd10      	pop	{r4, pc}

08006666 <__gnu_end_cleanup>:
 8006666:	b510      	push	{r4, lr}
 8006668:	f000 fb32 	bl	8006cd0 <__cxa_get_globals>
 800666c:	6882      	ldr	r2, [r0, #8]
 800666e:	4601      	mov	r1, r0
 8006670:	b90a      	cbnz	r2, 8006676 <__gnu_end_cleanup+0x10>
 8006672:	f000 fb3d 	bl	8006cf0 <_ZSt9terminatev>
 8006676:	f102 0420 	add.w	r4, r2, #32
 800667a:	4620      	mov	r0, r4
 800667c:	f7ff ff5a 	bl	8006534 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 8006680:	b138      	cbz	r0, 8006692 <__gnu_end_cleanup+0x2c>
 8006682:	69d3      	ldr	r3, [r2, #28]
 8006684:	3b01      	subs	r3, #1
 8006686:	61d3      	str	r3, [r2, #28]
 8006688:	b923      	cbnz	r3, 8006694 <__gnu_end_cleanup+0x2e>
 800668a:	6990      	ldr	r0, [r2, #24]
 800668c:	6088      	str	r0, [r1, #8]
 800668e:	6193      	str	r3, [r2, #24]
 8006690:	e000      	b.n	8006694 <__gnu_end_cleanup+0x2e>
 8006692:	6088      	str	r0, [r1, #8]
 8006694:	4620      	mov	r0, r4
 8006696:	bd10      	pop	{r4, pc}

08006698 <_ZL12read_uleb128PKhPm>:
 8006698:	b570      	push	{r4, r5, r6, lr}
 800669a:	2300      	movs	r3, #0
 800669c:	eba0 06c0 	sub.w	r6, r0, r0, lsl #3
 80066a0:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
 80066a4:	f810 5b01 	ldrb.w	r5, [r0], #1
 80066a8:	1994      	adds	r4, r2, r6
 80066aa:	f005 027f 	and.w	r2, r5, #127	; 0x7f
 80066ae:	40a2      	lsls	r2, r4
 80066b0:	4313      	orrs	r3, r2
 80066b2:	062a      	lsls	r2, r5, #24
 80066b4:	d4f4      	bmi.n	80066a0 <_ZL12read_uleb128PKhPm+0x8>
 80066b6:	600b      	str	r3, [r1, #0]
 80066b8:	bd70      	pop	{r4, r5, r6, pc}

080066ba <_ZL12read_sleb128PKhPl>:
 80066ba:	b530      	push	{r4, r5, lr}
 80066bc:	2300      	movs	r3, #0
 80066be:	461a      	mov	r2, r3
 80066c0:	f810 4b01 	ldrb.w	r4, [r0], #1
 80066c4:	f004 057f 	and.w	r5, r4, #127	; 0x7f
 80066c8:	4095      	lsls	r5, r2
 80066ca:	432b      	orrs	r3, r5
 80066cc:	0625      	lsls	r5, r4, #24
 80066ce:	f102 0207 	add.w	r2, r2, #7
 80066d2:	d4f5      	bmi.n	80066c0 <_ZL12read_sleb128PKhPl+0x6>
 80066d4:	2a1f      	cmp	r2, #31
 80066d6:	d806      	bhi.n	80066e6 <_ZL12read_sleb128PKhPl+0x2c>
 80066d8:	0664      	lsls	r4, r4, #25
 80066da:	bf42      	ittt	mi
 80066dc:	f04f 34ff 	movmi.w	r4, #4294967295
 80066e0:	fa04 f202 	lslmi.w	r2, r4, r2
 80066e4:	4313      	orrmi	r3, r2
 80066e6:	600b      	str	r3, [r1, #0]
 80066e8:	bd30      	pop	{r4, r5, pc}

080066ea <_ZL28read_encoded_value_with_basehjPKhPj>:
 80066ea:	2850      	cmp	r0, #80	; 0x50
 80066ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80066ee:	4605      	mov	r5, r0
 80066f0:	460f      	mov	r7, r1
 80066f2:	4614      	mov	r4, r2
 80066f4:	461e      	mov	r6, r3
 80066f6:	d105      	bne.n	8006704 <_ZL28read_encoded_value_with_basehjPKhPj+0x1a>
 80066f8:	1cd0      	adds	r0, r2, #3
 80066fa:	f020 0003 	bic.w	r0, r0, #3
 80066fe:	f850 3b04 	ldr.w	r3, [r0], #4
 8006702:	e033      	b.n	800676c <_ZL28read_encoded_value_with_basehjPKhPj+0x82>
 8006704:	f000 030f 	and.w	r3, r0, #15
 8006708:	2b0c      	cmp	r3, #12
 800670a:	d823      	bhi.n	8006754 <_ZL28read_encoded_value_with_basehjPKhPj+0x6a>
 800670c:	e8df f003 	tbb	[pc, r3]
 8006710:	1a12071a 	.word	0x1a12071a
 8006714:	2222221e 	.word	0x2222221e
 8006718:	1a160c22 	.word	0x1a160c22
 800671c:	1e          	.byte	0x1e
 800671d:	00          	.byte	0x00
 800671e:	a901      	add	r1, sp, #4
 8006720:	4620      	mov	r0, r4
 8006722:	f7ff ffb9 	bl	8006698 <_ZL12read_uleb128PKhPm>
 8006726:	e003      	b.n	8006730 <_ZL28read_encoded_value_with_basehjPKhPj+0x46>
 8006728:	a901      	add	r1, sp, #4
 800672a:	4620      	mov	r0, r4
 800672c:	f7ff ffc5 	bl	80066ba <_ZL12read_sleb128PKhPl>
 8006730:	9b01      	ldr	r3, [sp, #4]
 8006732:	e011      	b.n	8006758 <_ZL28read_encoded_value_with_basehjPKhPj+0x6e>
 8006734:	4620      	mov	r0, r4
 8006736:	f830 3b02 	ldrh.w	r3, [r0], #2
 800673a:	e00d      	b.n	8006758 <_ZL28read_encoded_value_with_basehjPKhPj+0x6e>
 800673c:	4620      	mov	r0, r4
 800673e:	f930 3b02 	ldrsh.w	r3, [r0], #2
 8006742:	e009      	b.n	8006758 <_ZL28read_encoded_value_with_basehjPKhPj+0x6e>
 8006744:	4620      	mov	r0, r4
 8006746:	f850 3b04 	ldr.w	r3, [r0], #4
 800674a:	e005      	b.n	8006758 <_ZL28read_encoded_value_with_basehjPKhPj+0x6e>
 800674c:	4620      	mov	r0, r4
 800674e:	f850 3b08 	ldr.w	r3, [r0], #8
 8006752:	e001      	b.n	8006758 <_ZL28read_encoded_value_with_basehjPKhPj+0x6e>
 8006754:	f001 fb04 	bl	8007d60 <abort>
 8006758:	b143      	cbz	r3, 800676c <_ZL28read_encoded_value_with_basehjPKhPj+0x82>
 800675a:	f005 0270 	and.w	r2, r5, #112	; 0x70
 800675e:	2a10      	cmp	r2, #16
 8006760:	bf18      	it	ne
 8006762:	463c      	movne	r4, r7
 8006764:	4423      	add	r3, r4
 8006766:	062a      	lsls	r2, r5, #24
 8006768:	bf48      	it	mi
 800676a:	681b      	ldrmi	r3, [r3, #0]
 800676c:	6033      	str	r3, [r6, #0]
 800676e:	b003      	add	sp, #12
 8006770:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006772 <_ZL21base_of_encoded_valuehP15_Unwind_Context>:
 8006772:	b508      	push	{r3, lr}
 8006774:	4603      	mov	r3, r0
 8006776:	2bff      	cmp	r3, #255	; 0xff
 8006778:	4608      	mov	r0, r1
 800677a:	d01c      	beq.n	80067b6 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x44>
 800677c:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8006780:	2b20      	cmp	r3, #32
 8006782:	d00e      	beq.n	80067a2 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x30>
 8006784:	d803      	bhi.n	800678e <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x1c>
 8006786:	b1b3      	cbz	r3, 80067b6 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x44>
 8006788:	2b10      	cmp	r3, #16
 800678a:	d112      	bne.n	80067b2 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x40>
 800678c:	e013      	b.n	80067b6 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x44>
 800678e:	2b40      	cmp	r3, #64	; 0x40
 8006790:	d00b      	beq.n	80067aa <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x38>
 8006792:	2b50      	cmp	r3, #80	; 0x50
 8006794:	d00f      	beq.n	80067b6 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x44>
 8006796:	2b30      	cmp	r3, #48	; 0x30
 8006798:	d10b      	bne.n	80067b2 <_ZL21base_of_encoded_valuehP15_Unwind_Context+0x40>
 800679a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800679e:	f7fa be39 	b.w	8001414 <_Unwind_GetDataRelBase>
 80067a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80067a6:	f7fa be31 	b.w	800140c <_Unwind_GetTextRelBase>
 80067aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80067ae:	f7fa be1d 	b.w	80013ec <_Unwind_GetRegionStart>
 80067b2:	f001 fad5 	bl	8007d60 <abort>
 80067b6:	2000      	movs	r0, #0
 80067b8:	bd08      	pop	{r3, pc}

080067ba <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>:
 80067ba:	b570      	push	{r4, r5, r6, lr}
 80067bc:	460c      	mov	r4, r1
 80067be:	4601      	mov	r1, r0
 80067c0:	4620      	mov	r0, r4
 80067c2:	4615      	mov	r5, r2
 80067c4:	461e      	mov	r6, r3
 80067c6:	f7ff ffd4 	bl	8006772 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 80067ca:	4633      	mov	r3, r6
 80067cc:	462a      	mov	r2, r5
 80067ce:	4601      	mov	r1, r0
 80067d0:	4620      	mov	r0, r4
 80067d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80067d6:	f7ff bf88 	b.w	80066ea <_ZL28read_encoded_value_with_basehjPKhPj>

080067da <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>:
 80067da:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80067dc:	460e      	mov	r6, r1
 80067de:	4614      	mov	r4, r2
 80067e0:	4605      	mov	r5, r0
 80067e2:	b110      	cbz	r0, 80067ea <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x10>
 80067e4:	f7fa fe02 	bl	80013ec <_Unwind_GetRegionStart>
 80067e8:	e7ff      	b.n	80067ea <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x10>
 80067ea:	6020      	str	r0, [r4, #0]
 80067ec:	7831      	ldrb	r1, [r6, #0]
 80067ee:	29ff      	cmp	r1, #255	; 0xff
 80067f0:	f106 0201 	add.w	r2, r6, #1
 80067f4:	d005      	beq.n	8006802 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x28>
 80067f6:	1d23      	adds	r3, r4, #4
 80067f8:	4628      	mov	r0, r5
 80067fa:	f7ff ffde 	bl	80067ba <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>
 80067fe:	4602      	mov	r2, r0
 8006800:	e000      	b.n	8006804 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x2a>
 8006802:	6060      	str	r0, [r4, #4]
 8006804:	7813      	ldrb	r3, [r2, #0]
 8006806:	7523      	strb	r3, [r4, #20]
 8006808:	2bff      	cmp	r3, #255	; 0xff
 800680a:	f102 0001 	add.w	r0, r2, #1
 800680e:	d007      	beq.n	8006820 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x46>
 8006810:	2310      	movs	r3, #16
 8006812:	7523      	strb	r3, [r4, #20]
 8006814:	a901      	add	r1, sp, #4
 8006816:	f7ff ff3f 	bl	8006698 <_ZL12read_uleb128PKhPm>
 800681a:	9b01      	ldr	r3, [sp, #4]
 800681c:	4403      	add	r3, r0
 800681e:	e000      	b.n	8006822 <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info+0x48>
 8006820:	2300      	movs	r3, #0
 8006822:	60e3      	str	r3, [r4, #12]
 8006824:	7803      	ldrb	r3, [r0, #0]
 8006826:	7563      	strb	r3, [r4, #21]
 8006828:	a901      	add	r1, sp, #4
 800682a:	3001      	adds	r0, #1
 800682c:	f7ff ff34 	bl	8006698 <_ZL12read_uleb128PKhPm>
 8006830:	9b01      	ldr	r3, [sp, #4]
 8006832:	4403      	add	r3, r0
 8006834:	6123      	str	r3, [r4, #16]
 8006836:	b002      	add	sp, #8
 8006838:	bd70      	pop	{r4, r5, r6, pc}

0800683a <_Unwind_GetGR>:
 800683a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800683c:	ab03      	add	r3, sp, #12
 800683e:	9300      	str	r3, [sp, #0]
 8006840:	2300      	movs	r3, #0
 8006842:	460a      	mov	r2, r1
 8006844:	4619      	mov	r1, r3
 8006846:	f7fa f847 	bl	80008d8 <_Unwind_VRS_Get>
 800684a:	9803      	ldr	r0, [sp, #12]
 800684c:	b005      	add	sp, #20
 800684e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08006854 <__gxx_personality_v0>:
 8006854:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006858:	b091      	sub	sp, #68	; 0x44
 800685a:	2300      	movs	r3, #0
 800685c:	9304      	str	r3, [sp, #16]
 800685e:	f000 0303 	and.w	r3, r0, #3
 8006862:	2b01      	cmp	r3, #1
 8006864:	4607      	mov	r7, r0
 8006866:	460c      	mov	r4, r1
 8006868:	4615      	mov	r5, r2
 800686a:	d00e      	beq.n	800688a <__gxx_personality_v0+0x36>
 800686c:	d302      	bcc.n	8006874 <__gxx_personality_v0+0x20>
 800686e:	2b02      	cmp	r3, #2
 8006870:	d002      	beq.n	8006878 <__gxx_personality_v0+0x24>
 8006872:	e0ef      	b.n	8006a54 <__gxx_personality_v0+0x200>
 8006874:	0702      	lsls	r2, r0, #28
 8006876:	d517      	bpl.n	80068a8 <__gxx_personality_v0+0x54>
 8006878:	4629      	mov	r1, r5
 800687a:	4620      	mov	r0, r4
 800687c:	f7fa fda2 	bl	80013c4 <__gnu_unwind_frame>
 8006880:	b108      	cbz	r0, 8006886 <__gxx_personality_v0+0x32>
 8006882:	2009      	movs	r0, #9
 8006884:	e19f      	b.n	8006bc6 <__gxx_personality_v0+0x372>
 8006886:	2008      	movs	r0, #8
 8006888:	e19d      	b.n	8006bc6 <__gxx_personality_v0+0x372>
 800688a:	f000 0208 	and.w	r2, r0, #8
 800688e:	f002 06ff 	and.w	r6, r2, #255	; 0xff
 8006892:	b95a      	cbnz	r2, 80068ac <__gxx_personality_v0+0x58>
 8006894:	f8d1 8020 	ldr.w	r8, [r1, #32]
 8006898:	4628      	mov	r0, r5
 800689a:	210d      	movs	r1, #13
 800689c:	f7ff ffcd 	bl	800683a <_Unwind_GetGR>
 80068a0:	4580      	cmp	r8, r0
 80068a2:	d120      	bne.n	80068e6 <__gxx_personality_v0+0x92>
 80068a4:	2606      	movs	r6, #6
 80068a6:	e002      	b.n	80068ae <__gxx_personality_v0+0x5a>
 80068a8:	2601      	movs	r6, #1
 80068aa:	e000      	b.n	80068ae <__gxx_personality_v0+0x5a>
 80068ac:	2602      	movs	r6, #2
 80068ae:	ab10      	add	r3, sp, #64	; 0x40
 80068b0:	f007 0708 	and.w	r7, r7, #8
 80068b4:	f843 4d2c 	str.w	r4, [r3, #-44]!
 80068b8:	9300      	str	r3, [sp, #0]
 80068ba:	2300      	movs	r3, #0
 80068bc:	433e      	orrs	r6, r7
 80068be:	220c      	movs	r2, #12
 80068c0:	4619      	mov	r1, r3
 80068c2:	4628      	mov	r0, r5
 80068c4:	f7fa f82e 	bl	8000924 <_Unwind_VRS_Set>
 80068c8:	2e06      	cmp	r6, #6
 80068ca:	d117      	bne.n	80068fc <__gxx_personality_v0+0xa8>
 80068cc:	f8d4 8030 	ldr.w	r8, [r4, #48]	; 0x30
 80068d0:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 80068d2:	f8d4 902c 	ldr.w	r9, [r4, #44]	; 0x2c
 80068d6:	f1b8 0f00 	cmp.w	r8, #0
 80068da:	bf0c      	ite	eq
 80068dc:	f04f 0a01 	moveq.w	sl, #1
 80068e0:	f04f 0a03 	movne.w	sl, #3
 80068e4:	e105      	b.n	8006af2 <__gxx_personality_v0+0x29e>
 80068e6:	aa10      	add	r2, sp, #64	; 0x40
 80068e8:	4633      	mov	r3, r6
 80068ea:	f842 4d2c 	str.w	r4, [r2, #-44]!
 80068ee:	4631      	mov	r1, r6
 80068f0:	9200      	str	r2, [sp, #0]
 80068f2:	4628      	mov	r0, r5
 80068f4:	220c      	movs	r2, #12
 80068f6:	f7fa f815 	bl	8000924 <_Unwind_VRS_Set>
 80068fa:	2602      	movs	r6, #2
 80068fc:	4628      	mov	r0, r5
 80068fe:	f7fa fd7b 	bl	80013f8 <_Unwind_GetLanguageSpecificData>
 8006902:	4681      	mov	r9, r0
 8006904:	2800      	cmp	r0, #0
 8006906:	d0b7      	beq.n	8006878 <__gxx_personality_v0+0x24>
 8006908:	aa0a      	add	r2, sp, #40	; 0x28
 800690a:	4601      	mov	r1, r0
 800690c:	4628      	mov	r0, r5
 800690e:	f7ff ff64 	bl	80067da <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>
 8006912:	4629      	mov	r1, r5
 8006914:	4680      	mov	r8, r0
 8006916:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
 800691a:	f7ff ff2a 	bl	8006772 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 800691e:	210f      	movs	r1, #15
 8006920:	900c      	str	r0, [sp, #48]	; 0x30
 8006922:	4628      	mov	r0, r5
 8006924:	f7ff ff89 	bl	800683a <_Unwind_GetGR>
 8006928:	f020 0001 	bic.w	r0, r0, #1
 800692c:	1e47      	subs	r7, r0, #1
 800692e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8006930:	4598      	cmp	r8, r3
 8006932:	f080 813f 	bcs.w	8006bb4 <__gxx_personality_v0+0x360>
 8006936:	4642      	mov	r2, r8
 8006938:	ab06      	add	r3, sp, #24
 800693a:	f89d 103d 	ldrb.w	r1, [sp, #61]	; 0x3d
 800693e:	2000      	movs	r0, #0
 8006940:	f7ff ff3b 	bl	80067ba <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>
 8006944:	ab07      	add	r3, sp, #28
 8006946:	4602      	mov	r2, r0
 8006948:	f89d 103d 	ldrb.w	r1, [sp, #61]	; 0x3d
 800694c:	2000      	movs	r0, #0
 800694e:	f7ff ff34 	bl	80067ba <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>
 8006952:	ab08      	add	r3, sp, #32
 8006954:	4602      	mov	r2, r0
 8006956:	f89d 103d 	ldrb.w	r1, [sp, #61]	; 0x3d
 800695a:	2000      	movs	r0, #0
 800695c:	f7ff ff2d 	bl	80067ba <_ZL18read_encoded_valueP15_Unwind_ContexthPKhPj>
 8006960:	a909      	add	r1, sp, #36	; 0x24
 8006962:	f7ff fe99 	bl	8006698 <_ZL12read_uleb128PKhPm>
 8006966:	9b06      	ldr	r3, [sp, #24]
 8006968:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800696a:	4413      	add	r3, r2
 800696c:	429f      	cmp	r7, r3
 800696e:	4680      	mov	r8, r0
 8006970:	d202      	bcs.n	8006978 <__gxx_personality_v0+0x124>
 8006972:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 8006976:	e7da      	b.n	800692e <__gxx_personality_v0+0xda>
 8006978:	9a07      	ldr	r2, [sp, #28]
 800697a:	4413      	add	r3, r2
 800697c:	429f      	cmp	r7, r3
 800697e:	d2d6      	bcs.n	800692e <__gxx_personality_v0+0xda>
 8006980:	9808      	ldr	r0, [sp, #32]
 8006982:	b118      	cbz	r0, 800698c <__gxx_personality_v0+0x138>
 8006984:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8006986:	eb00 0803 	add.w	r8, r0, r3
 800698a:	e000      	b.n	800698e <__gxx_personality_v0+0x13a>
 800698c:	4680      	mov	r8, r0
 800698e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8006990:	b110      	cbz	r0, 8006998 <__gxx_personality_v0+0x144>
 8006992:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 8006994:	3801      	subs	r0, #1
 8006996:	4438      	add	r0, r7
 8006998:	f1b8 0f00 	cmp.w	r8, #0
 800699c:	f43f af6c 	beq.w	8006878 <__gxx_personality_v0+0x24>
 80069a0:	2800      	cmp	r0, #0
 80069a2:	f000 810c 	beq.w	8006bbe <__gxx_personality_v0+0x36a>
 80069a6:	f016 0308 	ands.w	r3, r6, #8
 80069aa:	9302      	str	r3, [sp, #8]
 80069ac:	d014      	beq.n	80069d8 <__gxx_personality_v0+0x184>
 80069ae:	2347      	movs	r3, #71	; 0x47
 80069b0:	7023      	strb	r3, [r4, #0]
 80069b2:	234e      	movs	r3, #78	; 0x4e
 80069b4:	7063      	strb	r3, [r4, #1]
 80069b6:	2355      	movs	r3, #85	; 0x55
 80069b8:	70a3      	strb	r3, [r4, #2]
 80069ba:	2343      	movs	r3, #67	; 0x43
 80069bc:	70e3      	strb	r3, [r4, #3]
 80069be:	2346      	movs	r3, #70	; 0x46
 80069c0:	7123      	strb	r3, [r4, #4]
 80069c2:	234f      	movs	r3, #79	; 0x4f
 80069c4:	7163      	strb	r3, [r4, #5]
 80069c6:	2352      	movs	r3, #82	; 0x52
 80069c8:	71a3      	strb	r3, [r4, #6]
 80069ca:	2300      	movs	r3, #0
 80069cc:	71e3      	strb	r3, [r4, #7]
 80069ce:	f04f 0a00 	mov.w	sl, #0
 80069d2:	f06f 0b03 	mvn.w	fp, #3
 80069d6:	e01b      	b.n	8006a10 <__gxx_personality_v0+0x1bc>
 80069d8:	79e3      	ldrb	r3, [r4, #7]
 80069da:	2b01      	cmp	r3, #1
 80069dc:	bf0c      	ite	eq
 80069de:	f854 3c20 	ldreq.w	r3, [r4, #-32]
 80069e2:	f104 0358 	addne.w	r3, r4, #88	; 0x58
 80069e6:	9304      	str	r3, [sp, #16]
 80069e8:	e7f1      	b.n	80069ce <__gxx_personality_v0+0x17a>
 80069ea:	2704      	movs	r7, #4
 80069ec:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80069ee:	ab09      	add	r3, sp, #36	; 0x24
 80069f0:	fb07 2211 	mls	r2, r7, r1, r2
 80069f4:	990c      	ldr	r1, [sp, #48]	; 0x30
 80069f6:	f7ff fe78 	bl	80066ea <_ZL28read_encoded_value_with_basehjPKhPj>
 80069fa:	9909      	ldr	r1, [sp, #36]	; 0x24
 80069fc:	2900      	cmp	r1, #0
 80069fe:	f000 80d5 	beq.w	8006bac <__gxx_personality_v0+0x358>
 8006a02:	bb6c      	cbnz	r4, 8006a60 <__gxx_personality_v0+0x20c>
 8006a04:	9f08      	ldr	r7, [sp, #32]
 8006a06:	2f00      	cmp	r7, #0
 8006a08:	d059      	beq.n	8006abe <__gxx_personality_v0+0x26a>
 8006a0a:	9b03      	ldr	r3, [sp, #12]
 8006a0c:	443b      	add	r3, r7
 8006a0e:	4618      	mov	r0, r3
 8006a10:	a907      	add	r1, sp, #28
 8006a12:	f7ff fe52 	bl	80066ba <_ZL12read_sleb128PKhPl>
 8006a16:	a908      	add	r1, sp, #32
 8006a18:	9003      	str	r0, [sp, #12]
 8006a1a:	f7ff fe4e 	bl	80066ba <_ZL12read_sleb128PKhPl>
 8006a1e:	9907      	ldr	r1, [sp, #28]
 8006a20:	2900      	cmp	r1, #0
 8006a22:	d049      	beq.n	8006ab8 <__gxx_personality_v0+0x264>
 8006a24:	dd25      	ble.n	8006a72 <__gxx_personality_v0+0x21e>
 8006a26:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
 8006a2a:	28ff      	cmp	r0, #255	; 0xff
 8006a2c:	d014      	beq.n	8006a58 <__gxx_personality_v0+0x204>
 8006a2e:	f000 0307 	and.w	r3, r0, #7
 8006a32:	2b04      	cmp	r3, #4
 8006a34:	d80e      	bhi.n	8006a54 <__gxx_personality_v0+0x200>
 8006a36:	a201      	add	r2, pc, #4	; (adr r2, 8006a3c <__gxx_personality_v0+0x1e8>)
 8006a38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006a3c:	080069eb 	.word	0x080069eb
 8006a40:	08006a55 	.word	0x08006a55
 8006a44:	08006a5d 	.word	0x08006a5d
 8006a48:	080069eb 	.word	0x080069eb
 8006a4c:	08006a51 	.word	0x08006a51
 8006a50:	2708      	movs	r7, #8
 8006a52:	e7cb      	b.n	80069ec <__gxx_personality_v0+0x198>
 8006a54:	f001 f984 	bl	8007d60 <abort>
 8006a58:	2700      	movs	r7, #0
 8006a5a:	e7c7      	b.n	80069ec <__gxx_personality_v0+0x198>
 8006a5c:	2702      	movs	r7, #2
 8006a5e:	e7c5      	b.n	80069ec <__gxx_personality_v0+0x198>
 8006a60:	ab04      	add	r3, sp, #16
 8006a62:	2200      	movs	r2, #0
 8006a64:	4620      	mov	r0, r4
 8006a66:	f7ff fd83 	bl	8006570 <__cxa_type_match>
 8006a6a:	2800      	cmp	r0, #0
 8006a6c:	f040 809e 	bne.w	8006bac <__gxx_personality_v0+0x358>
 8006a70:	e7c8      	b.n	8006a04 <__gxx_personality_v0+0x1b0>
 8006a72:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 8006a74:	1c4a      	adds	r2, r1, #1
 8006a76:	b1b4      	cbz	r4, 8006aa6 <__gxx_personality_v0+0x252>
 8006a78:	9b02      	ldr	r3, [sp, #8]
 8006a7a:	b9a3      	cbnz	r3, 8006aa6 <__gxx_personality_v0+0x252>
 8006a7c:	9b04      	ldr	r3, [sp, #16]
 8006a7e:	9306      	str	r3, [sp, #24]
 8006a80:	fb0b 7202 	mla	r2, fp, r2, r7
 8006a84:	1f17      	subs	r7, r2, #4
 8006a86:	f857 1f04 	ldr.w	r1, [r7, #4]!
 8006a8a:	b141      	cbz	r1, 8006a9e <__gxx_personality_v0+0x24a>
 8006a8c:	ab06      	add	r3, sp, #24
 8006a8e:	2200      	movs	r2, #0
 8006a90:	4439      	add	r1, r7
 8006a92:	4620      	mov	r0, r4
 8006a94:	f7ff fd6c 	bl	8006570 <__cxa_type_match>
 8006a98:	2800      	cmp	r0, #0
 8006a9a:	d0f4      	beq.n	8006a86 <__gxx_personality_v0+0x232>
 8006a9c:	2101      	movs	r1, #1
 8006a9e:	f081 0101 	eor.w	r1, r1, #1
 8006aa2:	b2c9      	uxtb	r1, r1
 8006aa4:	e005      	b.n	8006ab2 <__gxx_personality_v0+0x25e>
 8006aa6:	fb0b f202 	mul.w	r2, fp, r2
 8006aaa:	58b9      	ldr	r1, [r7, r2]
 8006aac:	fab1 f181 	clz	r1, r1
 8006ab0:	0949      	lsrs	r1, r1, #5
 8006ab2:	2900      	cmp	r1, #0
 8006ab4:	d0a6      	beq.n	8006a04 <__gxx_personality_v0+0x1b0>
 8006ab6:	e079      	b.n	8006bac <__gxx_personality_v0+0x358>
 8006ab8:	f04f 0a01 	mov.w	sl, #1
 8006abc:	e7a2      	b.n	8006a04 <__gxx_personality_v0+0x1b0>
 8006abe:	f1ba 0f00 	cmp.w	sl, #0
 8006ac2:	f43f aed9 	beq.w	8006878 <__gxx_personality_v0+0x24>
 8006ac6:	f04f 0a02 	mov.w	sl, #2
 8006aca:	07f3      	lsls	r3, r6, #31
 8006acc:	d511      	bpl.n	8006af2 <__gxx_personality_v0+0x29e>
 8006ace:	f1ba 0f02 	cmp.w	sl, #2
 8006ad2:	f43f aed1 	beq.w	8006878 <__gxx_personality_v0+0x24>
 8006ad6:	210d      	movs	r1, #13
 8006ad8:	4628      	mov	r0, r5
 8006ada:	9e04      	ldr	r6, [sp, #16]
 8006adc:	f7ff fead 	bl	800683a <_Unwind_GetGR>
 8006ae0:	6266      	str	r6, [r4, #36]	; 0x24
 8006ae2:	6220      	str	r0, [r4, #32]
 8006ae4:	62a7      	str	r7, [r4, #40]	; 0x28
 8006ae6:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
 8006aea:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
 8006aee:	2006      	movs	r0, #6
 8006af0:	e069      	b.n	8006bc6 <__gxx_personality_v0+0x372>
 8006af2:	f016 0608 	ands.w	r6, r6, #8
 8006af6:	d008      	beq.n	8006b0a <__gxx_personality_v0+0x2b6>
 8006af8:	f1ba 0f01 	cmp.w	sl, #1
 8006afc:	d101      	bne.n	8006b02 <__gxx_personality_v0+0x2ae>
 8006afe:	f000 f8f7 	bl	8006cf0 <_ZSt9terminatev>
 8006b02:	2f00      	cmp	r7, #0
 8006b04:	da24      	bge.n	8006b50 <__gxx_personality_v0+0x2fc>
 8006b06:	f000 f905 	bl	8006d14 <_ZSt10unexpectedv>
 8006b0a:	f1ba 0f01 	cmp.w	sl, #1
 8006b0e:	d102      	bne.n	8006b16 <__gxx_personality_v0+0x2c2>
 8006b10:	4620      	mov	r0, r4
 8006b12:	f000 f9cc 	bl	8006eae <__cxa_call_terminate>
 8006b16:	2f00      	cmp	r7, #0
 8006b18:	da1a      	bge.n	8006b50 <__gxx_personality_v0+0x2fc>
 8006b1a:	aa0a      	add	r2, sp, #40	; 0x28
 8006b1c:	4649      	mov	r1, r9
 8006b1e:	4628      	mov	r0, r5
 8006b20:	f7ff fe5b 	bl	80067da <_ZL17parse_lsda_headerP15_Unwind_ContextPKhP16lsda_header_info>
 8006b24:	4629      	mov	r1, r5
 8006b26:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
 8006b2a:	f7ff fe22 	bl	8006772 <_ZL21base_of_encoded_valuehP15_Unwind_Context>
 8006b2e:	f06f 0303 	mvn.w	r3, #3
 8006b32:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8006b34:	900c      	str	r0, [sp, #48]	; 0x30
 8006b36:	fb07 3303 	mla	r3, r7, r3, r3
 8006b3a:	4413      	add	r3, r2
 8006b3c:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
 8006b40:	b10a      	cbz	r2, 8006b46 <__gxx_personality_v0+0x2f2>
 8006b42:	3601      	adds	r6, #1
 8006b44:	e7fa      	b.n	8006b3c <__gxx_personality_v0+0x2e8>
 8006b46:	2204      	movs	r2, #4
 8006b48:	62a6      	str	r6, [r4, #40]	; 0x28
 8006b4a:	62e0      	str	r0, [r4, #44]	; 0x2c
 8006b4c:	6322      	str	r2, [r4, #48]	; 0x30
 8006b4e:	6363      	str	r3, [r4, #52]	; 0x34
 8006b50:	ab10      	add	r3, sp, #64	; 0x40
 8006b52:	4628      	mov	r0, r5
 8006b54:	f843 4d1c 	str.w	r4, [r3, #-28]!
 8006b58:	9300      	str	r3, [sp, #0]
 8006b5a:	2300      	movs	r3, #0
 8006b5c:	461a      	mov	r2, r3
 8006b5e:	4619      	mov	r1, r3
 8006b60:	f7f9 fee0 	bl	8000924 <_Unwind_VRS_Set>
 8006b64:	ab10      	add	r3, sp, #64	; 0x40
 8006b66:	2201      	movs	r2, #1
 8006b68:	f843 7d20 	str.w	r7, [r3, #-32]!
 8006b6c:	9300      	str	r3, [sp, #0]
 8006b6e:	2300      	movs	r3, #0
 8006b70:	4619      	mov	r1, r3
 8006b72:	4628      	mov	r0, r5
 8006b74:	f7f9 fed6 	bl	8000924 <_Unwind_VRS_Set>
 8006b78:	210f      	movs	r1, #15
 8006b7a:	4628      	mov	r0, r5
 8006b7c:	f7ff fe5d 	bl	800683a <_Unwind_GetGR>
 8006b80:	ab10      	add	r3, sp, #64	; 0x40
 8006b82:	f000 0001 	and.w	r0, r0, #1
 8006b86:	ea40 0008 	orr.w	r0, r0, r8
 8006b8a:	f843 0d24 	str.w	r0, [r3, #-36]!
 8006b8e:	9300      	str	r3, [sp, #0]
 8006b90:	2300      	movs	r3, #0
 8006b92:	220f      	movs	r2, #15
 8006b94:	4619      	mov	r1, r3
 8006b96:	4628      	mov	r0, r5
 8006b98:	f7f9 fec4 	bl	8000924 <_Unwind_VRS_Set>
 8006b9c:	f1ba 0f02 	cmp.w	sl, #2
 8006ba0:	d102      	bne.n	8006ba8 <__gxx_personality_v0+0x354>
 8006ba2:	4620      	mov	r0, r4
 8006ba4:	f7ff fd42 	bl	800662c <__cxa_begin_cleanup>
 8006ba8:	2007      	movs	r0, #7
 8006baa:	e00c      	b.n	8006bc6 <__gxx_personality_v0+0x372>
 8006bac:	9f07      	ldr	r7, [sp, #28]
 8006bae:	f04f 0a03 	mov.w	sl, #3
 8006bb2:	e78a      	b.n	8006aca <__gxx_personality_v0+0x276>
 8006bb4:	f04f 0800 	mov.w	r8, #0
 8006bb8:	f04f 0a01 	mov.w	sl, #1
 8006bbc:	e001      	b.n	8006bc2 <__gxx_personality_v0+0x36e>
 8006bbe:	f04f 0a02 	mov.w	sl, #2
 8006bc2:	2700      	movs	r7, #0
 8006bc4:	e781      	b.n	8006aca <__gxx_personality_v0+0x276>
 8006bc6:	b011      	add	sp, #68	; 0x44
 8006bc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006bcc <_Znwj>:
 8006bcc:	b510      	push	{r4, lr}
 8006bce:	2800      	cmp	r0, #0
 8006bd0:	bf14      	ite	ne
 8006bd2:	4604      	movne	r4, r0
 8006bd4:	2401      	moveq	r4, #1
 8006bd6:	4620      	mov	r0, r4
 8006bd8:	f001 f8f6 	bl	8007dc8 <malloc>
 8006bdc:	b930      	cbnz	r0, 8006bec <_Znwj+0x20>
 8006bde:	f000 f941 	bl	8006e64 <_ZSt15get_new_handlerv>
 8006be2:	b908      	cbnz	r0, 8006be8 <_Znwj+0x1c>
 8006be4:	f001 f8bc 	bl	8007d60 <abort>
 8006be8:	4780      	blx	r0
 8006bea:	e7f4      	b.n	8006bd6 <_Znwj+0xa>
 8006bec:	bd10      	pop	{r4, pc}

08006bee <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv>:
 8006bee:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8006bf0:	2310      	movs	r3, #16
 8006bf2:	9302      	str	r3, [sp, #8]
 8006bf4:	6803      	ldr	r3, [r0, #0]
 8006bf6:	2400      	movs	r4, #0
 8006bf8:	4615      	mov	r5, r2
 8006bfa:	699e      	ldr	r6, [r3, #24]
 8006bfc:	9400      	str	r4, [sp, #0]
 8006bfe:	466b      	mov	r3, sp
 8006c00:	f88d 4004 	strb.w	r4, [sp, #4]
 8006c04:	9403      	str	r4, [sp, #12]
 8006c06:	6812      	ldr	r2, [r2, #0]
 8006c08:	47b0      	blx	r6
 8006c0a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8006c0e:	f003 0306 	and.w	r3, r3, #6
 8006c12:	2b06      	cmp	r3, #6
 8006c14:	bf03      	ittte	eq
 8006c16:	9b00      	ldreq	r3, [sp, #0]
 8006c18:	602b      	streq	r3, [r5, #0]
 8006c1a:	2001      	moveq	r0, #1
 8006c1c:	4620      	movne	r0, r4
 8006c1e:	b004      	add	sp, #16
 8006c20:	bd70      	pop	{r4, r5, r6, pc}

08006c22 <_ZNK10__cxxabiv117__class_type_info20__do_find_public_srcEiPKvPKS0_S2_>:
 8006c22:	9800      	ldr	r0, [sp, #0]
 8006c24:	4290      	cmp	r0, r2
 8006c26:	bf0c      	ite	eq
 8006c28:	2006      	moveq	r0, #6
 8006c2a:	2001      	movne	r0, #1
 8006c2c:	4770      	bx	lr
	...

08006c30 <_ZN10__cxxabiv117__class_type_infoD1Ev>:
 8006c30:	b510      	push	{r4, lr}
 8006c32:	4b03      	ldr	r3, [pc, #12]	; (8006c40 <_ZN10__cxxabiv117__class_type_infoD1Ev+0x10>)
 8006c34:	6003      	str	r3, [r0, #0]
 8006c36:	4604      	mov	r4, r0
 8006c38:	f000 f876 	bl	8006d28 <_ZNSt9type_infoD1Ev>
 8006c3c:	4620      	mov	r0, r4
 8006c3e:	bd10      	pop	{r4, pc}
 8006c40:	080091ec 	.word	0x080091ec

08006c44 <_ZN10__cxxabiv117__class_type_infoD0Ev>:
 8006c44:	b510      	push	{r4, lr}
 8006c46:	4604      	mov	r4, r0
 8006c48:	f7ff fff2 	bl	8006c30 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 8006c4c:	4620      	mov	r0, r4
 8006c4e:	f000 f907 	bl	8006e60 <_ZdlPv>
 8006c52:	4620      	mov	r0, r4
 8006c54:	bd10      	pop	{r4, pc}

08006c56 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>:
 8006c56:	b538      	push	{r3, r4, r5, lr}
 8006c58:	4615      	mov	r5, r2
 8006c5a:	461c      	mov	r4, r3
 8006c5c:	f000 f867 	bl	8006d2e <_ZNKSt9type_infoeqERKS_>
 8006c60:	b120      	cbz	r0, 8006c6c <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE+0x16>
 8006c62:	2308      	movs	r3, #8
 8006c64:	60e3      	str	r3, [r4, #12]
 8006c66:	2306      	movs	r3, #6
 8006c68:	6025      	str	r5, [r4, #0]
 8006c6a:	7123      	strb	r3, [r4, #4]
 8006c6c:	bd38      	pop	{r3, r4, r5, pc}

08006c6e <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE>:
 8006c6e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006c72:	9e06      	ldr	r6, [sp, #24]
 8006c74:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8006c76:	4698      	mov	r8, r3
 8006c78:	9b08      	ldr	r3, [sp, #32]
 8006c7a:	429e      	cmp	r6, r3
 8006c7c:	4607      	mov	r7, r0
 8006c7e:	4615      	mov	r5, r2
 8006c80:	d103      	bne.n	8006c8a <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x1c>
 8006c82:	9907      	ldr	r1, [sp, #28]
 8006c84:	f000 f853 	bl	8006d2e <_ZNKSt9type_infoeqERKS_>
 8006c88:	b948      	cbnz	r0, 8006c9e <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x30>
 8006c8a:	4641      	mov	r1, r8
 8006c8c:	4638      	mov	r0, r7
 8006c8e:	f000 f84e 	bl	8006d2e <_ZNKSt9type_infoeqERKS_>
 8006c92:	b128      	cbz	r0, 8006ca0 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x32>
 8006c94:	2301      	movs	r3, #1
 8006c96:	6026      	str	r6, [r4, #0]
 8006c98:	7125      	strb	r5, [r4, #4]
 8006c9a:	71a3      	strb	r3, [r4, #6]
 8006c9c:	e000      	b.n	8006ca0 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x32>
 8006c9e:	7165      	strb	r5, [r4, #5]
 8006ca0:	2000      	movs	r0, #0
 8006ca2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006ca6 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj>:
 8006ca6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006caa:	4605      	mov	r5, r0
 8006cac:	460c      	mov	r4, r1
 8006cae:	4616      	mov	r6, r2
 8006cb0:	461f      	mov	r7, r3
 8006cb2:	f000 f83c 	bl	8006d2e <_ZNKSt9type_infoeqERKS_>
 8006cb6:	b948      	cbnz	r0, 8006ccc <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x26>
 8006cb8:	2f03      	cmp	r7, #3
 8006cba:	d807      	bhi.n	8006ccc <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x26>
 8006cbc:	6823      	ldr	r3, [r4, #0]
 8006cbe:	4632      	mov	r2, r6
 8006cc0:	4629      	mov	r1, r5
 8006cc2:	4620      	mov	r0, r4
 8006cc4:	695b      	ldr	r3, [r3, #20]
 8006cc6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8006cca:	4718      	bx	r3
 8006ccc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006cd0 <__cxa_get_globals>:
 8006cd0:	4800      	ldr	r0, [pc, #0]	; (8006cd4 <__cxa_get_globals+0x4>)
 8006cd2:	4770      	bx	lr
 8006cd4:	20003d00 	.word	0x20003d00

08006cd8 <_ZN10__cxxabiv111__terminateEPFvvE>:
 8006cd8:	b508      	push	{r3, lr}
 8006cda:	4780      	blx	r0
 8006cdc:	f001 f840 	bl	8007d60 <abort>

08006ce0 <_ZSt13get_terminatev>:
 8006ce0:	4b02      	ldr	r3, [pc, #8]	; (8006cec <_ZSt13get_terminatev+0xc>)
 8006ce2:	6818      	ldr	r0, [r3, #0]
 8006ce4:	f3bf 8f5f 	dmb	sy
 8006ce8:	4770      	bx	lr
 8006cea:	bf00      	nop
 8006cec:	20000008 	.word	0x20000008

08006cf0 <_ZSt9terminatev>:
 8006cf0:	b508      	push	{r3, lr}
 8006cf2:	f7ff fff5 	bl	8006ce0 <_ZSt13get_terminatev>
 8006cf6:	f7ff ffef 	bl	8006cd8 <_ZN10__cxxabiv111__terminateEPFvvE>

08006cfa <_ZN10__cxxabiv112__unexpectedEPFvvE>:
 8006cfa:	b508      	push	{r3, lr}
 8006cfc:	4780      	blx	r0
 8006cfe:	f7ff fff7 	bl	8006cf0 <_ZSt9terminatev>
	...

08006d04 <_ZSt14get_unexpectedv>:
 8006d04:	4b02      	ldr	r3, [pc, #8]	; (8006d10 <_ZSt14get_unexpectedv+0xc>)
 8006d06:	6818      	ldr	r0, [r3, #0]
 8006d08:	f3bf 8f5f 	dmb	sy
 8006d0c:	4770      	bx	lr
 8006d0e:	bf00      	nop
 8006d10:	2000000c 	.word	0x2000000c

08006d14 <_ZSt10unexpectedv>:
 8006d14:	b508      	push	{r3, lr}
 8006d16:	f7ff fff5 	bl	8006d04 <_ZSt14get_unexpectedv>
 8006d1a:	f7ff ffee 	bl	8006cfa <_ZN10__cxxabiv112__unexpectedEPFvvE>

08006d1e <__aeabi_atexit>:
 8006d1e:	460b      	mov	r3, r1
 8006d20:	4601      	mov	r1, r0
 8006d22:	4618      	mov	r0, r3
 8006d24:	f001 b823 	b.w	8007d6e <__cxa_atexit>

08006d28 <_ZNSt9type_infoD1Ev>:
 8006d28:	4770      	bx	lr

08006d2a <_ZNKSt9type_info14__is_pointer_pEv>:
 8006d2a:	2000      	movs	r0, #0
 8006d2c:	4770      	bx	lr

08006d2e <_ZNKSt9type_infoeqERKS_>:
 8006d2e:	4281      	cmp	r1, r0
 8006d30:	b508      	push	{r3, lr}
 8006d32:	d00e      	beq.n	8006d52 <_ZNKSt9type_infoeqERKS_+0x24>
 8006d34:	6840      	ldr	r0, [r0, #4]
 8006d36:	7803      	ldrb	r3, [r0, #0]
 8006d38:	2b2a      	cmp	r3, #42	; 0x2a
 8006d3a:	d00c      	beq.n	8006d56 <_ZNKSt9type_infoeqERKS_+0x28>
 8006d3c:	6849      	ldr	r1, [r1, #4]
 8006d3e:	780b      	ldrb	r3, [r1, #0]
 8006d40:	2b2a      	cmp	r3, #42	; 0x2a
 8006d42:	bf08      	it	eq
 8006d44:	3101      	addeq	r1, #1
 8006d46:	f7f9 fa5f 	bl	8000208 <strcmp>
 8006d4a:	fab0 f080 	clz	r0, r0
 8006d4e:	0940      	lsrs	r0, r0, #5
 8006d50:	bd08      	pop	{r3, pc}
 8006d52:	2001      	movs	r0, #1
 8006d54:	bd08      	pop	{r3, pc}
 8006d56:	2000      	movs	r0, #0
 8006d58:	bd08      	pop	{r3, pc}
	...

08006d5c <_ZN10__cxxabiv120__si_class_type_infoD1Ev>:
 8006d5c:	b510      	push	{r4, lr}
 8006d5e:	4b03      	ldr	r3, [pc, #12]	; (8006d6c <_ZN10__cxxabiv120__si_class_type_infoD1Ev+0x10>)
 8006d60:	6003      	str	r3, [r0, #0]
 8006d62:	4604      	mov	r4, r0
 8006d64:	f7ff ff64 	bl	8006c30 <_ZN10__cxxabiv117__class_type_infoD1Ev>
 8006d68:	4620      	mov	r0, r4
 8006d6a:	bd10      	pop	{r4, pc}
 8006d6c:	080092b4 	.word	0x080092b4

08006d70 <_ZN10__cxxabiv120__si_class_type_infoD0Ev>:
 8006d70:	b510      	push	{r4, lr}
 8006d72:	4604      	mov	r4, r0
 8006d74:	f7ff fff2 	bl	8006d5c <_ZN10__cxxabiv120__si_class_type_infoD1Ev>
 8006d78:	4620      	mov	r0, r4
 8006d7a:	f000 f871 	bl	8006e60 <_ZdlPv>
 8006d7e:	4620      	mov	r0, r4
 8006d80:	bd10      	pop	{r4, pc}

08006d82 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE>:
 8006d82:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006d86:	460e      	mov	r6, r1
 8006d88:	4619      	mov	r1, r3
 8006d8a:	4683      	mov	fp, r0
 8006d8c:	4617      	mov	r7, r2
 8006d8e:	4699      	mov	r9, r3
 8006d90:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8006d92:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 8006d96:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8006d9a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8006d9c:	f7ff ffc7 	bl	8006d2e <_ZNKSt9type_infoeqERKS_>
 8006da0:	b178      	cbz	r0, 8006dc2 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x40>
 8006da2:	2e00      	cmp	r6, #0
 8006da4:	602c      	str	r4, [r5, #0]
 8006da6:	712f      	strb	r7, [r5, #4]
 8006da8:	db06      	blt.n	8006db8 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x36>
 8006daa:	4434      	add	r4, r6
 8006dac:	45a0      	cmp	r8, r4
 8006dae:	bf0c      	ite	eq
 8006db0:	2406      	moveq	r4, #6
 8006db2:	2401      	movne	r4, #1
 8006db4:	71ac      	strb	r4, [r5, #6]
 8006db6:	e01e      	b.n	8006df6 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x74>
 8006db8:	3602      	adds	r6, #2
 8006dba:	d11c      	bne.n	8006df6 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x74>
 8006dbc:	2301      	movs	r3, #1
 8006dbe:	71ab      	strb	r3, [r5, #6]
 8006dc0:	e019      	b.n	8006df6 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x74>
 8006dc2:	4544      	cmp	r4, r8
 8006dc4:	d104      	bne.n	8006dd0 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x4e>
 8006dc6:	4651      	mov	r1, sl
 8006dc8:	4658      	mov	r0, fp
 8006dca:	f7ff ffb0 	bl	8006d2e <_ZNKSt9type_infoeqERKS_>
 8006dce:	b988      	cbnz	r0, 8006df4 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x72>
 8006dd0:	f8db 0008 	ldr.w	r0, [fp, #8]
 8006dd4:	6803      	ldr	r3, [r0, #0]
 8006dd6:	950d      	str	r5, [sp, #52]	; 0x34
 8006dd8:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
 8006ddc:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 8006de0:	940a      	str	r4, [sp, #40]	; 0x28
 8006de2:	69dc      	ldr	r4, [r3, #28]
 8006de4:	463a      	mov	r2, r7
 8006de6:	464b      	mov	r3, r9
 8006de8:	4631      	mov	r1, r6
 8006dea:	46a4      	mov	ip, r4
 8006dec:	b001      	add	sp, #4
 8006dee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006df2:	4760      	bx	ip
 8006df4:	716f      	strb	r7, [r5, #5]
 8006df6:	2000      	movs	r0, #0
 8006df8:	b001      	add	sp, #4
 8006dfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006dfe <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_>:
 8006dfe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006e02:	9e06      	ldr	r6, [sp, #24]
 8006e04:	4296      	cmp	r6, r2
 8006e06:	4680      	mov	r8, r0
 8006e08:	460f      	mov	r7, r1
 8006e0a:	4614      	mov	r4, r2
 8006e0c:	461d      	mov	r5, r3
 8006e0e:	d103      	bne.n	8006e18 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x1a>
 8006e10:	4619      	mov	r1, r3
 8006e12:	f7ff ff8c 	bl	8006d2e <_ZNKSt9type_infoeqERKS_>
 8006e16:	b958      	cbnz	r0, 8006e30 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x32>
 8006e18:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8006e1c:	6803      	ldr	r3, [r0, #0]
 8006e1e:	9606      	str	r6, [sp, #24]
 8006e20:	6a1e      	ldr	r6, [r3, #32]
 8006e22:	4622      	mov	r2, r4
 8006e24:	462b      	mov	r3, r5
 8006e26:	4639      	mov	r1, r7
 8006e28:	46b4      	mov	ip, r6
 8006e2a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8006e2e:	4760      	bx	ip
 8006e30:	2006      	movs	r0, #6
 8006e32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006e36 <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE>:
 8006e36:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006e3a:	4604      	mov	r4, r0
 8006e3c:	460d      	mov	r5, r1
 8006e3e:	4616      	mov	r6, r2
 8006e40:	461f      	mov	r7, r3
 8006e42:	f7ff ff08 	bl	8006c56 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>
 8006e46:	b948      	cbnz	r0, 8006e5c <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x26>
 8006e48:	68a0      	ldr	r0, [r4, #8]
 8006e4a:	6803      	ldr	r3, [r0, #0]
 8006e4c:	699c      	ldr	r4, [r3, #24]
 8006e4e:	4632      	mov	r2, r6
 8006e50:	463b      	mov	r3, r7
 8006e52:	4629      	mov	r1, r5
 8006e54:	46a4      	mov	ip, r4
 8006e56:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8006e5a:	4760      	bx	ip
 8006e5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006e60 <_ZdlPv>:
 8006e60:	f000 bfba 	b.w	8007dd8 <free>

08006e64 <_ZSt15get_new_handlerv>:
 8006e64:	4b02      	ldr	r3, [pc, #8]	; (8006e70 <_ZSt15get_new_handlerv+0xc>)
 8006e66:	6818      	ldr	r0, [r3, #0]
 8006e68:	f3bf 8f5f 	dmb	sy
 8006e6c:	4770      	bx	lr
 8006e6e:	bf00      	nop
 8006e70:	20003d0c 	.word	0x20003d0c

08006e74 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>:
 8006e74:	7803      	ldrb	r3, [r0, #0]
 8006e76:	2b47      	cmp	r3, #71	; 0x47
 8006e78:	d117      	bne.n	8006eaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006e7a:	7843      	ldrb	r3, [r0, #1]
 8006e7c:	2b4e      	cmp	r3, #78	; 0x4e
 8006e7e:	d114      	bne.n	8006eaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006e80:	7883      	ldrb	r3, [r0, #2]
 8006e82:	2b55      	cmp	r3, #85	; 0x55
 8006e84:	d111      	bne.n	8006eaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006e86:	78c3      	ldrb	r3, [r0, #3]
 8006e88:	2b43      	cmp	r3, #67	; 0x43
 8006e8a:	d10e      	bne.n	8006eaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006e8c:	7903      	ldrb	r3, [r0, #4]
 8006e8e:	2b43      	cmp	r3, #67	; 0x43
 8006e90:	d10b      	bne.n	8006eaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006e92:	7943      	ldrb	r3, [r0, #5]
 8006e94:	2b2b      	cmp	r3, #43	; 0x2b
 8006e96:	d108      	bne.n	8006eaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006e98:	7983      	ldrb	r3, [r0, #6]
 8006e9a:	2b2b      	cmp	r3, #43	; 0x2b
 8006e9c:	d105      	bne.n	8006eaa <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006e9e:	79c0      	ldrb	r0, [r0, #7]
 8006ea0:	2801      	cmp	r0, #1
 8006ea2:	bf8c      	ite	hi
 8006ea4:	2000      	movhi	r0, #0
 8006ea6:	2001      	movls	r0, #1
 8006ea8:	4770      	bx	lr
 8006eaa:	2000      	movs	r0, #0
 8006eac:	4770      	bx	lr

08006eae <__cxa_call_terminate>:
 8006eae:	b510      	push	{r4, lr}
 8006eb0:	4604      	mov	r4, r0
 8006eb2:	b148      	cbz	r0, 8006ec8 <__cxa_call_terminate+0x1a>
 8006eb4:	f000 f83b 	bl	8006f2e <__cxa_begin_catch>
 8006eb8:	4620      	mov	r0, r4
 8006eba:	f7ff ffdb 	bl	8006e74 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 8006ebe:	b118      	cbz	r0, 8006ec8 <__cxa_call_terminate+0x1a>
 8006ec0:	f854 0c14 	ldr.w	r0, [r4, #-20]
 8006ec4:	f7ff ff08 	bl	8006cd8 <_ZN10__cxxabiv111__terminateEPFvvE>
 8006ec8:	f7ff ff12 	bl	8006cf0 <_ZSt9terminatev>

08006ecc <__cxa_call_unexpected>:
 8006ecc:	b538      	push	{r3, r4, r5, lr}
 8006ece:	4602      	mov	r2, r0
 8006ed0:	f7ff ffd0 	bl	8006e74 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 8006ed4:	b118      	cbz	r0, 8006ede <__cxa_call_unexpected+0x12>
 8006ed6:	f852 4c18 	ldr.w	r4, [r2, #-24]
 8006eda:	2500      	movs	r5, #0
 8006edc:	e001      	b.n	8006ee2 <__cxa_call_unexpected+0x16>
 8006ede:	4604      	mov	r4, r0
 8006ee0:	2501      	movs	r5, #1
 8006ee2:	4610      	mov	r0, r2
 8006ee4:	f000 f823 	bl	8006f2e <__cxa_begin_catch>
 8006ee8:	b10d      	cbz	r5, 8006eee <__cxa_call_unexpected+0x22>
 8006eea:	f7ff ff13 	bl	8006d14 <_ZSt10unexpectedv>
 8006eee:	4620      	mov	r0, r4
 8006ef0:	f7ff ff03 	bl	8006cfa <_ZN10__cxxabiv112__unexpectedEPFvvE>

08006ef4 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>:
 8006ef4:	7803      	ldrb	r3, [r0, #0]
 8006ef6:	2b47      	cmp	r3, #71	; 0x47
 8006ef8:	d117      	bne.n	8006f2a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006efa:	7843      	ldrb	r3, [r0, #1]
 8006efc:	2b4e      	cmp	r3, #78	; 0x4e
 8006efe:	d114      	bne.n	8006f2a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006f00:	7883      	ldrb	r3, [r0, #2]
 8006f02:	2b55      	cmp	r3, #85	; 0x55
 8006f04:	d111      	bne.n	8006f2a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006f06:	78c3      	ldrb	r3, [r0, #3]
 8006f08:	2b43      	cmp	r3, #67	; 0x43
 8006f0a:	d10e      	bne.n	8006f2a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006f0c:	7903      	ldrb	r3, [r0, #4]
 8006f0e:	2b43      	cmp	r3, #67	; 0x43
 8006f10:	d10b      	bne.n	8006f2a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006f12:	7943      	ldrb	r3, [r0, #5]
 8006f14:	2b2b      	cmp	r3, #43	; 0x2b
 8006f16:	d108      	bne.n	8006f2a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006f18:	7983      	ldrb	r3, [r0, #6]
 8006f1a:	2b2b      	cmp	r3, #43	; 0x2b
 8006f1c:	d105      	bne.n	8006f2a <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc+0x36>
 8006f1e:	79c0      	ldrb	r0, [r0, #7]
 8006f20:	2801      	cmp	r0, #1
 8006f22:	bf8c      	ite	hi
 8006f24:	2000      	movhi	r0, #0
 8006f26:	2001      	movls	r0, #1
 8006f28:	4770      	bx	lr
 8006f2a:	2000      	movs	r0, #0
 8006f2c:	4770      	bx	lr

08006f2e <__cxa_begin_catch>:
 8006f2e:	b538      	push	{r3, r4, r5, lr}
 8006f30:	4605      	mov	r5, r0
 8006f32:	f7ff fecd 	bl	8006cd0 <__cxa_get_globals>
 8006f36:	4601      	mov	r1, r0
 8006f38:	6802      	ldr	r2, [r0, #0]
 8006f3a:	4628      	mov	r0, r5
 8006f3c:	f1a5 0420 	sub.w	r4, r5, #32
 8006f40:	f7ff ffd8 	bl	8006ef4 <_ZN10__cxxabiv1L24__is_gxx_exception_classEPc>
 8006f44:	b928      	cbnz	r0, 8006f52 <__cxa_begin_catch+0x24>
 8006f46:	b10a      	cbz	r2, 8006f4c <__cxa_begin_catch+0x1e>
 8006f48:	f7ff fed2 	bl	8006cf0 <_ZSt9terminatev>
 8006f4c:	600c      	str	r4, [r1, #0]
 8006f4e:	4614      	mov	r4, r2
 8006f50:	e015      	b.n	8006f7e <__cxa_begin_catch+0x50>
 8006f52:	f855 3c0c 	ldr.w	r3, [r5, #-12]
 8006f56:	2b00      	cmp	r3, #0
 8006f58:	bfb4      	ite	lt
 8006f5a:	f1c3 0301 	rsblt	r3, r3, #1
 8006f5e:	3301      	addge	r3, #1
 8006f60:	f845 3c0c 	str.w	r3, [r5, #-12]
 8006f64:	684b      	ldr	r3, [r1, #4]
 8006f66:	42a2      	cmp	r2, r4
 8006f68:	f103 33ff 	add.w	r3, r3, #4294967295
 8006f6c:	604b      	str	r3, [r1, #4]
 8006f6e:	4628      	mov	r0, r5
 8006f70:	bf1c      	itt	ne
 8006f72:	f845 2c10 	strne.w	r2, [r5, #-16]
 8006f76:	600c      	strne	r4, [r1, #0]
 8006f78:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8006f7a:	f7f9 fca5 	bl	80008c8 <_Unwind_Complete>
 8006f7e:	4620      	mov	r0, r4
 8006f80:	bd38      	pop	{r3, r4, r5, pc}
	...

08006f84 <cosf>:
 8006f84:	ee10 3a10 	vmov	r3, s0
 8006f88:	b507      	push	{r0, r1, r2, lr}
 8006f8a:	4a1c      	ldr	r2, [pc, #112]	; (8006ffc <cosf+0x78>)
 8006f8c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8006f90:	4293      	cmp	r3, r2
 8006f92:	dc02      	bgt.n	8006f9a <cosf+0x16>
 8006f94:	eddf 0a1a 	vldr	s1, [pc, #104]	; 8007000 <cosf+0x7c>
 8006f98:	e013      	b.n	8006fc2 <cosf+0x3e>
 8006f9a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8006f9e:	db02      	blt.n	8006fa6 <cosf+0x22>
 8006fa0:	ee30 0a40 	vsub.f32	s0, s0, s0
 8006fa4:	e027      	b.n	8006ff6 <cosf+0x72>
 8006fa6:	4668      	mov	r0, sp
 8006fa8:	f000 f91a 	bl	80071e0 <__ieee754_rem_pio2f>
 8006fac:	f000 0003 	and.w	r0, r0, #3
 8006fb0:	2801      	cmp	r0, #1
 8006fb2:	d009      	beq.n	8006fc8 <cosf+0x44>
 8006fb4:	2802      	cmp	r0, #2
 8006fb6:	d00e      	beq.n	8006fd6 <cosf+0x52>
 8006fb8:	b9b0      	cbnz	r0, 8006fe8 <cosf+0x64>
 8006fba:	eddd 0a01 	vldr	s1, [sp, #4]
 8006fbe:	ed9d 0a00 	vldr	s0, [sp]
 8006fc2:	f000 fa37 	bl	8007434 <__kernel_cosf>
 8006fc6:	e016      	b.n	8006ff6 <cosf+0x72>
 8006fc8:	eddd 0a01 	vldr	s1, [sp, #4]
 8006fcc:	ed9d 0a00 	vldr	s0, [sp]
 8006fd0:	f000 fcf4 	bl	80079bc <__kernel_sinf>
 8006fd4:	e005      	b.n	8006fe2 <cosf+0x5e>
 8006fd6:	eddd 0a01 	vldr	s1, [sp, #4]
 8006fda:	ed9d 0a00 	vldr	s0, [sp]
 8006fde:	f000 fa29 	bl	8007434 <__kernel_cosf>
 8006fe2:	eeb1 0a40 	vneg.f32	s0, s0
 8006fe6:	e006      	b.n	8006ff6 <cosf+0x72>
 8006fe8:	2001      	movs	r0, #1
 8006fea:	eddd 0a01 	vldr	s1, [sp, #4]
 8006fee:	ed9d 0a00 	vldr	s0, [sp]
 8006ff2:	f000 fce3 	bl	80079bc <__kernel_sinf>
 8006ff6:	b003      	add	sp, #12
 8006ff8:	f85d fb04 	ldr.w	pc, [sp], #4
 8006ffc:	3f490fd8 	.word	0x3f490fd8
 8007000:	00000000 	.word	0x00000000

08007004 <sinf>:
 8007004:	ee10 3a10 	vmov	r3, s0
 8007008:	b507      	push	{r0, r1, r2, lr}
 800700a:	4a1d      	ldr	r2, [pc, #116]	; (8007080 <sinf+0x7c>)
 800700c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8007010:	4293      	cmp	r3, r2
 8007012:	dc03      	bgt.n	800701c <sinf+0x18>
 8007014:	2000      	movs	r0, #0
 8007016:	eddf 0a1b 	vldr	s1, [pc, #108]	; 8007084 <sinf+0x80>
 800701a:	e014      	b.n	8007046 <sinf+0x42>
 800701c:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8007020:	db02      	blt.n	8007028 <sinf+0x24>
 8007022:	ee30 0a40 	vsub.f32	s0, s0, s0
 8007026:	e028      	b.n	800707a <sinf+0x76>
 8007028:	4668      	mov	r0, sp
 800702a:	f000 f8d9 	bl	80071e0 <__ieee754_rem_pio2f>
 800702e:	f000 0003 	and.w	r0, r0, #3
 8007032:	2801      	cmp	r0, #1
 8007034:	d00a      	beq.n	800704c <sinf+0x48>
 8007036:	2802      	cmp	r0, #2
 8007038:	d00f      	beq.n	800705a <sinf+0x56>
 800703a:	b9b0      	cbnz	r0, 800706a <sinf+0x66>
 800703c:	eddd 0a01 	vldr	s1, [sp, #4]
 8007040:	ed9d 0a00 	vldr	s0, [sp]
 8007044:	2001      	movs	r0, #1
 8007046:	f000 fcb9 	bl	80079bc <__kernel_sinf>
 800704a:	e016      	b.n	800707a <sinf+0x76>
 800704c:	eddd 0a01 	vldr	s1, [sp, #4]
 8007050:	ed9d 0a00 	vldr	s0, [sp]
 8007054:	f000 f9ee 	bl	8007434 <__kernel_cosf>
 8007058:	e00f      	b.n	800707a <sinf+0x76>
 800705a:	2001      	movs	r0, #1
 800705c:	eddd 0a01 	vldr	s1, [sp, #4]
 8007060:	ed9d 0a00 	vldr	s0, [sp]
 8007064:	f000 fcaa 	bl	80079bc <__kernel_sinf>
 8007068:	e005      	b.n	8007076 <sinf+0x72>
 800706a:	eddd 0a01 	vldr	s1, [sp, #4]
 800706e:	ed9d 0a00 	vldr	s0, [sp]
 8007072:	f000 f9df 	bl	8007434 <__kernel_cosf>
 8007076:	eeb1 0a40 	vneg.f32	s0, s0
 800707a:	b003      	add	sp, #12
 800707c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007080:	3f490fd8 	.word	0x3f490fd8
 8007084:	00000000 	.word	0x00000000

08007088 <atan2f>:
 8007088:	f000 b800 	b.w	800708c <__ieee754_atan2f>

0800708c <__ieee754_atan2f>:
 800708c:	ee10 2a90 	vmov	r2, s1
 8007090:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 8007094:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8007098:	b510      	push	{r4, lr}
 800709a:	eef0 7a40 	vmov.f32	s15, s0
 800709e:	dc06      	bgt.n	80070ae <__ieee754_atan2f+0x22>
 80070a0:	ee10 0a10 	vmov	r0, s0
 80070a4:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 80070a8:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 80070ac:	dd02      	ble.n	80070b4 <__ieee754_atan2f+0x28>
 80070ae:	ee30 0aa7 	vadd.f32	s0, s1, s15
 80070b2:	bd10      	pop	{r4, pc}
 80070b4:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
 80070b8:	d103      	bne.n	80070c2 <__ieee754_atan2f+0x36>
 80070ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80070be:	f000 bcc5 	b.w	8007a4c <atanf>
 80070c2:	1794      	asrs	r4, r2, #30
 80070c4:	f004 0402 	and.w	r4, r4, #2
 80070c8:	ea44 74d0 	orr.w	r4, r4, r0, lsr #31
 80070cc:	b943      	cbnz	r3, 80070e0 <__ieee754_atan2f+0x54>
 80070ce:	2c02      	cmp	r4, #2
 80070d0:	d06c      	beq.n	80071ac <__ieee754_atan2f+0x120>
 80070d2:	ed9f 0a38 	vldr	s0, [pc, #224]	; 80071b4 <__ieee754_atan2f+0x128>
 80070d6:	2c03      	cmp	r4, #3
 80070d8:	bf18      	it	ne
 80070da:	eeb0 0a67 	vmovne.f32	s0, s15
 80070de:	bd10      	pop	{r4, pc}
 80070e0:	b341      	cbz	r1, 8007134 <__ieee754_atan2f+0xa8>
 80070e2:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 80070e6:	d122      	bne.n	800712e <__ieee754_atan2f+0xa2>
 80070e8:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 80070ec:	d10f      	bne.n	800710e <__ieee754_atan2f+0x82>
 80070ee:	2c02      	cmp	r4, #2
 80070f0:	d007      	beq.n	8007102 <__ieee754_atan2f+0x76>
 80070f2:	2c03      	cmp	r4, #3
 80070f4:	d008      	beq.n	8007108 <__ieee754_atan2f+0x7c>
 80070f6:	2c01      	cmp	r4, #1
 80070f8:	ed9f 0a2f 	vldr	s0, [pc, #188]	; 80071b8 <__ieee754_atan2f+0x12c>
 80070fc:	eddf 7a2f 	vldr	s15, [pc, #188]	; 80071bc <__ieee754_atan2f+0x130>
 8007100:	e00e      	b.n	8007120 <__ieee754_atan2f+0x94>
 8007102:	ed9f 0a2f 	vldr	s0, [pc, #188]	; 80071c0 <__ieee754_atan2f+0x134>
 8007106:	bd10      	pop	{r4, pc}
 8007108:	ed9f 0a2e 	vldr	s0, [pc, #184]	; 80071c4 <__ieee754_atan2f+0x138>
 800710c:	bd10      	pop	{r4, pc}
 800710e:	2c02      	cmp	r4, #2
 8007110:	d04c      	beq.n	80071ac <__ieee754_atan2f+0x120>
 8007112:	2c03      	cmp	r4, #3
 8007114:	d008      	beq.n	8007128 <__ieee754_atan2f+0x9c>
 8007116:	ed9f 0a2c 	vldr	s0, [pc, #176]	; 80071c8 <__ieee754_atan2f+0x13c>
 800711a:	eddf 7a2c 	vldr	s15, [pc, #176]	; 80071cc <__ieee754_atan2f+0x140>
 800711e:	2c01      	cmp	r4, #1
 8007120:	bf08      	it	eq
 8007122:	eeb0 0a67 	vmoveq.f32	s0, s15
 8007126:	bd10      	pop	{r4, pc}
 8007128:	ed9f 0a22 	vldr	s0, [pc, #136]	; 80071b4 <__ieee754_atan2f+0x128>
 800712c:	bd10      	pop	{r4, pc}
 800712e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8007132:	d108      	bne.n	8007146 <__ieee754_atan2f+0xba>
 8007134:	eddf 7a26 	vldr	s15, [pc, #152]	; 80071d0 <__ieee754_atan2f+0x144>
 8007138:	ed9f 0a26 	vldr	s0, [pc, #152]	; 80071d4 <__ieee754_atan2f+0x148>
 800713c:	2800      	cmp	r0, #0
 800713e:	bfa8      	it	ge
 8007140:	eeb0 0a67 	vmovge.f32	s0, s15
 8007144:	bd10      	pop	{r4, pc}
 8007146:	1a5b      	subs	r3, r3, r1
 8007148:	15db      	asrs	r3, r3, #23
 800714a:	2b3c      	cmp	r3, #60	; 0x3c
 800714c:	dc0a      	bgt.n	8007164 <__ieee754_atan2f+0xd8>
 800714e:	2a00      	cmp	r2, #0
 8007150:	da01      	bge.n	8007156 <__ieee754_atan2f+0xca>
 8007152:	333c      	adds	r3, #60	; 0x3c
 8007154:	db09      	blt.n	800716a <__ieee754_atan2f+0xde>
 8007156:	ee87 0aa0 	vdiv.f32	s0, s15, s1
 800715a:	f000 fd4d 	bl	8007bf8 <fabsf>
 800715e:	f000 fc75 	bl	8007a4c <atanf>
 8007162:	e004      	b.n	800716e <__ieee754_atan2f+0xe2>
 8007164:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 80071d0 <__ieee754_atan2f+0x144>
 8007168:	e001      	b.n	800716e <__ieee754_atan2f+0xe2>
 800716a:	ed9f 0a17 	vldr	s0, [pc, #92]	; 80071c8 <__ieee754_atan2f+0x13c>
 800716e:	2c01      	cmp	r4, #1
 8007170:	d003      	beq.n	800717a <__ieee754_atan2f+0xee>
 8007172:	2c02      	cmp	r4, #2
 8007174:	d008      	beq.n	8007188 <__ieee754_atan2f+0xfc>
 8007176:	b984      	cbnz	r4, 800719a <__ieee754_atan2f+0x10e>
 8007178:	bd10      	pop	{r4, pc}
 800717a:	ee10 3a10 	vmov	r3, s0
 800717e:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8007182:	ee00 3a10 	vmov	s0, r3
 8007186:	bd10      	pop	{r4, pc}
 8007188:	eddf 0a13 	vldr	s1, [pc, #76]	; 80071d8 <__ieee754_atan2f+0x14c>
 800718c:	ee30 0a20 	vadd.f32	s0, s0, s1
 8007190:	eddf 0a12 	vldr	s1, [pc, #72]	; 80071dc <__ieee754_atan2f+0x150>
 8007194:	ee30 0ac0 	vsub.f32	s0, s1, s0
 8007198:	bd10      	pop	{r4, pc}
 800719a:	eddf 0a0f 	vldr	s1, [pc, #60]	; 80071d8 <__ieee754_atan2f+0x14c>
 800719e:	ee30 0a20 	vadd.f32	s0, s0, s1
 80071a2:	eddf 0a0e 	vldr	s1, [pc, #56]	; 80071dc <__ieee754_atan2f+0x150>
 80071a6:	ee30 0a60 	vsub.f32	s0, s0, s1
 80071aa:	bd10      	pop	{r4, pc}
 80071ac:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 80071dc <__ieee754_atan2f+0x150>
 80071b0:	bd10      	pop	{r4, pc}
 80071b2:	bf00      	nop
 80071b4:	c0490fdb 	.word	0xc0490fdb
 80071b8:	3f490fdb 	.word	0x3f490fdb
 80071bc:	bf490fdb 	.word	0xbf490fdb
 80071c0:	4016cbe4 	.word	0x4016cbe4
 80071c4:	c016cbe4 	.word	0xc016cbe4
 80071c8:	00000000 	.word	0x00000000
 80071cc:	80000000 	.word	0x80000000
 80071d0:	3fc90fdb 	.word	0x3fc90fdb
 80071d4:	bfc90fdb 	.word	0xbfc90fdb
 80071d8:	33bbbd2e 	.word	0x33bbbd2e
 80071dc:	40490fdb 	.word	0x40490fdb

080071e0 <__ieee754_rem_pio2f>:
 80071e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80071e2:	ee10 6a10 	vmov	r6, s0
 80071e6:	4b85      	ldr	r3, [pc, #532]	; (80073fc <__ieee754_rem_pio2f+0x21c>)
 80071e8:	f026 4400 	bic.w	r4, r6, #2147483648	; 0x80000000
 80071ec:	429c      	cmp	r4, r3
 80071ee:	b087      	sub	sp, #28
 80071f0:	4605      	mov	r5, r0
 80071f2:	dc04      	bgt.n	80071fe <__ieee754_rem_pio2f+0x1e>
 80071f4:	2300      	movs	r3, #0
 80071f6:	ed85 0a00 	vstr	s0, [r5]
 80071fa:	6043      	str	r3, [r0, #4]
 80071fc:	e0b7      	b.n	800736e <__ieee754_rem_pio2f+0x18e>
 80071fe:	4b80      	ldr	r3, [pc, #512]	; (8007400 <__ieee754_rem_pio2f+0x220>)
 8007200:	429c      	cmp	r4, r3
 8007202:	dc37      	bgt.n	8007274 <__ieee754_rem_pio2f+0x94>
 8007204:	2e00      	cmp	r6, #0
 8007206:	ed9f 7a7f 	vldr	s14, [pc, #508]	; 8007404 <__ieee754_rem_pio2f+0x224>
 800720a:	4b7f      	ldr	r3, [pc, #508]	; (8007408 <__ieee754_rem_pio2f+0x228>)
 800720c:	f024 040f 	bic.w	r4, r4, #15
 8007210:	dd17      	ble.n	8007242 <__ieee754_rem_pio2f+0x62>
 8007212:	429c      	cmp	r4, r3
 8007214:	ee70 7a47 	vsub.f32	s15, s0, s14
 8007218:	bf09      	itett	eq
 800721a:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 800740c <__ieee754_rem_pio2f+0x22c>
 800721e:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 8007410 <__ieee754_rem_pio2f+0x230>
 8007222:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 8007226:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 8007414 <__ieee754_rem_pio2f+0x234>
 800722a:	ee77 6ac7 	vsub.f32	s13, s15, s14
 800722e:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8007232:	edc0 6a00 	vstr	s13, [r0]
 8007236:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800723a:	edc0 7a01 	vstr	s15, [r0, #4]
 800723e:	2001      	movs	r0, #1
 8007240:	e0da      	b.n	80073f8 <__ieee754_rem_pio2f+0x218>
 8007242:	429c      	cmp	r4, r3
 8007244:	ee70 7a07 	vadd.f32	s15, s0, s14
 8007248:	bf09      	itett	eq
 800724a:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 800740c <__ieee754_rem_pio2f+0x22c>
 800724e:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 8007410 <__ieee754_rem_pio2f+0x230>
 8007252:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 8007256:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 8007414 <__ieee754_rem_pio2f+0x234>
 800725a:	ee77 6a87 	vadd.f32	s13, s15, s14
 800725e:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8007262:	edc0 6a00 	vstr	s13, [r0]
 8007266:	ee77 7a87 	vadd.f32	s15, s15, s14
 800726a:	edc0 7a01 	vstr	s15, [r0, #4]
 800726e:	f04f 30ff 	mov.w	r0, #4294967295
 8007272:	e0c1      	b.n	80073f8 <__ieee754_rem_pio2f+0x218>
 8007274:	4b68      	ldr	r3, [pc, #416]	; (8007418 <__ieee754_rem_pio2f+0x238>)
 8007276:	429c      	cmp	r4, r3
 8007278:	dc70      	bgt.n	800735c <__ieee754_rem_pio2f+0x17c>
 800727a:	f000 fcbd 	bl	8007bf8 <fabsf>
 800727e:	ed9f 7a67 	vldr	s14, [pc, #412]	; 800741c <__ieee754_rem_pio2f+0x23c>
 8007282:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8007286:	eee0 7a07 	vfma.f32	s15, s0, s14
 800728a:	ed9f 7a5e 	vldr	s14, [pc, #376]	; 8007404 <__ieee754_rem_pio2f+0x224>
 800728e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8007292:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 8007296:	ee17 0a90 	vmov	r0, s15
 800729a:	eef1 7a46 	vneg.f32	s15, s12
 800729e:	eea7 0a87 	vfma.f32	s0, s15, s14
 80072a2:	281f      	cmp	r0, #31
 80072a4:	ed9f 7a5a 	vldr	s14, [pc, #360]	; 8007410 <__ieee754_rem_pio2f+0x230>
 80072a8:	ee26 7a07 	vmul.f32	s14, s12, s14
 80072ac:	ee70 6a47 	vsub.f32	s13, s0, s14
 80072b0:	ee16 3a90 	vmov	r3, s13
 80072b4:	dc07      	bgt.n	80072c6 <__ieee754_rem_pio2f+0xe6>
 80072b6:	1e47      	subs	r7, r0, #1
 80072b8:	4959      	ldr	r1, [pc, #356]	; (8007420 <__ieee754_rem_pio2f+0x240>)
 80072ba:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 80072be:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
 80072c2:	428a      	cmp	r2, r1
 80072c4:	d105      	bne.n	80072d2 <__ieee754_rem_pio2f+0xf2>
 80072c6:	15e4      	asrs	r4, r4, #23
 80072c8:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 80072cc:	1aa2      	subs	r2, r4, r2
 80072ce:	2a08      	cmp	r2, #8
 80072d0:	dc01      	bgt.n	80072d6 <__ieee754_rem_pio2f+0xf6>
 80072d2:	602b      	str	r3, [r5, #0]
 80072d4:	e02f      	b.n	8007336 <__ieee754_rem_pio2f+0x156>
 80072d6:	ed9f 7a4d 	vldr	s14, [pc, #308]	; 800740c <__ieee754_rem_pio2f+0x22c>
 80072da:	eef0 6a40 	vmov.f32	s13, s0
 80072de:	eee7 6a87 	vfma.f32	s13, s15, s14
 80072e2:	ee30 0a66 	vsub.f32	s0, s0, s13
 80072e6:	eea7 0a87 	vfma.f32	s0, s15, s14
 80072ea:	ed9f 7a4a 	vldr	s14, [pc, #296]	; 8007414 <__ieee754_rem_pio2f+0x234>
 80072ee:	ee96 0a07 	vfnms.f32	s0, s12, s14
 80072f2:	ee76 5ac0 	vsub.f32	s11, s13, s0
 80072f6:	eeb0 7a40 	vmov.f32	s14, s0
 80072fa:	ee15 3a90 	vmov	r3, s11
 80072fe:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8007302:	1aa4      	subs	r4, r4, r2
 8007304:	2c19      	cmp	r4, #25
 8007306:	dc04      	bgt.n	8007312 <__ieee754_rem_pio2f+0x132>
 8007308:	edc5 5a00 	vstr	s11, [r5]
 800730c:	eeb0 0a66 	vmov.f32	s0, s13
 8007310:	e011      	b.n	8007336 <__ieee754_rem_pio2f+0x156>
 8007312:	eddf 5a44 	vldr	s11, [pc, #272]	; 8007424 <__ieee754_rem_pio2f+0x244>
 8007316:	eeb0 0a66 	vmov.f32	s0, s13
 800731a:	eea7 0aa5 	vfma.f32	s0, s15, s11
 800731e:	ee36 7ac0 	vsub.f32	s14, s13, s0
 8007322:	eea7 7aa5 	vfma.f32	s14, s15, s11
 8007326:	eddf 7a40 	vldr	s15, [pc, #256]	; 8007428 <__ieee754_rem_pio2f+0x248>
 800732a:	ee96 7a27 	vfnms.f32	s14, s12, s15
 800732e:	ee70 7a47 	vsub.f32	s15, s0, s14
 8007332:	edc5 7a00 	vstr	s15, [r5]
 8007336:	edd5 6a00 	vldr	s13, [r5]
 800733a:	ee70 7a66 	vsub.f32	s15, s0, s13
 800733e:	2e00      	cmp	r6, #0
 8007340:	ee37 0ac7 	vsub.f32	s0, s15, s14
 8007344:	ed85 0a01 	vstr	s0, [r5, #4]
 8007348:	da56      	bge.n	80073f8 <__ieee754_rem_pio2f+0x218>
 800734a:	eef1 6a66 	vneg.f32	s13, s13
 800734e:	eeb1 0a40 	vneg.f32	s0, s0
 8007352:	edc5 6a00 	vstr	s13, [r5]
 8007356:	ed85 0a01 	vstr	s0, [r5, #4]
 800735a:	e04c      	b.n	80073f6 <__ieee754_rem_pio2f+0x216>
 800735c:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8007360:	db07      	blt.n	8007372 <__ieee754_rem_pio2f+0x192>
 8007362:	ee70 7a40 	vsub.f32	s15, s0, s0
 8007366:	edc0 7a01 	vstr	s15, [r0, #4]
 800736a:	edc0 7a00 	vstr	s15, [r0]
 800736e:	2000      	movs	r0, #0
 8007370:	e042      	b.n	80073f8 <__ieee754_rem_pio2f+0x218>
 8007372:	15e2      	asrs	r2, r4, #23
 8007374:	3a86      	subs	r2, #134	; 0x86
 8007376:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
 800737a:	ee06 3a90 	vmov	s13, r3
 800737e:	eebd 7ae6 	vcvt.s32.f32	s14, s13
 8007382:	eddf 7a2a 	vldr	s15, [pc, #168]	; 800742c <__ieee754_rem_pio2f+0x24c>
 8007386:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800738a:	ed8d 7a03 	vstr	s14, [sp, #12]
 800738e:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8007392:	ee27 7a27 	vmul.f32	s14, s14, s15
 8007396:	eefd 6ac7 	vcvt.s32.f32	s13, s14
 800739a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800739e:	ee37 7a66 	vsub.f32	s14, s14, s13
 80073a2:	edcd 6a04 	vstr	s13, [sp, #16]
 80073a6:	ee67 7a27 	vmul.f32	s15, s14, s15
 80073aa:	eef5 7a40 	vcmp.f32	s15, #0.0
 80073ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80073b2:	edcd 7a05 	vstr	s15, [sp, #20]
 80073b6:	d107      	bne.n	80073c8 <__ieee754_rem_pio2f+0x1e8>
 80073b8:	eef5 6a40 	vcmp.f32	s13, #0.0
 80073bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80073c0:	bf14      	ite	ne
 80073c2:	2302      	movne	r3, #2
 80073c4:	2301      	moveq	r3, #1
 80073c6:	e000      	b.n	80073ca <__ieee754_rem_pio2f+0x1ea>
 80073c8:	2303      	movs	r3, #3
 80073ca:	4919      	ldr	r1, [pc, #100]	; (8007430 <__ieee754_rem_pio2f+0x250>)
 80073cc:	9101      	str	r1, [sp, #4]
 80073ce:	2102      	movs	r1, #2
 80073d0:	9100      	str	r1, [sp, #0]
 80073d2:	a803      	add	r0, sp, #12
 80073d4:	4629      	mov	r1, r5
 80073d6:	f000 f88b 	bl	80074f0 <__kernel_rem_pio2f>
 80073da:	2e00      	cmp	r6, #0
 80073dc:	da0c      	bge.n	80073f8 <__ieee754_rem_pio2f+0x218>
 80073de:	edd5 7a00 	vldr	s15, [r5]
 80073e2:	eef1 7a67 	vneg.f32	s15, s15
 80073e6:	edc5 7a00 	vstr	s15, [r5]
 80073ea:	edd5 7a01 	vldr	s15, [r5, #4]
 80073ee:	eef1 7a67 	vneg.f32	s15, s15
 80073f2:	edc5 7a01 	vstr	s15, [r5, #4]
 80073f6:	4240      	negs	r0, r0
 80073f8:	b007      	add	sp, #28
 80073fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80073fc:	3f490fd8 	.word	0x3f490fd8
 8007400:	4016cbe3 	.word	0x4016cbe3
 8007404:	3fc90f80 	.word	0x3fc90f80
 8007408:	3fc90fd0 	.word	0x3fc90fd0
 800740c:	37354400 	.word	0x37354400
 8007410:	37354443 	.word	0x37354443
 8007414:	2e85a308 	.word	0x2e85a308
 8007418:	43490f80 	.word	0x43490f80
 800741c:	3f22f984 	.word	0x3f22f984
 8007420:	0800930c 	.word	0x0800930c
 8007424:	2e85a300 	.word	0x2e85a300
 8007428:	248d3132 	.word	0x248d3132
 800742c:	43800000 	.word	0x43800000
 8007430:	0800938c 	.word	0x0800938c

08007434 <__kernel_cosf>:
 8007434:	ee10 3a10 	vmov	r3, s0
 8007438:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800743c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8007440:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8007444:	da05      	bge.n	8007452 <__kernel_cosf+0x1e>
 8007446:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 800744a:	ee17 2a90 	vmov	r2, s15
 800744e:	2a00      	cmp	r2, #0
 8007450:	d03b      	beq.n	80074ca <__kernel_cosf+0x96>
 8007452:	ee20 7a00 	vmul.f32	s14, s0, s0
 8007456:	ed9f 6a1e 	vldr	s12, [pc, #120]	; 80074d0 <__kernel_cosf+0x9c>
 800745a:	eddf 7a1e 	vldr	s15, [pc, #120]	; 80074d4 <__kernel_cosf+0xa0>
 800745e:	eddf 5a1e 	vldr	s11, [pc, #120]	; 80074d8 <__kernel_cosf+0xa4>
 8007462:	4a1e      	ldr	r2, [pc, #120]	; (80074dc <__kernel_cosf+0xa8>)
 8007464:	eea7 6a27 	vfma.f32	s12, s14, s15
 8007468:	4293      	cmp	r3, r2
 800746a:	ee60 0a20 	vmul.f32	s1, s0, s1
 800746e:	eee7 5a06 	vfma.f32	s11, s14, s12
 8007472:	ed9f 6a1b 	vldr	s12, [pc, #108]	; 80074e0 <__kernel_cosf+0xac>
 8007476:	eea7 6a25 	vfma.f32	s12, s14, s11
 800747a:	eddf 5a1a 	vldr	s11, [pc, #104]	; 80074e4 <__kernel_cosf+0xb0>
 800747e:	eee7 5a06 	vfma.f32	s11, s14, s12
 8007482:	ed9f 6a19 	vldr	s12, [pc, #100]	; 80074e8 <__kernel_cosf+0xb4>
 8007486:	eea7 6a25 	vfma.f32	s12, s14, s11
 800748a:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
 800748e:	ee26 6a07 	vmul.f32	s12, s12, s14
 8007492:	dc06      	bgt.n	80074a2 <__kernel_cosf+0x6e>
 8007494:	eed7 0a06 	vfnms.f32	s1, s14, s12
 8007498:	eed7 0a25 	vfnms.f32	s1, s14, s11
 800749c:	ee36 0ae0 	vsub.f32	s0, s13, s1
 80074a0:	4770      	bx	lr
 80074a2:	4a12      	ldr	r2, [pc, #72]	; (80074ec <__kernel_cosf+0xb8>)
 80074a4:	4293      	cmp	r3, r2
 80074a6:	bfda      	itte	le
 80074a8:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 80074ac:	ee07 3a90 	vmovle	s15, r3
 80074b0:	eef5 7a02 	vmovgt.f32	s15, #82	; 0x3e900000  0.2812500
 80074b4:	ee76 6ae7 	vsub.f32	s13, s13, s15
 80074b8:	eed7 0a06 	vfnms.f32	s1, s14, s12
 80074bc:	eed7 7a25 	vfnms.f32	s15, s14, s11
 80074c0:	ee77 7ae0 	vsub.f32	s15, s15, s1
 80074c4:	ee36 0ae7 	vsub.f32	s0, s13, s15
 80074c8:	4770      	bx	lr
 80074ca:	eeb0 0a66 	vmov.f32	s0, s13
 80074ce:	4770      	bx	lr
 80074d0:	310f74f6 	.word	0x310f74f6
 80074d4:	ad47d74e 	.word	0xad47d74e
 80074d8:	b493f27c 	.word	0xb493f27c
 80074dc:	3e999999 	.word	0x3e999999
 80074e0:	37d00d01 	.word	0x37d00d01
 80074e4:	bab60b61 	.word	0xbab60b61
 80074e8:	3d2aaaab 	.word	0x3d2aaaab
 80074ec:	3f480000 	.word	0x3f480000

080074f0 <__kernel_rem_pio2f>:
 80074f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80074f4:	ed2d 8b04 	vpush	{d8-d9}
 80074f8:	b0d5      	sub	sp, #340	; 0x154
 80074fa:	460f      	mov	r7, r1
 80074fc:	9000      	str	r0, [sp, #0]
 80074fe:	49cf      	ldr	r1, [pc, #828]	; (800783c <__kernel_rem_pio2f+0x34c>)
 8007500:	9862      	ldr	r0, [sp, #392]	; 0x188
 8007502:	9e63      	ldr	r6, [sp, #396]	; 0x18c
 8007504:	f851 9020 	ldr.w	r9, [r1, r0, lsl #2]
 8007508:	f103 3aff 	add.w	sl, r3, #4294967295
 800750c:	1ed0      	subs	r0, r2, #3
 800750e:	2408      	movs	r4, #8
 8007510:	fb90 f0f4 	sdiv	r0, r0, r4
 8007514:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 8007518:	1c45      	adds	r5, r0, #1
 800751a:	ebca 0e00 	rsb	lr, sl, r0
 800751e:	eba2 05c5 	sub.w	r5, r2, r5, lsl #3
 8007522:	eb09 0c0a 	add.w	ip, r9, sl
 8007526:	ac18      	add	r4, sp, #96	; 0x60
 8007528:	eb06 088e 	add.w	r8, r6, lr, lsl #2
 800752c:	2200      	movs	r2, #0
 800752e:	4562      	cmp	r2, ip
 8007530:	dc0e      	bgt.n	8007550 <__kernel_rem_pio2f+0x60>
 8007532:	eb1e 0f02 	cmn.w	lr, r2
 8007536:	bf57      	itett	pl
 8007538:	f858 1022 	ldrpl.w	r1, [r8, r2, lsl #2]
 800753c:	eddf 7ac0 	vldrmi	s15, [pc, #768]	; 8007840 <__kernel_rem_pio2f+0x350>
 8007540:	ee07 1a90 	vmovpl	s15, r1
 8007544:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 8007548:	3201      	adds	r2, #1
 800754a:	ece4 7a01 	vstmia	r4!, {s15}
 800754e:	e7ee      	b.n	800752e <__kernel_rem_pio2f+0x3e>
 8007550:	f50d 7c80 	add.w	ip, sp, #256	; 0x100
 8007554:	2400      	movs	r4, #0
 8007556:	454c      	cmp	r4, r9
 8007558:	dc18      	bgt.n	800758c <__kernel_rem_pio2f+0x9c>
 800755a:	191a      	adds	r2, r3, r4
 800755c:	a918      	add	r1, sp, #96	; 0x60
 800755e:	f8dd e000 	ldr.w	lr, [sp]
 8007562:	eddf 7ab7 	vldr	s15, [pc, #732]	; 8007840 <__kernel_rem_pio2f+0x350>
 8007566:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 800756a:	f04f 0800 	mov.w	r8, #0
 800756e:	45d0      	cmp	r8, sl
 8007570:	dc08      	bgt.n	8007584 <__kernel_rem_pio2f+0x94>
 8007572:	ecfe 6a01 	vldmia	lr!, {s13}
 8007576:	ed32 7a01 	vldmdb	r2!, {s14}
 800757a:	f108 0801 	add.w	r8, r8, #1
 800757e:	eee6 7a87 	vfma.f32	s15, s13, s14
 8007582:	e7f4      	b.n	800756e <__kernel_rem_pio2f+0x7e>
 8007584:	ecec 7a01 	vstmia	ip!, {s15}
 8007588:	3401      	adds	r4, #1
 800758a:	e7e4      	b.n	8007556 <__kernel_rem_pio2f+0x66>
 800758c:	aa04      	add	r2, sp, #16
 800758e:	eb02 0289 	add.w	r2, r2, r9, lsl #2
 8007592:	9201      	str	r2, [sp, #4]
 8007594:	eddf 8aab 	vldr	s17, [pc, #684]	; 8007844 <__kernel_rem_pio2f+0x354>
 8007598:	ed9f 9aab 	vldr	s18, [pc, #684]	; 8007848 <__kernel_rem_pio2f+0x358>
 800759c:	eb06 0280 	add.w	r2, r6, r0, lsl #2
 80075a0:	9202      	str	r2, [sp, #8]
 80075a2:	464c      	mov	r4, r9
 80075a4:	aa54      	add	r2, sp, #336	; 0x150
 80075a6:	f104 4880 	add.w	r8, r4, #1073741824	; 0x40000000
 80075aa:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80075ae:	f108 38ff 	add.w	r8, r8, #4294967295
 80075b2:	ed12 0a14 	vldr	s0, [r2, #-80]	; 0xffffffb0
 80075b6:	ea4f 0888 	mov.w	r8, r8, lsl #2
 80075ba:	aa54      	add	r2, sp, #336	; 0x150
 80075bc:	eb02 0008 	add.w	r0, r2, r8
 80075c0:	384c      	subs	r0, #76	; 0x4c
 80075c2:	2200      	movs	r2, #0
 80075c4:	1aa6      	subs	r6, r4, r2
 80075c6:	2e00      	cmp	r6, #0
 80075c8:	dd14      	ble.n	80075f4 <__kernel_rem_pio2f+0x104>
 80075ca:	ee60 7a28 	vmul.f32	s15, s0, s17
 80075ce:	ae04      	add	r6, sp, #16
 80075d0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80075d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80075d8:	eea7 0ac9 	vfms.f32	s0, s15, s18
 80075dc:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80075e0:	ee10 1a10 	vmov	r1, s0
 80075e4:	ed30 0a01 	vldmdb	r0!, {s0}
 80075e8:	f846 1022 	str.w	r1, [r6, r2, lsl #2]
 80075ec:	ee37 0a80 	vadd.f32	s0, s15, s0
 80075f0:	3201      	adds	r2, #1
 80075f2:	e7e7      	b.n	80075c4 <__kernel_rem_pio2f+0xd4>
 80075f4:	4628      	mov	r0, r5
 80075f6:	9303      	str	r3, [sp, #12]
 80075f8:	f000 fb48 	bl	8007c8c <scalbnf>
 80075fc:	eeb0 8a40 	vmov.f32	s16, s0
 8007600:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 8007604:	ee28 0a00 	vmul.f32	s0, s16, s0
 8007608:	f000 fafe 	bl	8007c08 <floorf>
 800760c:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 8007610:	eea0 8a67 	vfms.f32	s16, s0, s15
 8007614:	2d00      	cmp	r5, #0
 8007616:	9b03      	ldr	r3, [sp, #12]
 8007618:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 800761c:	ee17 ba90 	vmov	fp, s15
 8007620:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8007624:	ee38 8a67 	vsub.f32	s16, s16, s15
 8007628:	dd14      	ble.n	8007654 <__kernel_rem_pio2f+0x164>
 800762a:	f104 3eff 	add.w	lr, r4, #4294967295
 800762e:	aa04      	add	r2, sp, #16
 8007630:	f1c5 0608 	rsb	r6, r5, #8
 8007634:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
 8007638:	fa42 f006 	asr.w	r0, r2, r6
 800763c:	fa00 f606 	lsl.w	r6, r0, r6
 8007640:	a904      	add	r1, sp, #16
 8007642:	1b92      	subs	r2, r2, r6
 8007644:	f1c5 0607 	rsb	r6, r5, #7
 8007648:	4483      	add	fp, r0
 800764a:	f841 202e 	str.w	r2, [r1, lr, lsl #2]
 800764e:	fa42 f606 	asr.w	r6, r2, r6
 8007652:	e00f      	b.n	8007674 <__kernel_rem_pio2f+0x184>
 8007654:	d105      	bne.n	8007662 <__kernel_rem_pio2f+0x172>
 8007656:	1e62      	subs	r2, r4, #1
 8007658:	a904      	add	r1, sp, #16
 800765a:	f851 6022 	ldr.w	r6, [r1, r2, lsl #2]
 800765e:	1236      	asrs	r6, r6, #8
 8007660:	e008      	b.n	8007674 <__kernel_rem_pio2f+0x184>
 8007662:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8007666:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800766a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800766e:	da04      	bge.n	800767a <__kernel_rem_pio2f+0x18a>
 8007670:	2600      	movs	r6, #0
 8007672:	e03f      	b.n	80076f4 <__kernel_rem_pio2f+0x204>
 8007674:	2e00      	cmp	r6, #0
 8007676:	dc01      	bgt.n	800767c <__kernel_rem_pio2f+0x18c>
 8007678:	e03c      	b.n	80076f4 <__kernel_rem_pio2f+0x204>
 800767a:	2602      	movs	r6, #2
 800767c:	2200      	movs	r2, #0
 800767e:	f10b 0b01 	add.w	fp, fp, #1
 8007682:	4610      	mov	r0, r2
 8007684:	4294      	cmp	r4, r2
 8007686:	dd0f      	ble.n	80076a8 <__kernel_rem_pio2f+0x1b8>
 8007688:	a904      	add	r1, sp, #16
 800768a:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 800768e:	b918      	cbnz	r0, 8007698 <__kernel_rem_pio2f+0x1a8>
 8007690:	b141      	cbz	r1, 80076a4 <__kernel_rem_pio2f+0x1b4>
 8007692:	f5c1 7080 	rsb	r0, r1, #256	; 0x100
 8007696:	e001      	b.n	800769c <__kernel_rem_pio2f+0x1ac>
 8007698:	f1c1 00ff 	rsb	r0, r1, #255	; 0xff
 800769c:	a904      	add	r1, sp, #16
 800769e:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
 80076a2:	2001      	movs	r0, #1
 80076a4:	3201      	adds	r2, #1
 80076a6:	e7ed      	b.n	8007684 <__kernel_rem_pio2f+0x194>
 80076a8:	2d00      	cmp	r5, #0
 80076aa:	dd15      	ble.n	80076d8 <__kernel_rem_pio2f+0x1e8>
 80076ac:	2d01      	cmp	r5, #1
 80076ae:	d009      	beq.n	80076c4 <__kernel_rem_pio2f+0x1d4>
 80076b0:	2d02      	cmp	r5, #2
 80076b2:	d111      	bne.n	80076d8 <__kernel_rem_pio2f+0x1e8>
 80076b4:	f104 3eff 	add.w	lr, r4, #4294967295
 80076b8:	aa04      	add	r2, sp, #16
 80076ba:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
 80076be:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80076c2:	e006      	b.n	80076d2 <__kernel_rem_pio2f+0x1e2>
 80076c4:	f104 3eff 	add.w	lr, r4, #4294967295
 80076c8:	aa04      	add	r2, sp, #16
 80076ca:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
 80076ce:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 80076d2:	a904      	add	r1, sp, #16
 80076d4:	f841 202e 	str.w	r2, [r1, lr, lsl #2]
 80076d8:	2e02      	cmp	r6, #2
 80076da:	d10b      	bne.n	80076f4 <__kernel_rem_pio2f+0x204>
 80076dc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 80076e0:	ee30 8a48 	vsub.f32	s16, s0, s16
 80076e4:	b130      	cbz	r0, 80076f4 <__kernel_rem_pio2f+0x204>
 80076e6:	4628      	mov	r0, r5
 80076e8:	9303      	str	r3, [sp, #12]
 80076ea:	f000 facf 	bl	8007c8c <scalbnf>
 80076ee:	9b03      	ldr	r3, [sp, #12]
 80076f0:	ee38 8a40 	vsub.f32	s16, s16, s0
 80076f4:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80076f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80076fc:	d154      	bne.n	80077a8 <__kernel_rem_pio2f+0x2b8>
 80076fe:	f104 3cff 	add.w	ip, r4, #4294967295
 8007702:	4660      	mov	r0, ip
 8007704:	2200      	movs	r2, #0
 8007706:	4548      	cmp	r0, r9
 8007708:	db05      	blt.n	8007716 <__kernel_rem_pio2f+0x226>
 800770a:	a904      	add	r1, sp, #16
 800770c:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 8007710:	3801      	subs	r0, #1
 8007712:	430a      	orrs	r2, r1
 8007714:	e7f7      	b.n	8007706 <__kernel_rem_pio2f+0x216>
 8007716:	2a00      	cmp	r2, #0
 8007718:	d13d      	bne.n	8007796 <__kernel_rem_pio2f+0x2a6>
 800771a:	2201      	movs	r2, #1
 800771c:	f06f 0603 	mvn.w	r6, #3
 8007720:	fb06 f002 	mul.w	r0, r6, r2
 8007724:	9901      	ldr	r1, [sp, #4]
 8007726:	5808      	ldr	r0, [r1, r0]
 8007728:	b908      	cbnz	r0, 800772e <__kernel_rem_pio2f+0x23e>
 800772a:	3201      	adds	r2, #1
 800772c:	e7f8      	b.n	8007720 <__kernel_rem_pio2f+0x230>
 800772e:	eb03 0e04 	add.w	lr, r3, r4
 8007732:	1c60      	adds	r0, r4, #1
 8007734:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8007738:	f108 0804 	add.w	r8, r8, #4
 800773c:	2600      	movs	r6, #0
 800773e:	4414      	add	r4, r2
 8007740:	42a0      	cmp	r0, r4
 8007742:	f73f af2f 	bgt.w	80075a4 <__kernel_rem_pio2f+0xb4>
 8007746:	3604      	adds	r6, #4
 8007748:	a918      	add	r1, sp, #96	; 0x60
 800774a:	eb06 020e 	add.w	r2, r6, lr
 800774e:	440a      	add	r2, r1
 8007750:	9902      	ldr	r1, [sp, #8]
 8007752:	f8dd b000 	ldr.w	fp, [sp]
 8007756:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 800775a:	9103      	str	r1, [sp, #12]
 800775c:	ee07 1a90 	vmov	s15, r1
 8007760:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8007764:	f04f 0c00 	mov.w	ip, #0
 8007768:	ed42 7a01 	vstr	s15, [r2, #-4]
 800776c:	eddf 7a34 	vldr	s15, [pc, #208]	; 8007840 <__kernel_rem_pio2f+0x350>
 8007770:	45d4      	cmp	ip, sl
 8007772:	dc08      	bgt.n	8007786 <__kernel_rem_pio2f+0x296>
 8007774:	ecfb 6a01 	vldmia	fp!, {s13}
 8007778:	ed32 7a01 	vldmdb	r2!, {s14}
 800777c:	f10c 0c01 	add.w	ip, ip, #1
 8007780:	eee6 7a87 	vfma.f32	s15, s13, s14
 8007784:	e7f4      	b.n	8007770 <__kernel_rem_pio2f+0x280>
 8007786:	eb06 0208 	add.w	r2, r6, r8
 800778a:	a940      	add	r1, sp, #256	; 0x100
 800778c:	440a      	add	r2, r1
 800778e:	edc2 7a00 	vstr	s15, [r2]
 8007792:	3001      	adds	r0, #1
 8007794:	e7d4      	b.n	8007740 <__kernel_rem_pio2f+0x250>
 8007796:	3d08      	subs	r5, #8
 8007798:	4664      	mov	r4, ip
 800779a:	ab04      	add	r3, sp, #16
 800779c:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80077a0:	bb6b      	cbnz	r3, 80077fe <__kernel_rem_pio2f+0x30e>
 80077a2:	3c01      	subs	r4, #1
 80077a4:	3d08      	subs	r5, #8
 80077a6:	e7f8      	b.n	800779a <__kernel_rem_pio2f+0x2aa>
 80077a8:	4268      	negs	r0, r5
 80077aa:	eeb0 0a48 	vmov.f32	s0, s16
 80077ae:	f000 fa6d 	bl	8007c8c <scalbnf>
 80077b2:	ed9f 7a25 	vldr	s14, [pc, #148]	; 8007848 <__kernel_rem_pio2f+0x358>
 80077b6:	eeb4 0ac7 	vcmpe.f32	s0, s14
 80077ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80077be:	db17      	blt.n	80077f0 <__kernel_rem_pio2f+0x300>
 80077c0:	eddf 7a20 	vldr	s15, [pc, #128]	; 8007844 <__kernel_rem_pio2f+0x354>
 80077c4:	ee60 7a27 	vmul.f32	s15, s0, s15
 80077c8:	aa04      	add	r2, sp, #16
 80077ca:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80077ce:	3508      	adds	r5, #8
 80077d0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80077d4:	eea7 0ac7 	vfms.f32	s0, s15, s14
 80077d8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80077dc:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80077e0:	ee10 3a10 	vmov	r3, s0
 80077e4:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 80077e8:	3401      	adds	r4, #1
 80077ea:	ee17 3a90 	vmov	r3, s15
 80077ee:	e004      	b.n	80077fa <__kernel_rem_pio2f+0x30a>
 80077f0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80077f4:	aa04      	add	r2, sp, #16
 80077f6:	ee10 3a10 	vmov	r3, s0
 80077fa:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 80077fe:	4628      	mov	r0, r5
 8007800:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8007804:	f000 fa42 	bl	8007c8c <scalbnf>
 8007808:	00a3      	lsls	r3, r4, #2
 800780a:	a940      	add	r1, sp, #256	; 0x100
 800780c:	1d1a      	adds	r2, r3, #4
 800780e:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 8007844 <__kernel_rem_pio2f+0x354>
 8007812:	1888      	adds	r0, r1, r2
 8007814:	4621      	mov	r1, r4
 8007816:	2900      	cmp	r1, #0
 8007818:	db18      	blt.n	800784c <__kernel_rem_pio2f+0x35c>
 800781a:	ad04      	add	r5, sp, #16
 800781c:	f855 5021 	ldr.w	r5, [r5, r1, lsl #2]
 8007820:	9500      	str	r5, [sp, #0]
 8007822:	ee07 5a90 	vmov	s15, r5
 8007826:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800782a:	3901      	subs	r1, #1
 800782c:	ee67 7a80 	vmul.f32	s15, s15, s0
 8007830:	ee20 0a07 	vmul.f32	s0, s0, s14
 8007834:	ed60 7a01 	vstmdb	r0!, {s15}
 8007838:	e7ed      	b.n	8007816 <__kernel_rem_pio2f+0x326>
 800783a:	bf00      	nop
 800783c:	080096a4 	.word	0x080096a4
 8007840:	00000000 	.word	0x00000000
 8007844:	3b800000 	.word	0x3b800000
 8007848:	43800000 	.word	0x43800000
 800784c:	f10d 0cb0 	add.w	ip, sp, #176	; 0xb0
 8007850:	2100      	movs	r1, #0
 8007852:	1a65      	subs	r5, r4, r1
 8007854:	d417      	bmi.n	8007886 <__kernel_rem_pio2f+0x396>
 8007856:	a840      	add	r0, sp, #256	; 0x100
 8007858:	f8df e15c 	ldr.w	lr, [pc, #348]	; 80079b8 <__kernel_rem_pio2f+0x4c8>
 800785c:	eddf 7a55 	vldr	s15, [pc, #340]	; 80079b4 <__kernel_rem_pio2f+0x4c4>
 8007860:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8007864:	2000      	movs	r0, #0
 8007866:	4548      	cmp	r0, r9
 8007868:	dc09      	bgt.n	800787e <__kernel_rem_pio2f+0x38e>
 800786a:	4288      	cmp	r0, r1
 800786c:	dc07      	bgt.n	800787e <__kernel_rem_pio2f+0x38e>
 800786e:	ecfe 6a01 	vldmia	lr!, {s13}
 8007872:	ecb5 7a01 	vldmia	r5!, {s14}
 8007876:	3001      	adds	r0, #1
 8007878:	eee6 7a87 	vfma.f32	s15, s13, s14
 800787c:	e7f3      	b.n	8007866 <__kernel_rem_pio2f+0x376>
 800787e:	ecec 7a01 	vstmia	ip!, {s15}
 8007882:	3101      	adds	r1, #1
 8007884:	e7e5      	b.n	8007852 <__kernel_rem_pio2f+0x362>
 8007886:	9962      	ldr	r1, [sp, #392]	; 0x188
 8007888:	2903      	cmp	r1, #3
 800788a:	f200 808c 	bhi.w	80079a6 <__kernel_rem_pio2f+0x4b6>
 800788e:	e8df f001 	tbb	[pc, r1]
 8007892:	070d      	.short	0x070d
 8007894:	0207      	.short	0x0207
 8007896:	a92c      	add	r1, sp, #176	; 0xb0
 8007898:	440b      	add	r3, r1
 800789a:	4619      	mov	r1, r3
 800789c:	4620      	mov	r0, r4
 800789e:	e03b      	b.n	8007918 <__kernel_rem_pio2f+0x428>
 80078a0:	ab2c      	add	r3, sp, #176	; 0xb0
 80078a2:	441a      	add	r2, r3
 80078a4:	ed9f 7a43 	vldr	s14, [pc, #268]	; 80079b4 <__kernel_rem_pio2f+0x4c4>
 80078a8:	4623      	mov	r3, r4
 80078aa:	e011      	b.n	80078d0 <__kernel_rem_pio2f+0x3e0>
 80078ac:	ab2c      	add	r3, sp, #176	; 0xb0
 80078ae:	eddf 7a41 	vldr	s15, [pc, #260]	; 80079b4 <__kernel_rem_pio2f+0x4c4>
 80078b2:	441a      	add	r2, r3
 80078b4:	2c00      	cmp	r4, #0
 80078b6:	db05      	blt.n	80078c4 <__kernel_rem_pio2f+0x3d4>
 80078b8:	ed32 7a01 	vldmdb	r2!, {s14}
 80078bc:	3c01      	subs	r4, #1
 80078be:	ee77 7a87 	vadd.f32	s15, s15, s14
 80078c2:	e7f7      	b.n	80078b4 <__kernel_rem_pio2f+0x3c4>
 80078c4:	b10e      	cbz	r6, 80078ca <__kernel_rem_pio2f+0x3da>
 80078c6:	eef1 7a67 	vneg.f32	s15, s15
 80078ca:	edc7 7a00 	vstr	s15, [r7]
 80078ce:	e06a      	b.n	80079a6 <__kernel_rem_pio2f+0x4b6>
 80078d0:	2b00      	cmp	r3, #0
 80078d2:	db05      	blt.n	80078e0 <__kernel_rem_pio2f+0x3f0>
 80078d4:	ed72 7a01 	vldmdb	r2!, {s15}
 80078d8:	3b01      	subs	r3, #1
 80078da:	ee37 7a27 	vadd.f32	s14, s14, s15
 80078de:	e7f7      	b.n	80078d0 <__kernel_rem_pio2f+0x3e0>
 80078e0:	b116      	cbz	r6, 80078e8 <__kernel_rem_pio2f+0x3f8>
 80078e2:	eef1 7a47 	vneg.f32	s15, s14
 80078e6:	e001      	b.n	80078ec <__kernel_rem_pio2f+0x3fc>
 80078e8:	eef0 7a47 	vmov.f32	s15, s14
 80078ec:	edc7 7a00 	vstr	s15, [r7]
 80078f0:	eddd 7a2c 	vldr	s15, [sp, #176]	; 0xb0
 80078f4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80078f8:	aa2d      	add	r2, sp, #180	; 0xb4
 80078fa:	2301      	movs	r3, #1
 80078fc:	429c      	cmp	r4, r3
 80078fe:	db05      	blt.n	800790c <__kernel_rem_pio2f+0x41c>
 8007900:	ecb2 7a01 	vldmia	r2!, {s14}
 8007904:	3301      	adds	r3, #1
 8007906:	ee77 7a87 	vadd.f32	s15, s15, s14
 800790a:	e7f7      	b.n	80078fc <__kernel_rem_pio2f+0x40c>
 800790c:	b10e      	cbz	r6, 8007912 <__kernel_rem_pio2f+0x422>
 800790e:	eef1 7a67 	vneg.f32	s15, s15
 8007912:	edc7 7a01 	vstr	s15, [r7, #4]
 8007916:	e046      	b.n	80079a6 <__kernel_rem_pio2f+0x4b6>
 8007918:	2800      	cmp	r0, #0
 800791a:	dd0f      	ble.n	800793c <__kernel_rem_pio2f+0x44c>
 800791c:	ed71 7a01 	vldmdb	r1!, {s15}
 8007920:	edd1 6a01 	vldr	s13, [r1, #4]
 8007924:	ee37 7aa6 	vadd.f32	s14, s15, s13
 8007928:	3801      	subs	r0, #1
 800792a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800792e:	ed81 7a00 	vstr	s14, [r1]
 8007932:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8007936:	edc1 7a01 	vstr	s15, [r1, #4]
 800793a:	e7ed      	b.n	8007918 <__kernel_rem_pio2f+0x428>
 800793c:	4621      	mov	r1, r4
 800793e:	2901      	cmp	r1, #1
 8007940:	dd0f      	ble.n	8007962 <__kernel_rem_pio2f+0x472>
 8007942:	ed73 7a01 	vldmdb	r3!, {s15}
 8007946:	edd3 6a01 	vldr	s13, [r3, #4]
 800794a:	ee37 7aa6 	vadd.f32	s14, s15, s13
 800794e:	3901      	subs	r1, #1
 8007950:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8007954:	ed83 7a00 	vstr	s14, [r3]
 8007958:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800795c:	edc3 7a01 	vstr	s15, [r3, #4]
 8007960:	e7ed      	b.n	800793e <__kernel_rem_pio2f+0x44e>
 8007962:	ab2c      	add	r3, sp, #176	; 0xb0
 8007964:	eddf 7a13 	vldr	s15, [pc, #76]	; 80079b4 <__kernel_rem_pio2f+0x4c4>
 8007968:	441a      	add	r2, r3
 800796a:	2c01      	cmp	r4, #1
 800796c:	dd05      	ble.n	800797a <__kernel_rem_pio2f+0x48a>
 800796e:	ed32 7a01 	vldmdb	r2!, {s14}
 8007972:	3c01      	subs	r4, #1
 8007974:	ee77 7a87 	vadd.f32	s15, s15, s14
 8007978:	e7f7      	b.n	800796a <__kernel_rem_pio2f+0x47a>
 800797a:	eddd 6a2c 	vldr	s13, [sp, #176]	; 0xb0
 800797e:	ed9d 7a2d 	vldr	s14, [sp, #180]	; 0xb4
 8007982:	b926      	cbnz	r6, 800798e <__kernel_rem_pio2f+0x49e>
 8007984:	edc7 6a00 	vstr	s13, [r7]
 8007988:	ed87 7a01 	vstr	s14, [r7, #4]
 800798c:	e009      	b.n	80079a2 <__kernel_rem_pio2f+0x4b2>
 800798e:	eef1 6a66 	vneg.f32	s13, s13
 8007992:	eeb1 7a47 	vneg.f32	s14, s14
 8007996:	edc7 6a00 	vstr	s13, [r7]
 800799a:	ed87 7a01 	vstr	s14, [r7, #4]
 800799e:	eef1 7a67 	vneg.f32	s15, s15
 80079a2:	edc7 7a02 	vstr	s15, [r7, #8]
 80079a6:	f00b 0007 	and.w	r0, fp, #7
 80079aa:	b055      	add	sp, #340	; 0x154
 80079ac:	ecbd 8b04 	vpop	{d8-d9}
 80079b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80079b4:	00000000 	.word	0x00000000
 80079b8:	080096b0 	.word	0x080096b0

080079bc <__kernel_sinf>:
 80079bc:	ee10 3a10 	vmov	r3, s0
 80079c0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80079c4:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 80079c8:	da04      	bge.n	80079d4 <__kernel_sinf+0x18>
 80079ca:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 80079ce:	ee17 3a90 	vmov	r3, s15
 80079d2:	b35b      	cbz	r3, 8007a2c <__kernel_sinf+0x70>
 80079d4:	ee20 7a00 	vmul.f32	s14, s0, s0
 80079d8:	eddf 7a15 	vldr	s15, [pc, #84]	; 8007a30 <__kernel_sinf+0x74>
 80079dc:	ed9f 6a15 	vldr	s12, [pc, #84]	; 8007a34 <__kernel_sinf+0x78>
 80079e0:	eea7 6a27 	vfma.f32	s12, s14, s15
 80079e4:	eddf 7a14 	vldr	s15, [pc, #80]	; 8007a38 <__kernel_sinf+0x7c>
 80079e8:	eee7 7a06 	vfma.f32	s15, s14, s12
 80079ec:	ed9f 6a13 	vldr	s12, [pc, #76]	; 8007a3c <__kernel_sinf+0x80>
 80079f0:	eea7 6a27 	vfma.f32	s12, s14, s15
 80079f4:	eddf 7a12 	vldr	s15, [pc, #72]	; 8007a40 <__kernel_sinf+0x84>
 80079f8:	ee60 6a07 	vmul.f32	s13, s0, s14
 80079fc:	eee7 7a06 	vfma.f32	s15, s14, s12
 8007a00:	b930      	cbnz	r0, 8007a10 <__kernel_sinf+0x54>
 8007a02:	ed9f 6a10 	vldr	s12, [pc, #64]	; 8007a44 <__kernel_sinf+0x88>
 8007a06:	eea7 6a27 	vfma.f32	s12, s14, s15
 8007a0a:	eea6 0a86 	vfma.f32	s0, s13, s12
 8007a0e:	4770      	bx	lr
 8007a10:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 8007a14:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 8007a18:	eee0 7a86 	vfma.f32	s15, s1, s12
 8007a1c:	eed7 0a27 	vfnms.f32	s1, s14, s15
 8007a20:	eddf 7a09 	vldr	s15, [pc, #36]	; 8007a48 <__kernel_sinf+0x8c>
 8007a24:	eee6 0aa7 	vfma.f32	s1, s13, s15
 8007a28:	ee30 0a60 	vsub.f32	s0, s0, s1
 8007a2c:	4770      	bx	lr
 8007a2e:	bf00      	nop
 8007a30:	2f2ec9d3 	.word	0x2f2ec9d3
 8007a34:	b2d72f34 	.word	0xb2d72f34
 8007a38:	3638ef1b 	.word	0x3638ef1b
 8007a3c:	b9500d01 	.word	0xb9500d01
 8007a40:	3c088889 	.word	0x3c088889
 8007a44:	be2aaaab 	.word	0xbe2aaaab
 8007a48:	3e2aaaab 	.word	0x3e2aaaab

08007a4c <atanf>:
 8007a4c:	b538      	push	{r3, r4, r5, lr}
 8007a4e:	ee10 5a10 	vmov	r5, s0
 8007a52:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 8007a56:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
 8007a5a:	eef0 7a40 	vmov.f32	s15, s0
 8007a5e:	db0e      	blt.n	8007a7e <atanf+0x32>
 8007a60:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8007a64:	dd02      	ble.n	8007a6c <atanf+0x20>
 8007a66:	ee30 0a00 	vadd.f32	s0, s0, s0
 8007a6a:	bd38      	pop	{r3, r4, r5, pc}
 8007a6c:	eddf 7a4f 	vldr	s15, [pc, #316]	; 8007bac <atanf+0x160>
 8007a70:	ed9f 0a4f 	vldr	s0, [pc, #316]	; 8007bb0 <atanf+0x164>
 8007a74:	2d00      	cmp	r5, #0
 8007a76:	bfc8      	it	gt
 8007a78:	eeb0 0a67 	vmovgt.f32	s0, s15
 8007a7c:	bd38      	pop	{r3, r4, r5, pc}
 8007a7e:	4b4d      	ldr	r3, [pc, #308]	; (8007bb4 <atanf+0x168>)
 8007a80:	429c      	cmp	r4, r3
 8007a82:	dc0f      	bgt.n	8007aa4 <atanf+0x58>
 8007a84:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
 8007a88:	da40      	bge.n	8007b0c <atanf+0xc0>
 8007a8a:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 8007bb8 <atanf+0x16c>
 8007a8e:	ee30 7a07 	vadd.f32	s14, s0, s14
 8007a92:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8007a96:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8007a9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007a9e:	f300 8082 	bgt.w	8007ba6 <atanf+0x15a>
 8007aa2:	e033      	b.n	8007b0c <atanf+0xc0>
 8007aa4:	f000 f8a8 	bl	8007bf8 <fabsf>
 8007aa8:	4b44      	ldr	r3, [pc, #272]	; (8007bbc <atanf+0x170>)
 8007aaa:	429c      	cmp	r4, r3
 8007aac:	dc19      	bgt.n	8007ae2 <atanf+0x96>
 8007aae:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
 8007ab2:	429c      	cmp	r4, r3
 8007ab4:	dc0b      	bgt.n	8007ace <atanf+0x82>
 8007ab6:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8007aba:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8007abe:	eea0 7a27 	vfma.f32	s14, s0, s15
 8007ac2:	2300      	movs	r3, #0
 8007ac4:	ee30 0a27 	vadd.f32	s0, s0, s15
 8007ac8:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8007acc:	e020      	b.n	8007b10 <atanf+0xc4>
 8007ace:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8007ad2:	ee30 7a67 	vsub.f32	s14, s0, s15
 8007ad6:	ee30 0a27 	vadd.f32	s0, s0, s15
 8007ada:	2301      	movs	r3, #1
 8007adc:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8007ae0:	e016      	b.n	8007b10 <atanf+0xc4>
 8007ae2:	4b37      	ldr	r3, [pc, #220]	; (8007bc0 <atanf+0x174>)
 8007ae4:	429c      	cmp	r4, r3
 8007ae6:	dc0b      	bgt.n	8007b00 <atanf+0xb4>
 8007ae8:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
 8007aec:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8007af0:	eea0 7a27 	vfma.f32	s14, s0, s15
 8007af4:	2302      	movs	r3, #2
 8007af6:	ee70 6a67 	vsub.f32	s13, s0, s15
 8007afa:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8007afe:	e007      	b.n	8007b10 <atanf+0xc4>
 8007b00:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8007b04:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8007b08:	2303      	movs	r3, #3
 8007b0a:	e001      	b.n	8007b10 <atanf+0xc4>
 8007b0c:	f04f 33ff 	mov.w	r3, #4294967295
 8007b10:	ee27 6aa7 	vmul.f32	s12, s15, s15
 8007b14:	eddf 6a2b 	vldr	s13, [pc, #172]	; 8007bc4 <atanf+0x178>
 8007b18:	eddf 5a2b 	vldr	s11, [pc, #172]	; 8007bc8 <atanf+0x17c>
 8007b1c:	ed9f 5a2b 	vldr	s10, [pc, #172]	; 8007bcc <atanf+0x180>
 8007b20:	ee26 7a06 	vmul.f32	s14, s12, s12
 8007b24:	1c5a      	adds	r2, r3, #1
 8007b26:	eee7 5a26 	vfma.f32	s11, s14, s13
 8007b2a:	eddf 6a29 	vldr	s13, [pc, #164]	; 8007bd0 <atanf+0x184>
 8007b2e:	eee7 6a25 	vfma.f32	s13, s14, s11
 8007b32:	eddf 5a28 	vldr	s11, [pc, #160]	; 8007bd4 <atanf+0x188>
 8007b36:	eee7 5a26 	vfma.f32	s11, s14, s13
 8007b3a:	eddf 6a27 	vldr	s13, [pc, #156]	; 8007bd8 <atanf+0x18c>
 8007b3e:	eee7 6a25 	vfma.f32	s13, s14, s11
 8007b42:	eddf 5a26 	vldr	s11, [pc, #152]	; 8007bdc <atanf+0x190>
 8007b46:	eee7 5a26 	vfma.f32	s11, s14, s13
 8007b4a:	eddf 6a25 	vldr	s13, [pc, #148]	; 8007be0 <atanf+0x194>
 8007b4e:	eea7 5a26 	vfma.f32	s10, s14, s13
 8007b52:	eddf 6a24 	vldr	s13, [pc, #144]	; 8007be4 <atanf+0x198>
 8007b56:	eee7 6a05 	vfma.f32	s13, s14, s10
 8007b5a:	ed9f 5a23 	vldr	s10, [pc, #140]	; 8007be8 <atanf+0x19c>
 8007b5e:	eea7 5a26 	vfma.f32	s10, s14, s13
 8007b62:	eddf 6a22 	vldr	s13, [pc, #136]	; 8007bec <atanf+0x1a0>
 8007b66:	eee7 6a05 	vfma.f32	s13, s14, s10
 8007b6a:	ee26 7a87 	vmul.f32	s14, s13, s14
 8007b6e:	ee05 7a86 	vmla.f32	s14, s11, s12
 8007b72:	d104      	bne.n	8007b7e <atanf+0x132>
 8007b74:	eeb0 0a67 	vmov.f32	s0, s15
 8007b78:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8007b7c:	bd38      	pop	{r3, r4, r5, pc}
 8007b7e:	4a1c      	ldr	r2, [pc, #112]	; (8007bf0 <atanf+0x1a4>)
 8007b80:	491c      	ldr	r1, [pc, #112]	; (8007bf4 <atanf+0x1a8>)
 8007b82:	009b      	lsls	r3, r3, #2
 8007b84:	441a      	add	r2, r3
 8007b86:	440b      	add	r3, r1
 8007b88:	ed93 0a00 	vldr	s0, [r3]
 8007b8c:	ee97 0a87 	vfnms.f32	s0, s15, s14
 8007b90:	2d00      	cmp	r5, #0
 8007b92:	ed92 7a00 	vldr	s14, [r2]
 8007b96:	ee30 0a67 	vsub.f32	s0, s0, s15
 8007b9a:	ee77 7a40 	vsub.f32	s15, s14, s0
 8007b9e:	da02      	bge.n	8007ba6 <atanf+0x15a>
 8007ba0:	eeb1 0a67 	vneg.f32	s0, s15
 8007ba4:	bd38      	pop	{r3, r4, r5, pc}
 8007ba6:	eeb0 0a67 	vmov.f32	s0, s15
 8007baa:	bd38      	pop	{r3, r4, r5, pc}
 8007bac:	3fc90fdb 	.word	0x3fc90fdb
 8007bb0:	bfc90fdb 	.word	0xbfc90fdb
 8007bb4:	3edfffff 	.word	0x3edfffff
 8007bb8:	7149f2ca 	.word	0x7149f2ca
 8007bbc:	3f97ffff 	.word	0x3f97ffff
 8007bc0:	401bffff 	.word	0x401bffff
 8007bc4:	3c8569d7 	.word	0x3c8569d7
 8007bc8:	3d4bda59 	.word	0x3d4bda59
 8007bcc:	bd6ef16b 	.word	0xbd6ef16b
 8007bd0:	3d886b35 	.word	0x3d886b35
 8007bd4:	3dba2e6e 	.word	0x3dba2e6e
 8007bd8:	3e124925 	.word	0x3e124925
 8007bdc:	3eaaaaab 	.word	0x3eaaaaab
 8007be0:	bd15a221 	.word	0xbd15a221
 8007be4:	bd9d8795 	.word	0xbd9d8795
 8007be8:	bde38e38 	.word	0xbde38e38
 8007bec:	be4ccccd 	.word	0xbe4ccccd
 8007bf0:	080096ec 	.word	0x080096ec
 8007bf4:	080096dc 	.word	0x080096dc

08007bf8 <fabsf>:
 8007bf8:	ee10 3a10 	vmov	r3, s0
 8007bfc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8007c00:	ee00 3a10 	vmov	s0, r3
 8007c04:	4770      	bx	lr
	...

08007c08 <floorf>:
 8007c08:	ee10 3a10 	vmov	r3, s0
 8007c0c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8007c10:	0dca      	lsrs	r2, r1, #23
 8007c12:	3a7f      	subs	r2, #127	; 0x7f
 8007c14:	2a16      	cmp	r2, #22
 8007c16:	dc28      	bgt.n	8007c6a <floorf+0x62>
 8007c18:	2a00      	cmp	r2, #0
 8007c1a:	da0f      	bge.n	8007c3c <floorf+0x34>
 8007c1c:	eddf 7a18 	vldr	s15, [pc, #96]	; 8007c80 <floorf+0x78>
 8007c20:	ee30 0a27 	vadd.f32	s0, s0, s15
 8007c24:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8007c28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007c2c:	dd24      	ble.n	8007c78 <floorf+0x70>
 8007c2e:	2b00      	cmp	r3, #0
 8007c30:	da21      	bge.n	8007c76 <floorf+0x6e>
 8007c32:	4a14      	ldr	r2, [pc, #80]	; (8007c84 <floorf+0x7c>)
 8007c34:	2900      	cmp	r1, #0
 8007c36:	bf18      	it	ne
 8007c38:	4613      	movne	r3, r2
 8007c3a:	e01d      	b.n	8007c78 <floorf+0x70>
 8007c3c:	4912      	ldr	r1, [pc, #72]	; (8007c88 <floorf+0x80>)
 8007c3e:	4111      	asrs	r1, r2
 8007c40:	420b      	tst	r3, r1
 8007c42:	d01b      	beq.n	8007c7c <floorf+0x74>
 8007c44:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8007c80 <floorf+0x78>
 8007c48:	ee30 0a27 	vadd.f32	s0, s0, s15
 8007c4c:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8007c50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007c54:	dd10      	ble.n	8007c78 <floorf+0x70>
 8007c56:	2b00      	cmp	r3, #0
 8007c58:	bfbe      	ittt	lt
 8007c5a:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 8007c5e:	fa40 f202 	asrlt.w	r2, r0, r2
 8007c62:	189b      	addlt	r3, r3, r2
 8007c64:	ea23 0301 	bic.w	r3, r3, r1
 8007c68:	e006      	b.n	8007c78 <floorf+0x70>
 8007c6a:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8007c6e:	d305      	bcc.n	8007c7c <floorf+0x74>
 8007c70:	ee30 0a00 	vadd.f32	s0, s0, s0
 8007c74:	4770      	bx	lr
 8007c76:	2300      	movs	r3, #0
 8007c78:	ee00 3a10 	vmov	s0, r3
 8007c7c:	4770      	bx	lr
 8007c7e:	bf00      	nop
 8007c80:	7149f2ca 	.word	0x7149f2ca
 8007c84:	bf800000 	.word	0xbf800000
 8007c88:	007fffff 	.word	0x007fffff

08007c8c <scalbnf>:
 8007c8c:	b508      	push	{r3, lr}
 8007c8e:	ee10 2a10 	vmov	r2, s0
 8007c92:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 8007c96:	ed2d 8b02 	vpush	{d8}
 8007c9a:	eef0 0a40 	vmov.f32	s1, s0
 8007c9e:	d045      	beq.n	8007d2c <scalbnf+0xa0>
 8007ca0:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8007ca4:	d302      	bcc.n	8007cac <scalbnf+0x20>
 8007ca6:	ee30 0a00 	vadd.f32	s0, s0, s0
 8007caa:	e03f      	b.n	8007d2c <scalbnf+0xa0>
 8007cac:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8007cb0:	d211      	bcs.n	8007cd6 <scalbnf+0x4a>
 8007cb2:	4b20      	ldr	r3, [pc, #128]	; (8007d34 <scalbnf+0xa8>)
 8007cb4:	eddf 7a20 	vldr	s15, [pc, #128]	; 8007d38 <scalbnf+0xac>
 8007cb8:	4298      	cmp	r0, r3
 8007cba:	ee60 0a27 	vmul.f32	s1, s0, s15
 8007cbe:	db05      	blt.n	8007ccc <scalbnf+0x40>
 8007cc0:	ee10 2a90 	vmov	r2, s1
 8007cc4:	f3c2 53c7 	ubfx	r3, r2, #23, #8
 8007cc8:	3b19      	subs	r3, #25
 8007cca:	e005      	b.n	8007cd8 <scalbnf+0x4c>
 8007ccc:	ed9f 0a1b 	vldr	s0, [pc, #108]	; 8007d3c <scalbnf+0xb0>
 8007cd0:	ee20 0a80 	vmul.f32	s0, s1, s0
 8007cd4:	e02a      	b.n	8007d2c <scalbnf+0xa0>
 8007cd6:	0ddb      	lsrs	r3, r3, #23
 8007cd8:	4403      	add	r3, r0
 8007cda:	2bfe      	cmp	r3, #254	; 0xfe
 8007cdc:	dc0f      	bgt.n	8007cfe <scalbnf+0x72>
 8007cde:	2b00      	cmp	r3, #0
 8007ce0:	dd06      	ble.n	8007cf0 <scalbnf+0x64>
 8007ce2:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8007ce6:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 8007cea:	ee00 3a10 	vmov	s0, r3
 8007cee:	e01d      	b.n	8007d2c <scalbnf+0xa0>
 8007cf0:	f113 0f16 	cmn.w	r3, #22
 8007cf4:	da0f      	bge.n	8007d16 <scalbnf+0x8a>
 8007cf6:	f24c 3350 	movw	r3, #50000	; 0xc350
 8007cfa:	4298      	cmp	r0, r3
 8007cfc:	dd02      	ble.n	8007d04 <scalbnf+0x78>
 8007cfe:	ed9f 8a10 	vldr	s16, [pc, #64]	; 8007d40 <scalbnf+0xb4>
 8007d02:	e001      	b.n	8007d08 <scalbnf+0x7c>
 8007d04:	ed9f 8a0d 	vldr	s16, [pc, #52]	; 8007d3c <scalbnf+0xb0>
 8007d08:	eeb0 0a48 	vmov.f32	s0, s16
 8007d0c:	f000 f81c 	bl	8007d48 <copysignf>
 8007d10:	ee20 0a08 	vmul.f32	s0, s0, s16
 8007d14:	e00a      	b.n	8007d2c <scalbnf+0xa0>
 8007d16:	3319      	adds	r3, #25
 8007d18:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8007d1c:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 8007d20:	ee00 3a90 	vmov	s1, r3
 8007d24:	eddf 7a07 	vldr	s15, [pc, #28]	; 8007d44 <scalbnf+0xb8>
 8007d28:	ee20 0aa7 	vmul.f32	s0, s1, s15
 8007d2c:	ecbd 8b02 	vpop	{d8}
 8007d30:	bd08      	pop	{r3, pc}
 8007d32:	bf00      	nop
 8007d34:	ffff3cb0 	.word	0xffff3cb0
 8007d38:	4c000000 	.word	0x4c000000
 8007d3c:	0da24260 	.word	0x0da24260
 8007d40:	7149f2ca 	.word	0x7149f2ca
 8007d44:	33000000 	.word	0x33000000

08007d48 <copysignf>:
 8007d48:	ee10 3a10 	vmov	r3, s0
 8007d4c:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8007d50:	ee10 3a90 	vmov	r3, s1
 8007d54:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8007d58:	4313      	orrs	r3, r2
 8007d5a:	ee00 3a10 	vmov	s0, r3
 8007d5e:	4770      	bx	lr

08007d60 <abort>:
 8007d60:	b508      	push	{r3, lr}
 8007d62:	2006      	movs	r0, #6
 8007d64:	f000 fc58 	bl	8008618 <raise>
 8007d68:	2001      	movs	r0, #1
 8007d6a:	f000 fe21 	bl	80089b0 <_exit>

08007d6e <__cxa_atexit>:
 8007d6e:	4613      	mov	r3, r2
 8007d70:	460a      	mov	r2, r1
 8007d72:	4601      	mov	r1, r0
 8007d74:	2002      	movs	r0, #2
 8007d76:	f000 bc6b 	b.w	8008650 <__register_exitproc>
	...

08007d7c <__libc_init_array>:
 8007d7c:	b570      	push	{r4, r5, r6, lr}
 8007d7e:	4b0e      	ldr	r3, [pc, #56]	; (8007db8 <__libc_init_array+0x3c>)
 8007d80:	4c0e      	ldr	r4, [pc, #56]	; (8007dbc <__libc_init_array+0x40>)
 8007d82:	1ae4      	subs	r4, r4, r3
 8007d84:	10a4      	asrs	r4, r4, #2
 8007d86:	2500      	movs	r5, #0
 8007d88:	461e      	mov	r6, r3
 8007d8a:	42a5      	cmp	r5, r4
 8007d8c:	d004      	beq.n	8007d98 <__libc_init_array+0x1c>
 8007d8e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8007d92:	4798      	blx	r3
 8007d94:	3501      	adds	r5, #1
 8007d96:	e7f8      	b.n	8007d8a <__libc_init_array+0xe>
 8007d98:	f000 fe0c 	bl	80089b4 <_init>
 8007d9c:	4c08      	ldr	r4, [pc, #32]	; (8007dc0 <__libc_init_array+0x44>)
 8007d9e:	4b09      	ldr	r3, [pc, #36]	; (8007dc4 <__libc_init_array+0x48>)
 8007da0:	1ae4      	subs	r4, r4, r3
 8007da2:	10a4      	asrs	r4, r4, #2
 8007da4:	2500      	movs	r5, #0
 8007da6:	461e      	mov	r6, r3
 8007da8:	42a5      	cmp	r5, r4
 8007daa:	d004      	beq.n	8007db6 <__libc_init_array+0x3a>
 8007dac:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8007db0:	4798      	blx	r3
 8007db2:	3501      	adds	r5, #1
 8007db4:	e7f8      	b.n	8007da8 <__libc_init_array+0x2c>
 8007db6:	bd70      	pop	{r4, r5, r6, pc}
 8007db8:	08009b90 	.word	0x08009b90
 8007dbc:	08009b90 	.word	0x08009b90
 8007dc0:	08009b98 	.word	0x08009b98
 8007dc4:	08009b90 	.word	0x08009b90

08007dc8 <malloc>:
 8007dc8:	4b02      	ldr	r3, [pc, #8]	; (8007dd4 <malloc+0xc>)
 8007dca:	4601      	mov	r1, r0
 8007dcc:	6818      	ldr	r0, [r3, #0]
 8007dce:	f000 b80b 	b.w	8007de8 <_malloc_r>
 8007dd2:	bf00      	nop
 8007dd4:	20000100 	.word	0x20000100

08007dd8 <free>:
 8007dd8:	4b02      	ldr	r3, [pc, #8]	; (8007de4 <free+0xc>)
 8007dda:	4601      	mov	r1, r0
 8007ddc:	6818      	ldr	r0, [r3, #0]
 8007dde:	f000 bcef 	b.w	80087c0 <_free_r>
 8007de2:	bf00      	nop
 8007de4:	20000100 	.word	0x20000100

08007de8 <_malloc_r>:
 8007de8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007dec:	f101 040b 	add.w	r4, r1, #11
 8007df0:	2c16      	cmp	r4, #22
 8007df2:	b085      	sub	sp, #20
 8007df4:	4681      	mov	r9, r0
 8007df6:	d903      	bls.n	8007e00 <_malloc_r+0x18>
 8007df8:	f034 0407 	bics.w	r4, r4, #7
 8007dfc:	d501      	bpl.n	8007e02 <_malloc_r+0x1a>
 8007dfe:	e002      	b.n	8007e06 <_malloc_r+0x1e>
 8007e00:	2410      	movs	r4, #16
 8007e02:	428c      	cmp	r4, r1
 8007e04:	d203      	bcs.n	8007e0e <_malloc_r+0x26>
 8007e06:	230c      	movs	r3, #12
 8007e08:	f8c9 3000 	str.w	r3, [r9]
 8007e0c:	e1ea      	b.n	80081e4 <_malloc_r+0x3fc>
 8007e0e:	4648      	mov	r0, r9
 8007e10:	f000 fa15 	bl	800823e <__malloc_lock>
 8007e14:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 8007e18:	4d9e      	ldr	r5, [pc, #632]	; (8008094 <_malloc_r+0x2ac>)
 8007e1a:	d217      	bcs.n	8007e4c <_malloc_r+0x64>
 8007e1c:	f104 0208 	add.w	r2, r4, #8
 8007e20:	442a      	add	r2, r5
 8007e22:	f1a2 0108 	sub.w	r1, r2, #8
 8007e26:	6856      	ldr	r6, [r2, #4]
 8007e28:	428e      	cmp	r6, r1
 8007e2a:	ea4f 03d4 	mov.w	r3, r4, lsr #3
 8007e2e:	d102      	bne.n	8007e36 <_malloc_r+0x4e>
 8007e30:	68d6      	ldr	r6, [r2, #12]
 8007e32:	42b2      	cmp	r2, r6
 8007e34:	d008      	beq.n	8007e48 <_malloc_r+0x60>
 8007e36:	6873      	ldr	r3, [r6, #4]
 8007e38:	68f2      	ldr	r2, [r6, #12]
 8007e3a:	68b1      	ldr	r1, [r6, #8]
 8007e3c:	f023 0303 	bic.w	r3, r3, #3
 8007e40:	60ca      	str	r2, [r1, #12]
 8007e42:	4433      	add	r3, r6
 8007e44:	6091      	str	r1, [r2, #8]
 8007e46:	e02f      	b.n	8007ea8 <_malloc_r+0xc0>
 8007e48:	3302      	adds	r3, #2
 8007e4a:	e03d      	b.n	8007ec8 <_malloc_r+0xe0>
 8007e4c:	0a63      	lsrs	r3, r4, #9
 8007e4e:	d01a      	beq.n	8007e86 <_malloc_r+0x9e>
 8007e50:	2b04      	cmp	r3, #4
 8007e52:	d802      	bhi.n	8007e5a <_malloc_r+0x72>
 8007e54:	09a3      	lsrs	r3, r4, #6
 8007e56:	3338      	adds	r3, #56	; 0x38
 8007e58:	e018      	b.n	8007e8c <_malloc_r+0xa4>
 8007e5a:	2b14      	cmp	r3, #20
 8007e5c:	d801      	bhi.n	8007e62 <_malloc_r+0x7a>
 8007e5e:	335b      	adds	r3, #91	; 0x5b
 8007e60:	e014      	b.n	8007e8c <_malloc_r+0xa4>
 8007e62:	2b54      	cmp	r3, #84	; 0x54
 8007e64:	d802      	bhi.n	8007e6c <_malloc_r+0x84>
 8007e66:	0b23      	lsrs	r3, r4, #12
 8007e68:	336e      	adds	r3, #110	; 0x6e
 8007e6a:	e00f      	b.n	8007e8c <_malloc_r+0xa4>
 8007e6c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8007e70:	d802      	bhi.n	8007e78 <_malloc_r+0x90>
 8007e72:	0be3      	lsrs	r3, r4, #15
 8007e74:	3377      	adds	r3, #119	; 0x77
 8007e76:	e009      	b.n	8007e8c <_malloc_r+0xa4>
 8007e78:	f240 5254 	movw	r2, #1364	; 0x554
 8007e7c:	4293      	cmp	r3, r2
 8007e7e:	d804      	bhi.n	8007e8a <_malloc_r+0xa2>
 8007e80:	0ca3      	lsrs	r3, r4, #18
 8007e82:	337c      	adds	r3, #124	; 0x7c
 8007e84:	e002      	b.n	8007e8c <_malloc_r+0xa4>
 8007e86:	233f      	movs	r3, #63	; 0x3f
 8007e88:	e000      	b.n	8007e8c <_malloc_r+0xa4>
 8007e8a:	237e      	movs	r3, #126	; 0x7e
 8007e8c:	1c5a      	adds	r2, r3, #1
 8007e8e:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 8007e92:	f1a2 0008 	sub.w	r0, r2, #8
 8007e96:	6856      	ldr	r6, [r2, #4]
 8007e98:	e00c      	b.n	8007eb4 <_malloc_r+0xcc>
 8007e9a:	2900      	cmp	r1, #0
 8007e9c:	68f1      	ldr	r1, [r6, #12]
 8007e9e:	db08      	blt.n	8007eb2 <_malloc_r+0xca>
 8007ea0:	68b3      	ldr	r3, [r6, #8]
 8007ea2:	60d9      	str	r1, [r3, #12]
 8007ea4:	608b      	str	r3, [r1, #8]
 8007ea6:	18b3      	adds	r3, r6, r2
 8007ea8:	685a      	ldr	r2, [r3, #4]
 8007eaa:	f042 0201 	orr.w	r2, r2, #1
 8007eae:	605a      	str	r2, [r3, #4]
 8007eb0:	e1a3      	b.n	80081fa <_malloc_r+0x412>
 8007eb2:	460e      	mov	r6, r1
 8007eb4:	4286      	cmp	r6, r0
 8007eb6:	d006      	beq.n	8007ec6 <_malloc_r+0xde>
 8007eb8:	6872      	ldr	r2, [r6, #4]
 8007eba:	f022 0203 	bic.w	r2, r2, #3
 8007ebe:	1b11      	subs	r1, r2, r4
 8007ec0:	290f      	cmp	r1, #15
 8007ec2:	ddea      	ble.n	8007e9a <_malloc_r+0xb2>
 8007ec4:	3b01      	subs	r3, #1
 8007ec6:	3301      	adds	r3, #1
 8007ec8:	4a72      	ldr	r2, [pc, #456]	; (8008094 <_malloc_r+0x2ac>)
 8007eca:	692e      	ldr	r6, [r5, #16]
 8007ecc:	f102 0708 	add.w	r7, r2, #8
 8007ed0:	42be      	cmp	r6, r7
 8007ed2:	4639      	mov	r1, r7
 8007ed4:	d079      	beq.n	8007fca <_malloc_r+0x1e2>
 8007ed6:	6870      	ldr	r0, [r6, #4]
 8007ed8:	f020 0003 	bic.w	r0, r0, #3
 8007edc:	ebc4 0e00 	rsb	lr, r4, r0
 8007ee0:	f1be 0f0f 	cmp.w	lr, #15
 8007ee4:	dd0d      	ble.n	8007f02 <_malloc_r+0x11a>
 8007ee6:	1933      	adds	r3, r6, r4
 8007ee8:	f044 0401 	orr.w	r4, r4, #1
 8007eec:	6074      	str	r4, [r6, #4]
 8007eee:	6153      	str	r3, [r2, #20]
 8007ef0:	6113      	str	r3, [r2, #16]
 8007ef2:	f04e 0201 	orr.w	r2, lr, #1
 8007ef6:	60df      	str	r7, [r3, #12]
 8007ef8:	609f      	str	r7, [r3, #8]
 8007efa:	605a      	str	r2, [r3, #4]
 8007efc:	f843 e00e 	str.w	lr, [r3, lr]
 8007f00:	e17b      	b.n	80081fa <_malloc_r+0x412>
 8007f02:	f1be 0f00 	cmp.w	lr, #0
 8007f06:	6157      	str	r7, [r2, #20]
 8007f08:	6117      	str	r7, [r2, #16]
 8007f0a:	db05      	blt.n	8007f18 <_malloc_r+0x130>
 8007f0c:	4430      	add	r0, r6
 8007f0e:	6843      	ldr	r3, [r0, #4]
 8007f10:	f043 0301 	orr.w	r3, r3, #1
 8007f14:	6043      	str	r3, [r0, #4]
 8007f16:	e170      	b.n	80081fa <_malloc_r+0x412>
 8007f18:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8007f1c:	d215      	bcs.n	8007f4a <_malloc_r+0x162>
 8007f1e:	08c0      	lsrs	r0, r0, #3
 8007f20:	ea4f 0ea0 	mov.w	lr, r0, asr #2
 8007f24:	2701      	movs	r7, #1
 8007f26:	fa07 fe0e 	lsl.w	lr, r7, lr
 8007f2a:	6857      	ldr	r7, [r2, #4]
 8007f2c:	3001      	adds	r0, #1
 8007f2e:	ea4e 0707 	orr.w	r7, lr, r7
 8007f32:	6057      	str	r7, [r2, #4]
 8007f34:	eb02 07c0 	add.w	r7, r2, r0, lsl #3
 8007f38:	f852 e030 	ldr.w	lr, [r2, r0, lsl #3]
 8007f3c:	f8c6 e008 	str.w	lr, [r6, #8]
 8007f40:	3f08      	subs	r7, #8
 8007f42:	60f7      	str	r7, [r6, #12]
 8007f44:	f842 6030 	str.w	r6, [r2, r0, lsl #3]
 8007f48:	e03d      	b.n	8007fc6 <_malloc_r+0x1de>
 8007f4a:	0a42      	lsrs	r2, r0, #9
 8007f4c:	2a04      	cmp	r2, #4
 8007f4e:	d802      	bhi.n	8007f56 <_malloc_r+0x16e>
 8007f50:	0982      	lsrs	r2, r0, #6
 8007f52:	3238      	adds	r2, #56	; 0x38
 8007f54:	e015      	b.n	8007f82 <_malloc_r+0x19a>
 8007f56:	2a14      	cmp	r2, #20
 8007f58:	d801      	bhi.n	8007f5e <_malloc_r+0x176>
 8007f5a:	325b      	adds	r2, #91	; 0x5b
 8007f5c:	e011      	b.n	8007f82 <_malloc_r+0x19a>
 8007f5e:	2a54      	cmp	r2, #84	; 0x54
 8007f60:	d802      	bhi.n	8007f68 <_malloc_r+0x180>
 8007f62:	0b02      	lsrs	r2, r0, #12
 8007f64:	326e      	adds	r2, #110	; 0x6e
 8007f66:	e00c      	b.n	8007f82 <_malloc_r+0x19a>
 8007f68:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8007f6c:	d802      	bhi.n	8007f74 <_malloc_r+0x18c>
 8007f6e:	0bc2      	lsrs	r2, r0, #15
 8007f70:	3277      	adds	r2, #119	; 0x77
 8007f72:	e006      	b.n	8007f82 <_malloc_r+0x19a>
 8007f74:	f240 5754 	movw	r7, #1364	; 0x554
 8007f78:	42ba      	cmp	r2, r7
 8007f7a:	bf9a      	itte	ls
 8007f7c:	0c82      	lsrls	r2, r0, #18
 8007f7e:	327c      	addls	r2, #124	; 0x7c
 8007f80:	227e      	movhi	r2, #126	; 0x7e
 8007f82:	1c57      	adds	r7, r2, #1
 8007f84:	eb05 0ec2 	add.w	lr, r5, r2, lsl #3
 8007f88:	f855 7037 	ldr.w	r7, [r5, r7, lsl #3]
 8007f8c:	f8df c104 	ldr.w	ip, [pc, #260]	; 8008094 <_malloc_r+0x2ac>
 8007f90:	45be      	cmp	lr, r7
 8007f92:	d10d      	bne.n	8007fb0 <_malloc_r+0x1c8>
 8007f94:	2001      	movs	r0, #1
 8007f96:	1092      	asrs	r2, r2, #2
 8007f98:	fa00 f202 	lsl.w	r2, r0, r2
 8007f9c:	f8dc 0004 	ldr.w	r0, [ip, #4]
 8007fa0:	4310      	orrs	r0, r2
 8007fa2:	f8cc 0004 	str.w	r0, [ip, #4]
 8007fa6:	4672      	mov	r2, lr
 8007fa8:	e009      	b.n	8007fbe <_malloc_r+0x1d6>
 8007faa:	68bf      	ldr	r7, [r7, #8]
 8007fac:	45be      	cmp	lr, r7
 8007fae:	d004      	beq.n	8007fba <_malloc_r+0x1d2>
 8007fb0:	687a      	ldr	r2, [r7, #4]
 8007fb2:	f022 0203 	bic.w	r2, r2, #3
 8007fb6:	4290      	cmp	r0, r2
 8007fb8:	d3f7      	bcc.n	8007faa <_malloc_r+0x1c2>
 8007fba:	68fa      	ldr	r2, [r7, #12]
 8007fbc:	46be      	mov	lr, r7
 8007fbe:	60f2      	str	r2, [r6, #12]
 8007fc0:	f8c6 e008 	str.w	lr, [r6, #8]
 8007fc4:	6096      	str	r6, [r2, #8]
 8007fc6:	f8ce 600c 	str.w	r6, [lr, #12]
 8007fca:	2001      	movs	r0, #1
 8007fcc:	109a      	asrs	r2, r3, #2
 8007fce:	fa00 f202 	lsl.w	r2, r0, r2
 8007fd2:	6868      	ldr	r0, [r5, #4]
 8007fd4:	4282      	cmp	r2, r0
 8007fd6:	d85f      	bhi.n	8008098 <_malloc_r+0x2b0>
 8007fd8:	4202      	tst	r2, r0
 8007fda:	d106      	bne.n	8007fea <_malloc_r+0x202>
 8007fdc:	f023 0303 	bic.w	r3, r3, #3
 8007fe0:	0052      	lsls	r2, r2, #1
 8007fe2:	4202      	tst	r2, r0
 8007fe4:	f103 0304 	add.w	r3, r3, #4
 8007fe8:	d0fa      	beq.n	8007fe0 <_malloc_r+0x1f8>
 8007fea:	eb05 08c3 	add.w	r8, r5, r3, lsl #3
 8007fee:	46c2      	mov	sl, r8
 8007ff0:	469c      	mov	ip, r3
 8007ff2:	f8da 600c 	ldr.w	r6, [sl, #12]
 8007ff6:	4556      	cmp	r6, sl
 8007ff8:	d02c      	beq.n	8008054 <_malloc_r+0x26c>
 8007ffa:	6870      	ldr	r0, [r6, #4]
 8007ffc:	68f7      	ldr	r7, [r6, #12]
 8007ffe:	f020 0003 	bic.w	r0, r0, #3
 8008002:	ebc4 0e00 	rsb	lr, r4, r0
 8008006:	f1be 0f0f 	cmp.w	lr, #15
 800800a:	dd11      	ble.n	8008030 <_malloc_r+0x248>
 800800c:	1933      	adds	r3, r6, r4
 800800e:	f044 0401 	orr.w	r4, r4, #1
 8008012:	6074      	str	r4, [r6, #4]
 8008014:	f856 2f08 	ldr.w	r2, [r6, #8]!
 8008018:	60d7      	str	r7, [r2, #12]
 800801a:	60ba      	str	r2, [r7, #8]
 800801c:	f04e 0201 	orr.w	r2, lr, #1
 8008020:	616b      	str	r3, [r5, #20]
 8008022:	612b      	str	r3, [r5, #16]
 8008024:	60d9      	str	r1, [r3, #12]
 8008026:	6099      	str	r1, [r3, #8]
 8008028:	605a      	str	r2, [r3, #4]
 800802a:	f843 e00e 	str.w	lr, [r3, lr]
 800802e:	e00b      	b.n	8008048 <_malloc_r+0x260>
 8008030:	f1be 0f00 	cmp.w	lr, #0
 8008034:	db0c      	blt.n	8008050 <_malloc_r+0x268>
 8008036:	1833      	adds	r3, r6, r0
 8008038:	685a      	ldr	r2, [r3, #4]
 800803a:	f042 0201 	orr.w	r2, r2, #1
 800803e:	605a      	str	r2, [r3, #4]
 8008040:	f856 3f08 	ldr.w	r3, [r6, #8]!
 8008044:	60df      	str	r7, [r3, #12]
 8008046:	60bb      	str	r3, [r7, #8]
 8008048:	4648      	mov	r0, r9
 800804a:	f000 f8f9 	bl	8008240 <__malloc_unlock>
 800804e:	e0d8      	b.n	8008202 <_malloc_r+0x41a>
 8008050:	463e      	mov	r6, r7
 8008052:	e7d0      	b.n	8007ff6 <_malloc_r+0x20e>
 8008054:	f10c 0c01 	add.w	ip, ip, #1
 8008058:	f01c 0f03 	tst.w	ip, #3
 800805c:	f10a 0a08 	add.w	sl, sl, #8
 8008060:	d1c7      	bne.n	8007ff2 <_malloc_r+0x20a>
 8008062:	0798      	lsls	r0, r3, #30
 8008064:	d104      	bne.n	8008070 <_malloc_r+0x288>
 8008066:	686b      	ldr	r3, [r5, #4]
 8008068:	ea23 0302 	bic.w	r3, r3, r2
 800806c:	606b      	str	r3, [r5, #4]
 800806e:	e005      	b.n	800807c <_malloc_r+0x294>
 8008070:	f858 0908 	ldr.w	r0, [r8], #-8
 8008074:	4580      	cmp	r8, r0
 8008076:	f103 33ff 	add.w	r3, r3, #4294967295
 800807a:	d0f2      	beq.n	8008062 <_malloc_r+0x27a>
 800807c:	6868      	ldr	r0, [r5, #4]
 800807e:	0052      	lsls	r2, r2, #1
 8008080:	4282      	cmp	r2, r0
 8008082:	d809      	bhi.n	8008098 <_malloc_r+0x2b0>
 8008084:	b142      	cbz	r2, 8008098 <_malloc_r+0x2b0>
 8008086:	4663      	mov	r3, ip
 8008088:	4202      	tst	r2, r0
 800808a:	d1ae      	bne.n	8007fea <_malloc_r+0x202>
 800808c:	3304      	adds	r3, #4
 800808e:	0052      	lsls	r2, r2, #1
 8008090:	e7fa      	b.n	8008088 <_malloc_r+0x2a0>
 8008092:	bf00      	nop
 8008094:	20000104 	.word	0x20000104
 8008098:	f8d5 b008 	ldr.w	fp, [r5, #8]
 800809c:	f8db 6004 	ldr.w	r6, [fp, #4]
 80080a0:	f026 0603 	bic.w	r6, r6, #3
 80080a4:	42b4      	cmp	r4, r6
 80080a6:	d803      	bhi.n	80080b0 <_malloc_r+0x2c8>
 80080a8:	1b33      	subs	r3, r6, r4
 80080aa:	2b0f      	cmp	r3, #15
 80080ac:	f300 809c 	bgt.w	80081e8 <_malloc_r+0x400>
 80080b0:	4a56      	ldr	r2, [pc, #344]	; (800820c <_malloc_r+0x424>)
 80080b2:	4957      	ldr	r1, [pc, #348]	; (8008210 <_malloc_r+0x428>)
 80080b4:	6812      	ldr	r2, [r2, #0]
 80080b6:	6808      	ldr	r0, [r1, #0]
 80080b8:	9101      	str	r1, [sp, #4]
 80080ba:	f102 0810 	add.w	r8, r2, #16
 80080be:	4a55      	ldr	r2, [pc, #340]	; (8008214 <_malloc_r+0x42c>)
 80080c0:	9203      	str	r2, [sp, #12]
 80080c2:	3001      	adds	r0, #1
 80080c4:	bf18      	it	ne
 80080c6:	f102 31ff 	addne.w	r1, r2, #4294967295
 80080ca:	44a0      	add	r8, r4
 80080cc:	bf1e      	ittt	ne
 80080ce:	4488      	addne	r8, r1
 80080d0:	4251      	negne	r1, r2
 80080d2:	ea01 0808 	andne.w	r8, r1, r8
 80080d6:	eb0b 0306 	add.w	r3, fp, r6
 80080da:	4641      	mov	r1, r8
 80080dc:	4648      	mov	r0, r9
 80080de:	9302      	str	r3, [sp, #8]
 80080e0:	f000 fa60 	bl	80085a4 <_sbrk_r>
 80080e4:	1c42      	adds	r2, r0, #1
 80080e6:	4607      	mov	r7, r0
 80080e8:	d06f      	beq.n	80081ca <_malloc_r+0x3e2>
 80080ea:	9b02      	ldr	r3, [sp, #8]
 80080ec:	9a03      	ldr	r2, [sp, #12]
 80080ee:	4283      	cmp	r3, r0
 80080f0:	d901      	bls.n	80080f6 <_malloc_r+0x30e>
 80080f2:	45ab      	cmp	fp, r5
 80080f4:	d169      	bne.n	80081ca <_malloc_r+0x3e2>
 80080f6:	f8df a128 	ldr.w	sl, [pc, #296]	; 8008220 <_malloc_r+0x438>
 80080fa:	f8df c128 	ldr.w	ip, [pc, #296]	; 8008224 <_malloc_r+0x43c>
 80080fe:	f8da 0000 	ldr.w	r0, [sl]
 8008102:	42bb      	cmp	r3, r7
 8008104:	4440      	add	r0, r8
 8008106:	f8ca 0000 	str.w	r0, [sl]
 800810a:	d108      	bne.n	800811e <_malloc_r+0x336>
 800810c:	ea13 0f0c 	tst.w	r3, ip
 8008110:	d105      	bne.n	800811e <_malloc_r+0x336>
 8008112:	68ab      	ldr	r3, [r5, #8]
 8008114:	4446      	add	r6, r8
 8008116:	f046 0601 	orr.w	r6, r6, #1
 800811a:	605e      	str	r6, [r3, #4]
 800811c:	e049      	b.n	80081b2 <_malloc_r+0x3ca>
 800811e:	9901      	ldr	r1, [sp, #4]
 8008120:	f8d1 e000 	ldr.w	lr, [r1]
 8008124:	f1be 3fff 	cmp.w	lr, #4294967295
 8008128:	bf15      	itete	ne
 800812a:	1afb      	subne	r3, r7, r3
 800812c:	4b38      	ldreq	r3, [pc, #224]	; (8008210 <_malloc_r+0x428>)
 800812e:	181b      	addne	r3, r3, r0
 8008130:	601f      	streq	r7, [r3, #0]
 8008132:	bf18      	it	ne
 8008134:	f8ca 3000 	strne.w	r3, [sl]
 8008138:	f017 0307 	ands.w	r3, r7, #7
 800813c:	bf1c      	itt	ne
 800813e:	f1c3 0308 	rsbne	r3, r3, #8
 8008142:	18ff      	addne	r7, r7, r3
 8008144:	44b8      	add	r8, r7
 8008146:	441a      	add	r2, r3
 8008148:	ea08 080c 	and.w	r8, r8, ip
 800814c:	ebc8 0802 	rsb	r8, r8, r2
 8008150:	4641      	mov	r1, r8
 8008152:	4648      	mov	r0, r9
 8008154:	f000 fa26 	bl	80085a4 <_sbrk_r>
 8008158:	1c43      	adds	r3, r0, #1
 800815a:	bf04      	itt	eq
 800815c:	4638      	moveq	r0, r7
 800815e:	f04f 0800 	moveq.w	r8, #0
 8008162:	f8da 3000 	ldr.w	r3, [sl]
 8008166:	60af      	str	r7, [r5, #8]
 8008168:	1bc2      	subs	r2, r0, r7
 800816a:	4442      	add	r2, r8
 800816c:	4443      	add	r3, r8
 800816e:	f042 0201 	orr.w	r2, r2, #1
 8008172:	45ab      	cmp	fp, r5
 8008174:	f8ca 3000 	str.w	r3, [sl]
 8008178:	607a      	str	r2, [r7, #4]
 800817a:	d01a      	beq.n	80081b2 <_malloc_r+0x3ca>
 800817c:	2e0f      	cmp	r6, #15
 800817e:	d802      	bhi.n	8008186 <_malloc_r+0x39e>
 8008180:	2301      	movs	r3, #1
 8008182:	607b      	str	r3, [r7, #4]
 8008184:	e021      	b.n	80081ca <_malloc_r+0x3e2>
 8008186:	f8db 3004 	ldr.w	r3, [fp, #4]
 800818a:	3e0c      	subs	r6, #12
 800818c:	f026 0607 	bic.w	r6, r6, #7
 8008190:	f003 0301 	and.w	r3, r3, #1
 8008194:	4333      	orrs	r3, r6
 8008196:	f8cb 3004 	str.w	r3, [fp, #4]
 800819a:	eb0b 0306 	add.w	r3, fp, r6
 800819e:	2205      	movs	r2, #5
 80081a0:	2e0f      	cmp	r6, #15
 80081a2:	605a      	str	r2, [r3, #4]
 80081a4:	609a      	str	r2, [r3, #8]
 80081a6:	d904      	bls.n	80081b2 <_malloc_r+0x3ca>
 80081a8:	f10b 0108 	add.w	r1, fp, #8
 80081ac:	4648      	mov	r0, r9
 80081ae:	f000 fb07 	bl	80087c0 <_free_r>
 80081b2:	4a19      	ldr	r2, [pc, #100]	; (8008218 <_malloc_r+0x430>)
 80081b4:	f8da 3000 	ldr.w	r3, [sl]
 80081b8:	6811      	ldr	r1, [r2, #0]
 80081ba:	428b      	cmp	r3, r1
 80081bc:	bf88      	it	hi
 80081be:	6013      	strhi	r3, [r2, #0]
 80081c0:	4a16      	ldr	r2, [pc, #88]	; (800821c <_malloc_r+0x434>)
 80081c2:	6811      	ldr	r1, [r2, #0]
 80081c4:	428b      	cmp	r3, r1
 80081c6:	bf88      	it	hi
 80081c8:	6013      	strhi	r3, [r2, #0]
 80081ca:	68ab      	ldr	r3, [r5, #8]
 80081cc:	685a      	ldr	r2, [r3, #4]
 80081ce:	f022 0203 	bic.w	r2, r2, #3
 80081d2:	4294      	cmp	r4, r2
 80081d4:	eba2 0304 	sub.w	r3, r2, r4
 80081d8:	d801      	bhi.n	80081de <_malloc_r+0x3f6>
 80081da:	2b0f      	cmp	r3, #15
 80081dc:	dc04      	bgt.n	80081e8 <_malloc_r+0x400>
 80081de:	4648      	mov	r0, r9
 80081e0:	f000 f82e 	bl	8008240 <__malloc_unlock>
 80081e4:	2600      	movs	r6, #0
 80081e6:	e00c      	b.n	8008202 <_malloc_r+0x41a>
 80081e8:	68ae      	ldr	r6, [r5, #8]
 80081ea:	f044 0201 	orr.w	r2, r4, #1
 80081ee:	4434      	add	r4, r6
 80081f0:	f043 0301 	orr.w	r3, r3, #1
 80081f4:	6072      	str	r2, [r6, #4]
 80081f6:	60ac      	str	r4, [r5, #8]
 80081f8:	6063      	str	r3, [r4, #4]
 80081fa:	4648      	mov	r0, r9
 80081fc:	f000 f820 	bl	8008240 <__malloc_unlock>
 8008200:	3608      	adds	r6, #8
 8008202:	4630      	mov	r0, r6
 8008204:	b005      	add	sp, #20
 8008206:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800820a:	bf00      	nop
 800820c:	20003d18 	.word	0x20003d18
 8008210:	20000510 	.word	0x20000510
 8008214:	00001000 	.word	0x00001000
 8008218:	20003d14 	.word	0x20003d14
 800821c:	20003d10 	.word	0x20003d10
 8008220:	20003d1c 	.word	0x20003d1c
 8008224:	00000fff 	.word	0x00000fff

08008228 <memcpy>:
 8008228:	b510      	push	{r4, lr}
 800822a:	1e43      	subs	r3, r0, #1
 800822c:	440a      	add	r2, r1
 800822e:	4291      	cmp	r1, r2
 8008230:	d004      	beq.n	800823c <memcpy+0x14>
 8008232:	f811 4b01 	ldrb.w	r4, [r1], #1
 8008236:	f803 4f01 	strb.w	r4, [r3, #1]!
 800823a:	e7f8      	b.n	800822e <memcpy+0x6>
 800823c:	bd10      	pop	{r4, pc}

0800823e <__malloc_lock>:
 800823e:	4770      	bx	lr

08008240 <__malloc_unlock>:
 8008240:	4770      	bx	lr
	...

08008244 <realloc>:
 8008244:	4b02      	ldr	r3, [pc, #8]	; (8008250 <realloc+0xc>)
 8008246:	460a      	mov	r2, r1
 8008248:	4601      	mov	r1, r0
 800824a:	6818      	ldr	r0, [r3, #0]
 800824c:	f000 b802 	b.w	8008254 <_realloc_r>
 8008250:	20000100 	.word	0x20000100

08008254 <_realloc_r>:
 8008254:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008258:	4681      	mov	r9, r0
 800825a:	460c      	mov	r4, r1
 800825c:	b929      	cbnz	r1, 800826a <_realloc_r+0x16>
 800825e:	4611      	mov	r1, r2
 8008260:	b003      	add	sp, #12
 8008262:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008266:	f7ff bdbf 	b.w	8007de8 <_malloc_r>
 800826a:	9201      	str	r2, [sp, #4]
 800826c:	f7ff ffe7 	bl	800823e <__malloc_lock>
 8008270:	9a01      	ldr	r2, [sp, #4]
 8008272:	f854 ec04 	ldr.w	lr, [r4, #-4]
 8008276:	f102 080b 	add.w	r8, r2, #11
 800827a:	f1b8 0f16 	cmp.w	r8, #22
 800827e:	f1a4 0b08 	sub.w	fp, r4, #8
 8008282:	f02e 0503 	bic.w	r5, lr, #3
 8008286:	d903      	bls.n	8008290 <_realloc_r+0x3c>
 8008288:	f038 0807 	bics.w	r8, r8, #7
 800828c:	d502      	bpl.n	8008294 <_realloc_r+0x40>
 800828e:	e003      	b.n	8008298 <_realloc_r+0x44>
 8008290:	f04f 0810 	mov.w	r8, #16
 8008294:	4590      	cmp	r8, r2
 8008296:	d204      	bcs.n	80082a2 <_realloc_r+0x4e>
 8008298:	230c      	movs	r3, #12
 800829a:	f8c9 3000 	str.w	r3, [r9]
 800829e:	2000      	movs	r0, #0
 80082a0:	e17d      	b.n	800859e <_realloc_r+0x34a>
 80082a2:	45a8      	cmp	r8, r5
 80082a4:	f340 8150 	ble.w	8008548 <_realloc_r+0x2f4>
 80082a8:	4ba6      	ldr	r3, [pc, #664]	; (8008544 <_realloc_r+0x2f0>)
 80082aa:	6898      	ldr	r0, [r3, #8]
 80082ac:	eb0b 0105 	add.w	r1, fp, r5
 80082b0:	4281      	cmp	r1, r0
 80082b2:	684f      	ldr	r7, [r1, #4]
 80082b4:	d005      	beq.n	80082c2 <_realloc_r+0x6e>
 80082b6:	f027 0601 	bic.w	r6, r7, #1
 80082ba:	440e      	add	r6, r1
 80082bc:	6876      	ldr	r6, [r6, #4]
 80082be:	07f6      	lsls	r6, r6, #31
 80082c0:	d426      	bmi.n	8008310 <_realloc_r+0xbc>
 80082c2:	f027 0a03 	bic.w	sl, r7, #3
 80082c6:	4281      	cmp	r1, r0
 80082c8:	eb05 070a 	add.w	r7, r5, sl
 80082cc:	d118      	bne.n	8008300 <_realloc_r+0xac>
 80082ce:	f108 0610 	add.w	r6, r8, #16
 80082d2:	42b7      	cmp	r7, r6
 80082d4:	db1f      	blt.n	8008316 <_realloc_r+0xc2>
 80082d6:	eb0b 0008 	add.w	r0, fp, r8
 80082da:	ebc8 0707 	rsb	r7, r8, r7
 80082de:	f047 0701 	orr.w	r7, r7, #1
 80082e2:	6098      	str	r0, [r3, #8]
 80082e4:	6047      	str	r7, [r0, #4]
 80082e6:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80082ea:	f003 0301 	and.w	r3, r3, #1
 80082ee:	ea43 0308 	orr.w	r3, r3, r8
 80082f2:	4648      	mov	r0, r9
 80082f4:	f844 3c04 	str.w	r3, [r4, #-4]
 80082f8:	f7ff ffa2 	bl	8008240 <__malloc_unlock>
 80082fc:	4620      	mov	r0, r4
 80082fe:	e14e      	b.n	800859e <_realloc_r+0x34a>
 8008300:	45b8      	cmp	r8, r7
 8008302:	dc08      	bgt.n	8008316 <_realloc_r+0xc2>
 8008304:	68cb      	ldr	r3, [r1, #12]
 8008306:	688a      	ldr	r2, [r1, #8]
 8008308:	463d      	mov	r5, r7
 800830a:	60d3      	str	r3, [r2, #12]
 800830c:	609a      	str	r2, [r3, #8]
 800830e:	e11b      	b.n	8008548 <_realloc_r+0x2f4>
 8008310:	f04f 0a00 	mov.w	sl, #0
 8008314:	4651      	mov	r1, sl
 8008316:	f01e 0f01 	tst.w	lr, #1
 800831a:	f040 80c3 	bne.w	80084a4 <_realloc_r+0x250>
 800831e:	f854 7c08 	ldr.w	r7, [r4, #-8]
 8008322:	ebc7 070b 	rsb	r7, r7, fp
 8008326:	687e      	ldr	r6, [r7, #4]
 8008328:	f026 0603 	bic.w	r6, r6, #3
 800832c:	442e      	add	r6, r5
 800832e:	2900      	cmp	r1, #0
 8008330:	f000 8083 	beq.w	800843a <_realloc_r+0x1e6>
 8008334:	4281      	cmp	r1, r0
 8008336:	44b2      	add	sl, r6
 8008338:	d147      	bne.n	80083ca <_realloc_r+0x176>
 800833a:	f108 0110 	add.w	r1, r8, #16
 800833e:	458a      	cmp	sl, r1
 8008340:	db7b      	blt.n	800843a <_realloc_r+0x1e6>
 8008342:	463e      	mov	r6, r7
 8008344:	68fa      	ldr	r2, [r7, #12]
 8008346:	f856 1f08 	ldr.w	r1, [r6, #8]!
 800834a:	60ca      	str	r2, [r1, #12]
 800834c:	6091      	str	r1, [r2, #8]
 800834e:	1f2a      	subs	r2, r5, #4
 8008350:	2a24      	cmp	r2, #36	; 0x24
 8008352:	d825      	bhi.n	80083a0 <_realloc_r+0x14c>
 8008354:	2a13      	cmp	r2, #19
 8008356:	d91b      	bls.n	8008390 <_realloc_r+0x13c>
 8008358:	6821      	ldr	r1, [r4, #0]
 800835a:	60b9      	str	r1, [r7, #8]
 800835c:	6861      	ldr	r1, [r4, #4]
 800835e:	60f9      	str	r1, [r7, #12]
 8008360:	2a1b      	cmp	r2, #27
 8008362:	d803      	bhi.n	800836c <_realloc_r+0x118>
 8008364:	f107 0210 	add.w	r2, r7, #16
 8008368:	3408      	adds	r4, #8
 800836a:	e012      	b.n	8008392 <_realloc_r+0x13e>
 800836c:	68a1      	ldr	r1, [r4, #8]
 800836e:	6139      	str	r1, [r7, #16]
 8008370:	68e1      	ldr	r1, [r4, #12]
 8008372:	6179      	str	r1, [r7, #20]
 8008374:	2a24      	cmp	r2, #36	; 0x24
 8008376:	bf01      	itttt	eq
 8008378:	6922      	ldreq	r2, [r4, #16]
 800837a:	61ba      	streq	r2, [r7, #24]
 800837c:	6961      	ldreq	r1, [r4, #20]
 800837e:	61f9      	streq	r1, [r7, #28]
 8008380:	bf19      	ittee	ne
 8008382:	f107 0218 	addne.w	r2, r7, #24
 8008386:	3410      	addne	r4, #16
 8008388:	f107 0220 	addeq.w	r2, r7, #32
 800838c:	3418      	addeq	r4, #24
 800838e:	e000      	b.n	8008392 <_realloc_r+0x13e>
 8008390:	4632      	mov	r2, r6
 8008392:	6821      	ldr	r1, [r4, #0]
 8008394:	6011      	str	r1, [r2, #0]
 8008396:	6861      	ldr	r1, [r4, #4]
 8008398:	6051      	str	r1, [r2, #4]
 800839a:	68a1      	ldr	r1, [r4, #8]
 800839c:	6091      	str	r1, [r2, #8]
 800839e:	e005      	b.n	80083ac <_realloc_r+0x158>
 80083a0:	4621      	mov	r1, r4
 80083a2:	4630      	mov	r0, r6
 80083a4:	9301      	str	r3, [sp, #4]
 80083a6:	f000 fac9 	bl	800893c <memmove>
 80083aa:	9b01      	ldr	r3, [sp, #4]
 80083ac:	eb07 0208 	add.w	r2, r7, r8
 80083b0:	ebc8 0a0a 	rsb	sl, r8, sl
 80083b4:	609a      	str	r2, [r3, #8]
 80083b6:	f04a 0301 	orr.w	r3, sl, #1
 80083ba:	6053      	str	r3, [r2, #4]
 80083bc:	687b      	ldr	r3, [r7, #4]
 80083be:	f003 0301 	and.w	r3, r3, #1
 80083c2:	ea43 0308 	orr.w	r3, r3, r8
 80083c6:	607b      	str	r3, [r7, #4]
 80083c8:	e0b6      	b.n	8008538 <_realloc_r+0x2e4>
 80083ca:	45d0      	cmp	r8, sl
 80083cc:	dc35      	bgt.n	800843a <_realloc_r+0x1e6>
 80083ce:	68cb      	ldr	r3, [r1, #12]
 80083d0:	688a      	ldr	r2, [r1, #8]
 80083d2:	4638      	mov	r0, r7
 80083d4:	60d3      	str	r3, [r2, #12]
 80083d6:	609a      	str	r2, [r3, #8]
 80083d8:	f850 2f08 	ldr.w	r2, [r0, #8]!
 80083dc:	68fb      	ldr	r3, [r7, #12]
 80083de:	60d3      	str	r3, [r2, #12]
 80083e0:	609a      	str	r2, [r3, #8]
 80083e2:	1f2a      	subs	r2, r5, #4
 80083e4:	2a24      	cmp	r2, #36	; 0x24
 80083e6:	d823      	bhi.n	8008430 <_realloc_r+0x1dc>
 80083e8:	2a13      	cmp	r2, #19
 80083ea:	d91a      	bls.n	8008422 <_realloc_r+0x1ce>
 80083ec:	6823      	ldr	r3, [r4, #0]
 80083ee:	60bb      	str	r3, [r7, #8]
 80083f0:	6863      	ldr	r3, [r4, #4]
 80083f2:	60fb      	str	r3, [r7, #12]
 80083f4:	2a1b      	cmp	r2, #27
 80083f6:	d803      	bhi.n	8008400 <_realloc_r+0x1ac>
 80083f8:	f107 0010 	add.w	r0, r7, #16
 80083fc:	3408      	adds	r4, #8
 80083fe:	e010      	b.n	8008422 <_realloc_r+0x1ce>
 8008400:	68a3      	ldr	r3, [r4, #8]
 8008402:	613b      	str	r3, [r7, #16]
 8008404:	68e3      	ldr	r3, [r4, #12]
 8008406:	617b      	str	r3, [r7, #20]
 8008408:	2a24      	cmp	r2, #36	; 0x24
 800840a:	bf01      	itttt	eq
 800840c:	6923      	ldreq	r3, [r4, #16]
 800840e:	61bb      	streq	r3, [r7, #24]
 8008410:	6963      	ldreq	r3, [r4, #20]
 8008412:	61fb      	streq	r3, [r7, #28]
 8008414:	bf19      	ittee	ne
 8008416:	f107 0018 	addne.w	r0, r7, #24
 800841a:	3410      	addne	r4, #16
 800841c:	f107 0020 	addeq.w	r0, r7, #32
 8008420:	3418      	addeq	r4, #24
 8008422:	6823      	ldr	r3, [r4, #0]
 8008424:	6003      	str	r3, [r0, #0]
 8008426:	6863      	ldr	r3, [r4, #4]
 8008428:	6043      	str	r3, [r0, #4]
 800842a:	68a3      	ldr	r3, [r4, #8]
 800842c:	6083      	str	r3, [r0, #8]
 800842e:	e002      	b.n	8008436 <_realloc_r+0x1e2>
 8008430:	4621      	mov	r1, r4
 8008432:	f000 fa83 	bl	800893c <memmove>
 8008436:	4655      	mov	r5, sl
 8008438:	e02e      	b.n	8008498 <_realloc_r+0x244>
 800843a:	45b0      	cmp	r8, r6
 800843c:	dc32      	bgt.n	80084a4 <_realloc_r+0x250>
 800843e:	4638      	mov	r0, r7
 8008440:	68fb      	ldr	r3, [r7, #12]
 8008442:	f850 2f08 	ldr.w	r2, [r0, #8]!
 8008446:	60d3      	str	r3, [r2, #12]
 8008448:	609a      	str	r2, [r3, #8]
 800844a:	1f2a      	subs	r2, r5, #4
 800844c:	2a24      	cmp	r2, #36	; 0x24
 800844e:	d825      	bhi.n	800849c <_realloc_r+0x248>
 8008450:	2a13      	cmp	r2, #19
 8008452:	d91a      	bls.n	800848a <_realloc_r+0x236>
 8008454:	6823      	ldr	r3, [r4, #0]
 8008456:	60bb      	str	r3, [r7, #8]
 8008458:	6863      	ldr	r3, [r4, #4]
 800845a:	60fb      	str	r3, [r7, #12]
 800845c:	2a1b      	cmp	r2, #27
 800845e:	d803      	bhi.n	8008468 <_realloc_r+0x214>
 8008460:	f107 0010 	add.w	r0, r7, #16
 8008464:	3408      	adds	r4, #8
 8008466:	e010      	b.n	800848a <_realloc_r+0x236>
 8008468:	68a3      	ldr	r3, [r4, #8]
 800846a:	613b      	str	r3, [r7, #16]
 800846c:	68e3      	ldr	r3, [r4, #12]
 800846e:	617b      	str	r3, [r7, #20]
 8008470:	2a24      	cmp	r2, #36	; 0x24
 8008472:	bf01      	itttt	eq
 8008474:	6923      	ldreq	r3, [r4, #16]
 8008476:	61bb      	streq	r3, [r7, #24]
 8008478:	6963      	ldreq	r3, [r4, #20]
 800847a:	61fb      	streq	r3, [r7, #28]
 800847c:	bf19      	ittee	ne
 800847e:	f107 0018 	addne.w	r0, r7, #24
 8008482:	3410      	addne	r4, #16
 8008484:	f107 0020 	addeq.w	r0, r7, #32
 8008488:	3418      	addeq	r4, #24
 800848a:	6823      	ldr	r3, [r4, #0]
 800848c:	6003      	str	r3, [r0, #0]
 800848e:	6863      	ldr	r3, [r4, #4]
 8008490:	6043      	str	r3, [r0, #4]
 8008492:	68a3      	ldr	r3, [r4, #8]
 8008494:	6083      	str	r3, [r0, #8]
 8008496:	4635      	mov	r5, r6
 8008498:	46bb      	mov	fp, r7
 800849a:	e055      	b.n	8008548 <_realloc_r+0x2f4>
 800849c:	4621      	mov	r1, r4
 800849e:	f000 fa4d 	bl	800893c <memmove>
 80084a2:	e7f8      	b.n	8008496 <_realloc_r+0x242>
 80084a4:	4611      	mov	r1, r2
 80084a6:	4648      	mov	r0, r9
 80084a8:	f7ff fc9e 	bl	8007de8 <_malloc_r>
 80084ac:	4606      	mov	r6, r0
 80084ae:	2800      	cmp	r0, #0
 80084b0:	d042      	beq.n	8008538 <_realloc_r+0x2e4>
 80084b2:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80084b6:	f023 0301 	bic.w	r3, r3, #1
 80084ba:	f1a0 0208 	sub.w	r2, r0, #8
 80084be:	445b      	add	r3, fp
 80084c0:	429a      	cmp	r2, r3
 80084c2:	d105      	bne.n	80084d0 <_realloc_r+0x27c>
 80084c4:	f850 3c04 	ldr.w	r3, [r0, #-4]
 80084c8:	f023 0303 	bic.w	r3, r3, #3
 80084cc:	441d      	add	r5, r3
 80084ce:	e03b      	b.n	8008548 <_realloc_r+0x2f4>
 80084d0:	1f2a      	subs	r2, r5, #4
 80084d2:	2a24      	cmp	r2, #36	; 0x24
 80084d4:	d829      	bhi.n	800852a <_realloc_r+0x2d6>
 80084d6:	2a13      	cmp	r2, #19
 80084d8:	d91e      	bls.n	8008518 <_realloc_r+0x2c4>
 80084da:	6823      	ldr	r3, [r4, #0]
 80084dc:	6003      	str	r3, [r0, #0]
 80084de:	6863      	ldr	r3, [r4, #4]
 80084e0:	6043      	str	r3, [r0, #4]
 80084e2:	2a1b      	cmp	r2, #27
 80084e4:	d804      	bhi.n	80084f0 <_realloc_r+0x29c>
 80084e6:	f100 0308 	add.w	r3, r0, #8
 80084ea:	f104 0208 	add.w	r2, r4, #8
 80084ee:	e015      	b.n	800851c <_realloc_r+0x2c8>
 80084f0:	68a3      	ldr	r3, [r4, #8]
 80084f2:	6083      	str	r3, [r0, #8]
 80084f4:	68e3      	ldr	r3, [r4, #12]
 80084f6:	60c3      	str	r3, [r0, #12]
 80084f8:	2a24      	cmp	r2, #36	; 0x24
 80084fa:	bf01      	itttt	eq
 80084fc:	6923      	ldreq	r3, [r4, #16]
 80084fe:	6103      	streq	r3, [r0, #16]
 8008500:	6961      	ldreq	r1, [r4, #20]
 8008502:	6141      	streq	r1, [r0, #20]
 8008504:	bf19      	ittee	ne
 8008506:	f100 0310 	addne.w	r3, r0, #16
 800850a:	f104 0210 	addne.w	r2, r4, #16
 800850e:	f100 0318 	addeq.w	r3, r0, #24
 8008512:	f104 0218 	addeq.w	r2, r4, #24
 8008516:	e001      	b.n	800851c <_realloc_r+0x2c8>
 8008518:	4603      	mov	r3, r0
 800851a:	4622      	mov	r2, r4
 800851c:	6811      	ldr	r1, [r2, #0]
 800851e:	6019      	str	r1, [r3, #0]
 8008520:	6851      	ldr	r1, [r2, #4]
 8008522:	6059      	str	r1, [r3, #4]
 8008524:	6892      	ldr	r2, [r2, #8]
 8008526:	609a      	str	r2, [r3, #8]
 8008528:	e002      	b.n	8008530 <_realloc_r+0x2dc>
 800852a:	4621      	mov	r1, r4
 800852c:	f000 fa06 	bl	800893c <memmove>
 8008530:	4621      	mov	r1, r4
 8008532:	4648      	mov	r0, r9
 8008534:	f000 f944 	bl	80087c0 <_free_r>
 8008538:	4648      	mov	r0, r9
 800853a:	f7ff fe81 	bl	8008240 <__malloc_unlock>
 800853e:	4630      	mov	r0, r6
 8008540:	e02d      	b.n	800859e <_realloc_r+0x34a>
 8008542:	bf00      	nop
 8008544:	20000104 	.word	0x20000104
 8008548:	ebc8 0205 	rsb	r2, r8, r5
 800854c:	2a0f      	cmp	r2, #15
 800854e:	f8db 3004 	ldr.w	r3, [fp, #4]
 8008552:	d914      	bls.n	800857e <_realloc_r+0x32a>
 8008554:	f003 0301 	and.w	r3, r3, #1
 8008558:	eb0b 0108 	add.w	r1, fp, r8
 800855c:	ea43 0308 	orr.w	r3, r3, r8
 8008560:	f8cb 3004 	str.w	r3, [fp, #4]
 8008564:	f042 0301 	orr.w	r3, r2, #1
 8008568:	440a      	add	r2, r1
 800856a:	604b      	str	r3, [r1, #4]
 800856c:	6853      	ldr	r3, [r2, #4]
 800856e:	f043 0301 	orr.w	r3, r3, #1
 8008572:	6053      	str	r3, [r2, #4]
 8008574:	3108      	adds	r1, #8
 8008576:	4648      	mov	r0, r9
 8008578:	f000 f922 	bl	80087c0 <_free_r>
 800857c:	e00a      	b.n	8008594 <_realloc_r+0x340>
 800857e:	f003 0301 	and.w	r3, r3, #1
 8008582:	432b      	orrs	r3, r5
 8008584:	eb0b 0205 	add.w	r2, fp, r5
 8008588:	f8cb 3004 	str.w	r3, [fp, #4]
 800858c:	6853      	ldr	r3, [r2, #4]
 800858e:	f043 0301 	orr.w	r3, r3, #1
 8008592:	6053      	str	r3, [r2, #4]
 8008594:	4648      	mov	r0, r9
 8008596:	f7ff fe53 	bl	8008240 <__malloc_unlock>
 800859a:	f10b 0008 	add.w	r0, fp, #8
 800859e:	b003      	add	sp, #12
 80085a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080085a4 <_sbrk_r>:
 80085a4:	b538      	push	{r3, r4, r5, lr}
 80085a6:	4c06      	ldr	r4, [pc, #24]	; (80085c0 <_sbrk_r+0x1c>)
 80085a8:	2300      	movs	r3, #0
 80085aa:	4605      	mov	r5, r0
 80085ac:	4608      	mov	r0, r1
 80085ae:	6023      	str	r3, [r4, #0]
 80085b0:	f000 f9f0 	bl	8008994 <_sbrk>
 80085b4:	1c43      	adds	r3, r0, #1
 80085b6:	d102      	bne.n	80085be <_sbrk_r+0x1a>
 80085b8:	6823      	ldr	r3, [r4, #0]
 80085ba:	b103      	cbz	r3, 80085be <_sbrk_r+0x1a>
 80085bc:	602b      	str	r3, [r5, #0]
 80085be:	bd38      	pop	{r3, r4, r5, pc}
 80085c0:	20003e50 	.word	0x20003e50

080085c4 <_raise_r>:
 80085c4:	291f      	cmp	r1, #31
 80085c6:	b538      	push	{r3, r4, r5, lr}
 80085c8:	4604      	mov	r4, r0
 80085ca:	460d      	mov	r5, r1
 80085cc:	d904      	bls.n	80085d8 <_raise_r+0x14>
 80085ce:	2316      	movs	r3, #22
 80085d0:	6003      	str	r3, [r0, #0]
 80085d2:	f04f 30ff 	mov.w	r0, #4294967295
 80085d6:	bd38      	pop	{r3, r4, r5, pc}
 80085d8:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80085da:	b112      	cbz	r2, 80085e2 <_raise_r+0x1e>
 80085dc:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80085e0:	b94b      	cbnz	r3, 80085f6 <_raise_r+0x32>
 80085e2:	4620      	mov	r0, r4
 80085e4:	f000 f832 	bl	800864c <_getpid_r>
 80085e8:	462a      	mov	r2, r5
 80085ea:	4601      	mov	r1, r0
 80085ec:	4620      	mov	r0, r4
 80085ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80085f2:	f000 b819 	b.w	8008628 <_kill_r>
 80085f6:	2b01      	cmp	r3, #1
 80085f8:	d00c      	beq.n	8008614 <_raise_r+0x50>
 80085fa:	1c59      	adds	r1, r3, #1
 80085fc:	d103      	bne.n	8008606 <_raise_r+0x42>
 80085fe:	2316      	movs	r3, #22
 8008600:	6003      	str	r3, [r0, #0]
 8008602:	2001      	movs	r0, #1
 8008604:	bd38      	pop	{r3, r4, r5, pc}
 8008606:	2400      	movs	r4, #0
 8008608:	4628      	mov	r0, r5
 800860a:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 800860e:	4798      	blx	r3
 8008610:	4620      	mov	r0, r4
 8008612:	bd38      	pop	{r3, r4, r5, pc}
 8008614:	2000      	movs	r0, #0
 8008616:	bd38      	pop	{r3, r4, r5, pc}

08008618 <raise>:
 8008618:	4b02      	ldr	r3, [pc, #8]	; (8008624 <raise+0xc>)
 800861a:	4601      	mov	r1, r0
 800861c:	6818      	ldr	r0, [r3, #0]
 800861e:	f7ff bfd1 	b.w	80085c4 <_raise_r>
 8008622:	bf00      	nop
 8008624:	20000100 	.word	0x20000100

08008628 <_kill_r>:
 8008628:	b538      	push	{r3, r4, r5, lr}
 800862a:	4c07      	ldr	r4, [pc, #28]	; (8008648 <_kill_r+0x20>)
 800862c:	2300      	movs	r3, #0
 800862e:	4605      	mov	r5, r0
 8008630:	4608      	mov	r0, r1
 8008632:	4611      	mov	r1, r2
 8008634:	6023      	str	r3, [r4, #0]
 8008636:	f000 f9a5 	bl	8008984 <_kill>
 800863a:	1c43      	adds	r3, r0, #1
 800863c:	d102      	bne.n	8008644 <_kill_r+0x1c>
 800863e:	6823      	ldr	r3, [r4, #0]
 8008640:	b103      	cbz	r3, 8008644 <_kill_r+0x1c>
 8008642:	602b      	str	r3, [r5, #0]
 8008644:	bd38      	pop	{r3, r4, r5, pc}
 8008646:	bf00      	nop
 8008648:	20003e50 	.word	0x20003e50

0800864c <_getpid_r>:
 800864c:	f000 b992 	b.w	8008974 <_getpid>

08008650 <__register_exitproc>:
 8008650:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008654:	4698      	mov	r8, r3
 8008656:	4b2c      	ldr	r3, [pc, #176]	; (8008708 <__register_exitproc+0xb8>)
 8008658:	681d      	ldr	r5, [r3, #0]
 800865a:	6cac      	ldr	r4, [r5, #72]	; 0x48
 800865c:	4607      	mov	r7, r0
 800865e:	460e      	mov	r6, r1
 8008660:	4691      	mov	r9, r2
 8008662:	b93c      	cbnz	r4, 8008674 <__register_exitproc+0x24>
 8008664:	4b29      	ldr	r3, [pc, #164]	; (800870c <__register_exitproc+0xbc>)
 8008666:	f105 044c 	add.w	r4, r5, #76	; 0x4c
 800866a:	64ac      	str	r4, [r5, #72]	; 0x48
 800866c:	b113      	cbz	r3, 8008674 <__register_exitproc+0x24>
 800866e:	681b      	ldr	r3, [r3, #0]
 8008670:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
 8008674:	6863      	ldr	r3, [r4, #4]
 8008676:	2b1f      	cmp	r3, #31
 8008678:	dd14      	ble.n	80086a4 <__register_exitproc+0x54>
 800867a:	4b25      	ldr	r3, [pc, #148]	; (8008710 <__register_exitproc+0xc0>)
 800867c:	b91b      	cbnz	r3, 8008686 <__register_exitproc+0x36>
 800867e:	f04f 30ff 	mov.w	r0, #4294967295
 8008682:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008686:	208c      	movs	r0, #140	; 0x8c
 8008688:	f7ff fb9e 	bl	8007dc8 <malloc>
 800868c:	4604      	mov	r4, r0
 800868e:	2800      	cmp	r0, #0
 8008690:	d0f5      	beq.n	800867e <__register_exitproc+0x2e>
 8008692:	6caa      	ldr	r2, [r5, #72]	; 0x48
 8008694:	6002      	str	r2, [r0, #0]
 8008696:	2300      	movs	r3, #0
 8008698:	6043      	str	r3, [r0, #4]
 800869a:	64a8      	str	r0, [r5, #72]	; 0x48
 800869c:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
 80086a0:	b34f      	cbz	r7, 80086f6 <__register_exitproc+0xa6>
 80086a2:	e006      	b.n	80086b2 <__register_exitproc+0x62>
 80086a4:	b33f      	cbz	r7, 80086f6 <__register_exitproc+0xa6>
 80086a6:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 80086aa:	b978      	cbnz	r0, 80086cc <__register_exitproc+0x7c>
 80086ac:	4b18      	ldr	r3, [pc, #96]	; (8008710 <__register_exitproc+0xc0>)
 80086ae:	2b00      	cmp	r3, #0
 80086b0:	d0e5      	beq.n	800867e <__register_exitproc+0x2e>
 80086b2:	f44f 7084 	mov.w	r0, #264	; 0x108
 80086b6:	f7ff fb87 	bl	8007dc8 <malloc>
 80086ba:	2800      	cmp	r0, #0
 80086bc:	d0df      	beq.n	800867e <__register_exitproc+0x2e>
 80086be:	2300      	movs	r3, #0
 80086c0:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
 80086c4:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 80086c8:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 80086cc:	6862      	ldr	r2, [r4, #4]
 80086ce:	f840 9022 	str.w	r9, [r0, r2, lsl #2]
 80086d2:	2301      	movs	r3, #1
 80086d4:	4093      	lsls	r3, r2
 80086d6:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 80086da:	f8d0 2100 	ldr.w	r2, [r0, #256]	; 0x100
 80086de:	431a      	orrs	r2, r3
 80086e0:	2f02      	cmp	r7, #2
 80086e2:	f8c0 2100 	str.w	r2, [r0, #256]	; 0x100
 80086e6:	f8c1 8080 	str.w	r8, [r1, #128]	; 0x80
 80086ea:	bf02      	ittt	eq
 80086ec:	f8d0 2104 	ldreq.w	r2, [r0, #260]	; 0x104
 80086f0:	4313      	orreq	r3, r2
 80086f2:	f8c0 3104 	streq.w	r3, [r0, #260]	; 0x104
 80086f6:	6863      	ldr	r3, [r4, #4]
 80086f8:	1c5a      	adds	r2, r3, #1
 80086fa:	3302      	adds	r3, #2
 80086fc:	6062      	str	r2, [r4, #4]
 80086fe:	2000      	movs	r0, #0
 8008700:	f844 6023 	str.w	r6, [r4, r3, lsl #2]
 8008704:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008708:	08009700 	.word	0x08009700
 800870c:	08009704 	.word	0x08009704
 8008710:	08007dc9 	.word	0x08007dc9

08008714 <_malloc_trim_r>:
 8008714:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008718:	4f25      	ldr	r7, [pc, #148]	; (80087b0 <_malloc_trim_r+0x9c>)
 800871a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 80087bc <_malloc_trim_r+0xa8>
 800871e:	4689      	mov	r9, r1
 8008720:	4606      	mov	r6, r0
 8008722:	f7ff fd8c 	bl	800823e <__malloc_lock>
 8008726:	68bb      	ldr	r3, [r7, #8]
 8008728:	685d      	ldr	r5, [r3, #4]
 800872a:	f1a8 0411 	sub.w	r4, r8, #17
 800872e:	f025 0503 	bic.w	r5, r5, #3
 8008732:	442c      	add	r4, r5
 8008734:	ebc9 0404 	rsb	r4, r9, r4
 8008738:	fbb4 f4f8 	udiv	r4, r4, r8
 800873c:	3c01      	subs	r4, #1
 800873e:	fb08 f404 	mul.w	r4, r8, r4
 8008742:	4544      	cmp	r4, r8
 8008744:	da05      	bge.n	8008752 <_malloc_trim_r+0x3e>
 8008746:	4630      	mov	r0, r6
 8008748:	f7ff fd7a 	bl	8008240 <__malloc_unlock>
 800874c:	2000      	movs	r0, #0
 800874e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008752:	2100      	movs	r1, #0
 8008754:	4630      	mov	r0, r6
 8008756:	f7ff ff25 	bl	80085a4 <_sbrk_r>
 800875a:	68bb      	ldr	r3, [r7, #8]
 800875c:	442b      	add	r3, r5
 800875e:	4298      	cmp	r0, r3
 8008760:	d1f1      	bne.n	8008746 <_malloc_trim_r+0x32>
 8008762:	4261      	negs	r1, r4
 8008764:	4630      	mov	r0, r6
 8008766:	f7ff ff1d 	bl	80085a4 <_sbrk_r>
 800876a:	3001      	adds	r0, #1
 800876c:	d110      	bne.n	8008790 <_malloc_trim_r+0x7c>
 800876e:	2100      	movs	r1, #0
 8008770:	4630      	mov	r0, r6
 8008772:	f7ff ff17 	bl	80085a4 <_sbrk_r>
 8008776:	68ba      	ldr	r2, [r7, #8]
 8008778:	1a83      	subs	r3, r0, r2
 800877a:	2b0f      	cmp	r3, #15
 800877c:	dde3      	ble.n	8008746 <_malloc_trim_r+0x32>
 800877e:	490d      	ldr	r1, [pc, #52]	; (80087b4 <_malloc_trim_r+0xa0>)
 8008780:	6809      	ldr	r1, [r1, #0]
 8008782:	1a40      	subs	r0, r0, r1
 8008784:	490c      	ldr	r1, [pc, #48]	; (80087b8 <_malloc_trim_r+0xa4>)
 8008786:	f043 0301 	orr.w	r3, r3, #1
 800878a:	6008      	str	r0, [r1, #0]
 800878c:	6053      	str	r3, [r2, #4]
 800878e:	e7da      	b.n	8008746 <_malloc_trim_r+0x32>
 8008790:	68bb      	ldr	r3, [r7, #8]
 8008792:	4a09      	ldr	r2, [pc, #36]	; (80087b8 <_malloc_trim_r+0xa4>)
 8008794:	1b2d      	subs	r5, r5, r4
 8008796:	f045 0501 	orr.w	r5, r5, #1
 800879a:	605d      	str	r5, [r3, #4]
 800879c:	6813      	ldr	r3, [r2, #0]
 800879e:	4630      	mov	r0, r6
 80087a0:	1b1c      	subs	r4, r3, r4
 80087a2:	6014      	str	r4, [r2, #0]
 80087a4:	f7ff fd4c 	bl	8008240 <__malloc_unlock>
 80087a8:	2001      	movs	r0, #1
 80087aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80087ae:	bf00      	nop
 80087b0:	20000104 	.word	0x20000104
 80087b4:	20000510 	.word	0x20000510
 80087b8:	20003d1c 	.word	0x20003d1c
 80087bc:	00001000 	.word	0x00001000

080087c0 <_free_r>:
 80087c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80087c4:	4604      	mov	r4, r0
 80087c6:	4688      	mov	r8, r1
 80087c8:	2900      	cmp	r1, #0
 80087ca:	f000 80ad 	beq.w	8008928 <_free_r+0x168>
 80087ce:	f7ff fd36 	bl	800823e <__malloc_lock>
 80087d2:	f858 2c04 	ldr.w	r2, [r8, #-4]
 80087d6:	4d55      	ldr	r5, [pc, #340]	; (800892c <_free_r+0x16c>)
 80087d8:	f022 0001 	bic.w	r0, r2, #1
 80087dc:	f1a8 0308 	sub.w	r3, r8, #8
 80087e0:	181f      	adds	r7, r3, r0
 80087e2:	68a9      	ldr	r1, [r5, #8]
 80087e4:	687e      	ldr	r6, [r7, #4]
 80087e6:	428f      	cmp	r7, r1
 80087e8:	f026 0603 	bic.w	r6, r6, #3
 80087ec:	f002 0201 	and.w	r2, r2, #1
 80087f0:	d11b      	bne.n	800882a <_free_r+0x6a>
 80087f2:	4430      	add	r0, r6
 80087f4:	b93a      	cbnz	r2, 8008806 <_free_r+0x46>
 80087f6:	f858 2c08 	ldr.w	r2, [r8, #-8]
 80087fa:	1a9b      	subs	r3, r3, r2
 80087fc:	4410      	add	r0, r2
 80087fe:	6899      	ldr	r1, [r3, #8]
 8008800:	68da      	ldr	r2, [r3, #12]
 8008802:	60ca      	str	r2, [r1, #12]
 8008804:	6091      	str	r1, [r2, #8]
 8008806:	f040 0201 	orr.w	r2, r0, #1
 800880a:	605a      	str	r2, [r3, #4]
 800880c:	60ab      	str	r3, [r5, #8]
 800880e:	4b48      	ldr	r3, [pc, #288]	; (8008930 <_free_r+0x170>)
 8008810:	681b      	ldr	r3, [r3, #0]
 8008812:	4298      	cmp	r0, r3
 8008814:	d304      	bcc.n	8008820 <_free_r+0x60>
 8008816:	4b47      	ldr	r3, [pc, #284]	; (8008934 <_free_r+0x174>)
 8008818:	4620      	mov	r0, r4
 800881a:	6819      	ldr	r1, [r3, #0]
 800881c:	f7ff ff7a 	bl	8008714 <_malloc_trim_r>
 8008820:	4620      	mov	r0, r4
 8008822:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8008826:	f7ff bd0b 	b.w	8008240 <__malloc_unlock>
 800882a:	607e      	str	r6, [r7, #4]
 800882c:	b97a      	cbnz	r2, 800884e <_free_r+0x8e>
 800882e:	f858 1c08 	ldr.w	r1, [r8, #-8]
 8008832:	1a5b      	subs	r3, r3, r1
 8008834:	4408      	add	r0, r1
 8008836:	6899      	ldr	r1, [r3, #8]
 8008838:	f105 0e08 	add.w	lr, r5, #8
 800883c:	4571      	cmp	r1, lr
 800883e:	d008      	beq.n	8008852 <_free_r+0x92>
 8008840:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 8008844:	f8c1 e00c 	str.w	lr, [r1, #12]
 8008848:	f8ce 1008 	str.w	r1, [lr, #8]
 800884c:	e002      	b.n	8008854 <_free_r+0x94>
 800884e:	2200      	movs	r2, #0
 8008850:	e000      	b.n	8008854 <_free_r+0x94>
 8008852:	2201      	movs	r2, #1
 8008854:	19b9      	adds	r1, r7, r6
 8008856:	6849      	ldr	r1, [r1, #4]
 8008858:	07c9      	lsls	r1, r1, #31
 800885a:	d40e      	bmi.n	800887a <_free_r+0xba>
 800885c:	4430      	add	r0, r6
 800885e:	68b9      	ldr	r1, [r7, #8]
 8008860:	b942      	cbnz	r2, 8008874 <_free_r+0xb4>
 8008862:	4e35      	ldr	r6, [pc, #212]	; (8008938 <_free_r+0x178>)
 8008864:	42b1      	cmp	r1, r6
 8008866:	d105      	bne.n	8008874 <_free_r+0xb4>
 8008868:	616b      	str	r3, [r5, #20]
 800886a:	612b      	str	r3, [r5, #16]
 800886c:	2201      	movs	r2, #1
 800886e:	60d9      	str	r1, [r3, #12]
 8008870:	6099      	str	r1, [r3, #8]
 8008872:	e002      	b.n	800887a <_free_r+0xba>
 8008874:	68fe      	ldr	r6, [r7, #12]
 8008876:	60ce      	str	r6, [r1, #12]
 8008878:	60b1      	str	r1, [r6, #8]
 800887a:	f040 0101 	orr.w	r1, r0, #1
 800887e:	6059      	str	r1, [r3, #4]
 8008880:	5018      	str	r0, [r3, r0]
 8008882:	2a00      	cmp	r2, #0
 8008884:	d1cc      	bne.n	8008820 <_free_r+0x60>
 8008886:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800888a:	d212      	bcs.n	80088b2 <_free_r+0xf2>
 800888c:	08c0      	lsrs	r0, r0, #3
 800888e:	1081      	asrs	r1, r0, #2
 8008890:	2201      	movs	r2, #1
 8008892:	fa02 f101 	lsl.w	r1, r2, r1
 8008896:	686a      	ldr	r2, [r5, #4]
 8008898:	3001      	adds	r0, #1
 800889a:	430a      	orrs	r2, r1
 800889c:	606a      	str	r2, [r5, #4]
 800889e:	eb05 02c0 	add.w	r2, r5, r0, lsl #3
 80088a2:	f855 1030 	ldr.w	r1, [r5, r0, lsl #3]
 80088a6:	6099      	str	r1, [r3, #8]
 80088a8:	3a08      	subs	r2, #8
 80088aa:	60da      	str	r2, [r3, #12]
 80088ac:	f845 3030 	str.w	r3, [r5, r0, lsl #3]
 80088b0:	e038      	b.n	8008924 <_free_r+0x164>
 80088b2:	0a42      	lsrs	r2, r0, #9
 80088b4:	2a04      	cmp	r2, #4
 80088b6:	d802      	bhi.n	80088be <_free_r+0xfe>
 80088b8:	0982      	lsrs	r2, r0, #6
 80088ba:	3238      	adds	r2, #56	; 0x38
 80088bc:	e015      	b.n	80088ea <_free_r+0x12a>
 80088be:	2a14      	cmp	r2, #20
 80088c0:	d801      	bhi.n	80088c6 <_free_r+0x106>
 80088c2:	325b      	adds	r2, #91	; 0x5b
 80088c4:	e011      	b.n	80088ea <_free_r+0x12a>
 80088c6:	2a54      	cmp	r2, #84	; 0x54
 80088c8:	d802      	bhi.n	80088d0 <_free_r+0x110>
 80088ca:	0b02      	lsrs	r2, r0, #12
 80088cc:	326e      	adds	r2, #110	; 0x6e
 80088ce:	e00c      	b.n	80088ea <_free_r+0x12a>
 80088d0:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 80088d4:	d802      	bhi.n	80088dc <_free_r+0x11c>
 80088d6:	0bc2      	lsrs	r2, r0, #15
 80088d8:	3277      	adds	r2, #119	; 0x77
 80088da:	e006      	b.n	80088ea <_free_r+0x12a>
 80088dc:	f240 5154 	movw	r1, #1364	; 0x554
 80088e0:	428a      	cmp	r2, r1
 80088e2:	bf9a      	itte	ls
 80088e4:	0c82      	lsrls	r2, r0, #18
 80088e6:	327c      	addls	r2, #124	; 0x7c
 80088e8:	227e      	movhi	r2, #126	; 0x7e
 80088ea:	1c51      	adds	r1, r2, #1
 80088ec:	eb05 06c2 	add.w	r6, r5, r2, lsl #3
 80088f0:	f855 1031 	ldr.w	r1, [r5, r1, lsl #3]
 80088f4:	4f0d      	ldr	r7, [pc, #52]	; (800892c <_free_r+0x16c>)
 80088f6:	428e      	cmp	r6, r1
 80088f8:	d10b      	bne.n	8008912 <_free_r+0x152>
 80088fa:	2101      	movs	r1, #1
 80088fc:	1092      	asrs	r2, r2, #2
 80088fe:	fa01 f202 	lsl.w	r2, r1, r2
 8008902:	6879      	ldr	r1, [r7, #4]
 8008904:	4311      	orrs	r1, r2
 8008906:	6079      	str	r1, [r7, #4]
 8008908:	4631      	mov	r1, r6
 800890a:	e008      	b.n	800891e <_free_r+0x15e>
 800890c:	6889      	ldr	r1, [r1, #8]
 800890e:	428e      	cmp	r6, r1
 8008910:	d004      	beq.n	800891c <_free_r+0x15c>
 8008912:	684a      	ldr	r2, [r1, #4]
 8008914:	f022 0203 	bic.w	r2, r2, #3
 8008918:	4290      	cmp	r0, r2
 800891a:	d3f7      	bcc.n	800890c <_free_r+0x14c>
 800891c:	68ce      	ldr	r6, [r1, #12]
 800891e:	60de      	str	r6, [r3, #12]
 8008920:	6099      	str	r1, [r3, #8]
 8008922:	60b3      	str	r3, [r6, #8]
 8008924:	60cb      	str	r3, [r1, #12]
 8008926:	e77b      	b.n	8008820 <_free_r+0x60>
 8008928:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800892c:	20000104 	.word	0x20000104
 8008930:	2000050c 	.word	0x2000050c
 8008934:	20003d18 	.word	0x20003d18
 8008938:	2000010c 	.word	0x2000010c

0800893c <memmove>:
 800893c:	4288      	cmp	r0, r1
 800893e:	b510      	push	{r4, lr}
 8008940:	eb01 0302 	add.w	r3, r1, r2
 8008944:	d801      	bhi.n	800894a <memmove+0xe>
 8008946:	1e42      	subs	r2, r0, #1
 8008948:	e00b      	b.n	8008962 <memmove+0x26>
 800894a:	4298      	cmp	r0, r3
 800894c:	d2fb      	bcs.n	8008946 <memmove+0xa>
 800894e:	1881      	adds	r1, r0, r2
 8008950:	1ad2      	subs	r2, r2, r3
 8008952:	42d3      	cmn	r3, r2
 8008954:	d004      	beq.n	8008960 <memmove+0x24>
 8008956:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800895a:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800895e:	e7f8      	b.n	8008952 <memmove+0x16>
 8008960:	bd10      	pop	{r4, pc}
 8008962:	4299      	cmp	r1, r3
 8008964:	d004      	beq.n	8008970 <memmove+0x34>
 8008966:	f811 4b01 	ldrb.w	r4, [r1], #1
 800896a:	f802 4f01 	strb.w	r4, [r2, #1]!
 800896e:	e7f8      	b.n	8008962 <memmove+0x26>
 8008970:	bd10      	pop	{r4, pc}
	...

08008974 <_getpid>:
 8008974:	4b02      	ldr	r3, [pc, #8]	; (8008980 <_getpid+0xc>)
 8008976:	2258      	movs	r2, #88	; 0x58
 8008978:	601a      	str	r2, [r3, #0]
 800897a:	f04f 30ff 	mov.w	r0, #4294967295
 800897e:	4770      	bx	lr
 8008980:	20003e50 	.word	0x20003e50

08008984 <_kill>:
 8008984:	4b02      	ldr	r3, [pc, #8]	; (8008990 <_kill+0xc>)
 8008986:	2258      	movs	r2, #88	; 0x58
 8008988:	601a      	str	r2, [r3, #0]
 800898a:	f04f 30ff 	mov.w	r0, #4294967295
 800898e:	4770      	bx	lr
 8008990:	20003e50 	.word	0x20003e50

08008994 <_sbrk>:
 8008994:	4b04      	ldr	r3, [pc, #16]	; (80089a8 <_sbrk+0x14>)
 8008996:	6819      	ldr	r1, [r3, #0]
 8008998:	4602      	mov	r2, r0
 800899a:	b909      	cbnz	r1, 80089a0 <_sbrk+0xc>
 800899c:	4903      	ldr	r1, [pc, #12]	; (80089ac <_sbrk+0x18>)
 800899e:	6019      	str	r1, [r3, #0]
 80089a0:	6818      	ldr	r0, [r3, #0]
 80089a2:	4402      	add	r2, r0
 80089a4:	601a      	str	r2, [r3, #0]
 80089a6:	4770      	bx	lr
 80089a8:	20003e4c 	.word	0x20003e4c
 80089ac:	20003e54 	.word	0x20003e54

080089b0 <_exit>:
 80089b0:	e7fe      	b.n	80089b0 <_exit>
	...

080089b4 <_init>:
 80089b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80089b6:	bf00      	nop
 80089b8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80089ba:	bc08      	pop	{r3}
 80089bc:	469e      	mov	lr, r3
 80089be:	4770      	bx	lr

080089c0 <_fini>:
 80089c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80089c2:	bf00      	nop
 80089c4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80089c6:	bc08      	pop	{r3}
 80089c8:	469e      	mov	lr, r3
 80089ca:	4770      	bx	lr
